[
  {
    "id": "ch00",
    "number": 0,
    "title": "Introducción",
    "titleEs": "Introducción",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Creemos que estamos creando el sistema para nuestros propios propósitos. Creemos que lo estamos haciendo a nuestra propia imagen... Pero la computador...",
    "isProject": false,
    "totalXP": 230,
    "lessons": [
      {
        "id": "ch00-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch00-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Creemos que estamos creando el sistema para nuestros propios propósitos. Creemos que lo estamos haciendo a nuestra propia imagen... Pero la computadora en realidad no es como nosotros. Es una proyección de una parte muy pequeña de nosotros mismos: esa parte dedicada a la lógica, el orden, la regla y la claridad. Ellen Ullman, Cerca de la máquina: Tecnofilia y sus Descontentos"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Introducción __ Eloquent JavaScript_files/chapter_picture_00.jpg",
                "alt": "Ilustración de un destornillador junto a una placa de circuitos de aproximadamente el mismo tamaño"
              },
              {
                "type": "paragraph",
                "content": "Este es un libro sobre cómo instruir a computadoras. Las computadoras son tan comunes como los destornilladores hoy en día, pero son bastante más complejas, y hacer que hagan lo que quieres no siempre es fácil."
              }
            ]
          },
          {
            "id": "ch00-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si la tarea que tienes para tu computadora es común, bien entendida, como mostrarte tu correo electrónico o actuar como una calculadora, puedes abrir la aplicación correspondiente y ponerte a trabajar. Pero para tareas únicas o abiertas, a menudo no hay una aplicación adecuada."
              },
              {
                "type": "paragraph",
                "content": "Ahí es donde entra en juego la programación. <em>Programar</em> es el acto de construir un <em>programa</em>—un conjunto de instrucciones precisas que le dicen a una computadora qué hacer. Debido a que las computadoras son bestias tontas y pedantes, programar es fundamentalmente tedioso y frustrante."
              },
              {
                "type": "paragraph",
                "content": "Por suerte, si puedes superar ese hecho—e incluso disfrutar del rigor de pensar en términos que las máquinas tontas pueden manejar—programar puede ser gratificante. Te permite hacer cosas en segundos que te tomarían <em>una eternidad</em> a mano. Es una forma de hacer que tu herramienta informática haga cosas que antes no podía hacer. Además, se convierte en un maravilloso juego de resolución de acertijos y pensamiento abstracto."
              }
            ]
          },
          {
            "id": "ch00-l0-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría de la programación se realiza con lenguajes de programación. Un <em>lenguaje de programación</em> es un lenguaje artificialmente construido utilizado para instruir a las computadoras. Es interesante que la forma más efectiva que hemos encontrado para comunicarnos con una computadora se base tanto en la forma en que nos comunicamos entre nosotros. Al igual que los idiomas humanos, los lenguajes informáticos permiten combinar palabras y frases de nuevas formas, lo que permite expresar conceptos cada vez más nuevos."
              },
              {
                "type": "paragraph",
                "content": "En un momento dado, las interfaces basadas en lenguaje, como los <em>prompts</em> de BASIC y DOS de los años 1980 y 1990, eran el principal método de interactuar con las computadoras. Para el uso informático rutinario, estas se han reemplazado en gran medida por interfaces visuales, que son más fáciles de aprender pero ofrecen menos libertad. Pero si sabes dónde buscar, los lenguajes todavía están ahí. Uno de ellos, <em>JavaScript</em>, está integrado en cada navegador web moderno—y por lo tanto está disponible en casi todos los dispositivos."
              },
              {
                "type": "paragraph",
                "content": "Este libro intentará que te familiarices lo suficiente con este lenguaje para hacer cosas útiles y entretenidas con él."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch00-l1",
        "title": "Sobre la programación",
        "sections": [
          {
            "id": "ch00-l1-s0",
            "title": "Sobre la programación",
            "content": [
              {
                "type": "paragraph",
                "content": "Además de explicar JavaScript, presentaré los principios básicos de la programación. Resulta que programar es difícil. Las reglas fundamentales son simples y claras, pero los programas construidos sobre estas reglas tienden a volverse lo suficientemente complejos como para introducir sus propias reglas y complejidades. Estás construyendo tu propio laberinto, de alguna manera, y fácilmente puedes perderte en él."
              },
              {
                "type": "paragraph",
                "content": "Habrá momentos en los que leer este libro resulte terriblemente frustrante. Si eres nuevo en la programación, habrá mucho material nuevo que asimilar. Gran parte de este material luego se combinará de maneras que requieren que hagas conexiones adicionales."
              },
              {
                "type": "paragraph",
                "content": "Depende de ti hacer el esfuerzo necesario. Cuando te cueste seguir el libro, no saques conclusiones precipitadas sobre tus propias capacidades. Estás bien, simplemente necesitas seguir adelante. Tómate un descanso, vuelve a leer algo de material y asegúrate de leer y comprender los programas de ejemplo y los ejercicios. Aprender es un trabajo duro, pero todo lo que aprendas será tuyo y facilitará aún más el aprendizaje futuro."
              }
            ]
          },
          {
            "id": "ch00-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "blockquote",
                "content": "Cuando la acción se vuelve poco rentable, recopila información; cuando la información se vuelve poco rentable, duerme."
              },
              {
                "type": "paragraph",
                "content": "Un programa es muchas cosas. Es un trozo de texto escrito por un programador, es la fuerza directiva que hace que la computadora haga lo que hace, es información en la memoria de la computadora, y al mismo tiempo controla las acciones realizadas en esta memoria. Las analogías que intentan comparar los programas con objetos familiares tienden a quedarse cortas. Una comparación vagamente adecuada es comparar un programa con una máquina: suelen estar implicadas muchas partes separadas y, para hacer que todo funcione, debemos considerar las formas en que estas partes se interconectan y contribuyen a la operación del conjunto."
              },
              {
                "type": "paragraph",
                "content": "Una computadora es una máquina física que actúa como anfitriona de estas máquinas inmateriales. Las computadoras mismas solo pueden hacer cosas increíblemente sencillas. La razón por la que son tan útiles es que hacen estas cosas a una velocidad increíblemente alta. Un programa puede combinar ingeniosamente un número enorme de estas acciones simples para hacer cosas muy complicadas."
              }
            ]
          },
          {
            "id": "ch00-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un programa es una construcción del pensamiento. Es gratuito de construir, es liviano y crece fácilmente bajo nuestras manos al teclear. Pero a medida que un programa crece, también lo hace su complejidad. La habilidad de programar es la habilidad de construir programas que no te confundan a ti mismo. Los mejores programas son aquellos que logran hacer algo interesante mientras siguen siendo fáciles de entender."
              },
              {
                "type": "paragraph",
                "content": "Algunos programadores creen que esta complejidad se gestiona mejor utilizando solo un conjunto pequeño de técnicas bien comprendidas en sus programas. Han compuesto reglas estrictas (“mejores prácticas”) que prescriben la forma que deberían tener los programas y se mantienen cuidadosamente dentro de su pequeña zona segura."
              },
              {
                "type": "paragraph",
                "content": "Esto no solo es aburrido, es inefectivo. A menudo, nuevos problemas requieren soluciones nuevas. El campo de la programación es joven y aún se está desarrollando rápidamente, y es lo suficientemente variado como para tener espacio para enfoques radicalmente diferentes. Hay muchos errores terribles que cometer en el diseño de programas, y deberías ir y cometerlos al menos una vez para entenderlos. Una noción de cómo es un buen programa se desarrolla con la práctica, no se aprende de una lista de reglas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch00-l2",
        "title": "Por qué importa el lenguaje",
        "sections": [
          {
            "id": "ch00-l2-s0",
            "title": "Por qué importa el lenguaje",
            "content": [
              {
                "type": "paragraph",
                "content": "Al principio, en los inicios de la informática, no existían los lenguajes de programación. Los programas lucían algo así:"
              },
              {
                "type": "paragraph",
                "content": "Este es un programa para sumar los números del 1 al 10 y mostrar el resultado: <code>1 + 2 + .<wbr>.<wbr>.<wbr> + 10 = 55</code>. Podría ejecutarse en una máquina hipotética simple. Para programar los primeros ordenadores, era necesario configurar grandes conjuntos de interruptores en la posición correcta o perforar agujeros en tiras de cartón y alimentarlos al ordenador. Puedes imaginar lo tedioso y propenso a errores que era este procedimiento. Incluso escribir programas simples requería mucha astucia y disciplina. Los complejos eran casi inconcebibles."
              },
              {
                "type": "paragraph",
                "content": "Por supuesto, introducir manualmente estos patrones arcanos de bits (los unos y ceros) hacía que el programador se sintiera como un mago poderoso. Y eso debe valer algo en términos de satisfacción laboral."
              }
            ]
          },
          {
            "id": "ch00-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada línea del programa anterior contiene una única instrucción. Podría escribirse en español de la siguiente manera:"
              },
              {
                "type": "list",
                "content": [
                  "Almacena el número 0 en la ubicación de memoria 0.",
                  "Almacena el número 1 en la ubicación de memoria 1.",
                  "Almacena el valor de la ubicación de memoria 1 en la ubicación de memoria 2.",
                  "Resta el número 11 al valor en la ubicación de memoria 2.",
                  "Si el valor en la ubicación de memoria 2 es el número 0, continúa con la instrucción 9.",
                  "Suma el valor de la ubicación de memoria 1 a la ubicación de memoria 0.",
                  "Añade el número 1 al valor de la ubicación de memoria 1.",
                  "Continúa con la instrucción 3.",
                  "Muestra el valor de la ubicación de memoria 0."
                ]
              },
              {
                "type": "paragraph",
                "content": "Aunque eso ya es más legible que la sopa de bits, sigue siendo bastante confusa. Usar nombres en lugar de números para las instrucciones y las ubicaciones de memoria ayuda:"
              }
            ]
          },
          {
            "id": "ch00-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¿Puedes ver cómo funciona el programa en este punto? Las dos primeras líneas asignan los valores iniciales a dos ubicaciones de memoria: <code>total</code> se utilizará para construir el resultado de la computación, y <code>count</code> llevará la cuenta del número que estamos observando en ese momento. Las líneas que utilizan <code>compare</code> probablemente sean las más confusas. El programa quiere ver si <code>count</code> es igual a 11 para decidir si puede dejar de ejecutarse. Debido a que nuestra máquina hipotética es bastante primitiva, solo puede comprobar si un número es cero y tomar una decisión en función de ese valor. Por lo tanto, utiliza la ubicación de memoria etiquetada como <code>compare</code> para calcular el valor de <code>count - 11</code> y tomar una decisión basada en ese valor. Las siguientes dos líneas suman el valor de <code>count</code> al resultado e incrementan <code>count</code> en 1 cada vez que el programa decide que <code>count</code> aún no es 11. Aquí está el mismo programa en JavaScript:"
              },
              {
                "type": "paragraph",
                "content": "Esta versión nos proporciona algunas mejoras. Lo más importante es que ya no es necesario especificar la forma en que queremos que el programa salte hacia adelante y hacia atrás; la construcción <code>while</code> se encarga de eso. Continúa ejecutando el bloque (entre llaves) debajo de él siempre y cuando se cumpla la condición que se le ha dado. Esa condición es <code>count &lt;= 10</code>, lo que significa “el recuento es menor o igual a 10”. Ya no tenemos que crear un valor temporal y compararlo con cero, lo cual era simplemente un detalle no interesante. Parte del poder de los lenguajes de programación es que pueden encargarse de los detalles no interesantes por nosotros."
              },
              {
                "type": "paragraph",
                "content": "Al final del programa, después de que la construcción <code>while</code> haya terminado, se utiliza la operación <code>console.log</code> para escribir el resultado."
              }
            ]
          },
          {
            "id": "ch00-l2-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Finalmente, así es como podría verse el programa si tuviéramos a nuestra disposición las operaciones convenientes <code>range</code> y <code>sum</code>, que respectivamente crean una colección de números dentro de un rango y calculan la suma de una colección de números:"
              },
              {
                "type": "paragraph",
                "content": "La moraleja de esta historia es que el mismo programa puede expresarse de formas largas y cortas, ilegibles y legibles. La primera versión del programa era extremadamente críptica, mientras que esta última es casi en inglés: registra (<code>log</code>) la <code>sum</code> del <code>range</code> de números del 1 al 10. (Veremos en capítulos posteriores cómo definir operaciones como <code>suma</code> y <code>rango</code>.)"
              },
              {
                "type": "paragraph",
                "content": "Un buen lenguaje de programación ayuda al programador al permitirle hablar sobre las acciones que la computadora debe realizar a un nivel más alto. Ayuda a omitir detalles, proporciona bloques de construcción convenientes (como <code>while</code> y <code>console.log</code>), te permite definir tus propios bloques de construcción (como <code>suma</code> y <code>rango</code>), y hace que esos bloques sean fáciles de componer."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch00-l3",
        "title": "¿Qué es JavaScript?",
        "sections": [
          {
            "id": "ch00-l3-s0",
            "title": "¿Qué es JavaScript?",
            "content": [
              {
                "type": "paragraph",
                "content": "JavaScript fue introducido en 1995 como una forma de agregar programas a páginas web en el navegador Netscape Navigator. Desde entonces, el lenguaje ha sido adoptado por todos los demás navegadores web gráficos principales. Ha hecho posibles aplicaciones web modernas, es decir, aplicaciones con las que puedes interactuar directamente sin tener que recargar la página para cada acción. JavaScript también se utiliza en sitios web más tradicionales para proporcionar distintas formas de interactividad e ingenio."
              },
              {
                "type": "paragraph",
                "content": "Es importante tener en cuenta que JavaScript casi no tiene nada que ver con el lenguaje de programación llamado Java. El nombre similar fue inspirado por consideraciones de marketing en lugar de un buen juicio. Cuando se estaba introduciendo JavaScript, el lenguaje Java se estaba comercializando mucho y ganaba popularidad. Alguien pensó que era una buena idea intentar aprovechar este éxito. Ahora estamos atrapados con el nombre."
              },
              {
                "type": "paragraph",
                "content": "Después de su adopción fuera de Netscape, se escribió un documento estándar para describir la forma en que debería funcionar el lenguaje JavaScript para que las diversas piezas de software que afirmaban soportar JavaScript pudieran asegurarse de que realmente proporcionaban el mismo lenguaje. Esto se llama el estándar ECMAScript, según la organización Ecma International que llevó a cabo la estandarización. En la práctica, los términos ECMAScript y JavaScript se pueden usar indistintamente, son dos nombres para el mismo lenguaje."
              }
            ]
          },
          {
            "id": "ch00-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay quienes dirán cosas <em>terribles</em> sobre JavaScript. Muchas de esas cosas son ciertas. Cuando me pidieron que escribiera algo en JavaScript por primera vez, rápidamente llegué a detestarlo. Aceptaba casi cualquier cosa que escribía pero lo interpretaba de una manera completamente diferente a lo que yo quería decir. Esto tenía mucho que ver con el hecho de que no tenía ni idea de lo que estaba haciendo, por supuesto, pero hay un problema real aquí: JavaScript es ridículamente liberal en lo que permite. La idea detrás de este diseño era que haría la programación en JavaScript más fácil para principiantes. En realidad, esto hace que encontrar problemas en tus programas sea más difícil porque el sistema no te los señalará."
              },
              {
                "type": "paragraph",
                "content": "Esta flexibilidad también tiene sus ventajas. Deja espacio para técnicas imposibles en lenguajes más rígidos y permite un estilo de programación agradable e informal. Después de aprender el lenguaje adecuadamente y trabajar con él durante un tiempo, ha llegado a realmente <em>gustarme</em> JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Ha habido varias versiones de JavaScript. La versión ECMAScript 3 fue la versión ampliamente soportada durante el ascenso al dominio de JavaScript, aproximadamente entre 2000 y 2010. Durante este tiempo, se estaba trabajando en una versión ambiciosa 4, la cual planeaba una serie de mejoras y extensiones radicales al lenguaje. Cambiar un lenguaje vivo y ampliamente utilizado de esa manera resultó ser políticamente difícil, y el trabajo en la versión 4 fue abandonado en 2008. Una versión 5, mucho menos ambiciosa, que solo realizaba algunas mejoras no controversiales, salió en 2009. En 2015, salió la versión 6, una actualización importante que incluía algunas de las ideas previstas para la versión 4. Desde entonces, hemos tenido nuevas actualizaciones pequeñas cada año."
              }
            ]
          },
          {
            "id": "ch00-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El hecho de que JavaScript esté evolucionando significa que los navegadores tienen que mantenerse constantemente al día. Si estás usando un navegador más antiguo, es posible que no admita todas las funciones. Los diseñadores del lenguaje se aseguran de no realizar cambios que puedan romper programas existentes, por lo que los nuevos navegadores aún pueden ejecutar programas antiguos. En este libro, estoy utilizando la versión 2023 de JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Los navegadores web no son las únicas plataformas en las que se utiliza JavaScript. Algunas bases de datos, como MongoDB y CouchDB, utilizan JavaScript como su lenguaje de secuencias de comandos y consulta. Varias plataformas para programación de escritorio y servidores, especialmente el proyecto Node.js (el tema del Capítulo 20), proporcionan un entorno para programar en JavaScript fuera del navegador."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch00-l4",
        "title": "Código y qué hacer con él",
        "sections": [
          {
            "id": "ch00-l4-s0",
            "title": "Código y qué hacer con él",
            "content": [
              {
                "type": "paragraph",
                "content": "El <em>código</em> es el texto que constituye los programas. La mayoría de los capítulos en este libro contienen bastante código. Creo que leer código y escribir código son partes indispensables de aprender a programar. Intenta no solo echar un vistazo a los ejemplos, léelos atentamente y entiéndelos. Esto puede ser lento y confuso al principio, pero te prometo que pronto le tomarás la mano. Lo mismo ocurre con los ejercicios. No des por sentado que los entiendes hasta que hayas escrito realmente una solución que funcione."
              },
              {
                "type": "paragraph",
                "content": "Te recomiendo que pruebes tus soluciones a los ejercicios en un intérprete de JavaScript real. De esta manera, obtendrás comentarios inmediatos sobre si lo que estás haciendo funciona, y, espero, te tentarán a experimentar y a ir más allá de los ejercicios."
              },
              {
                "type": "paragraph",
                "content": "Cuando leas este libro en tu navegador, puedes editar (y ejecutar) todos los programas de ejemplo haciendo clic en ellos."
              }
            ]
          },
          {
            "id": "ch00-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ejecutar los programas definidos en este libro fuera del sitio web del libro requiere cierto cuidado. Muchos ejemplos son independientes y deberían funcionar en cualquier entorno de JavaScript. Pero el código en los capítulos posteriores a menudo está escrito para un entorno específico (navegador o Node.js) y solo puede ejecutarse allí. Además, muchos capítulos definen programas más grandes, y las piezas de código que aparecen en ellos dependen unas de otras o de archivos externos. El sandbox en el sitio web proporciona enlaces a archivos ZIP que contienen todos los scripts y archivos de datos necesarios para ejecutar el código de un capítulo dado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch00-l5",
        "title": "Visión general de este libro",
        "sections": [
          {
            "id": "ch00-l5-s0",
            "title": "Visión general de este libro",
            "content": [
              {
                "type": "paragraph",
                "content": "Este libro consta aproximadamente de tres partes. Los primeros 12 capítulos tratan sobre el lenguaje JavaScript. Los siguientes siete capítulos son acerca de los navegadores web y la forma en que se utiliza JavaScript para programarlos. Por último, dos capítulos están dedicados a Node.js, otro entorno para programar en JavaScript. Hay cinco <em>capítulos de proyectos</em> en el libro que describen programas de ejemplo más grandes para darte una idea de la programación real."
              },
              {
                "type": "paragraph",
                "content": "La parte del lenguaje del libro comienza con cuatro capítulos que introducen la estructura básica del lenguaje JavaScript. Discuten las estructuras de control (como la palabra <code>while</code> que viste en esta introducción), las funciones (escribir tus propios bloques de construcción) y las estructuras de datos. Después de estos, serás capaz de escribir programas básicos. Luego, los Capítulos 5 y 6 introducen técnicas para usar funciones y objetos para escribir código más <em>abstracto</em> y mantener la complejidad bajo control. Después de un primer capítulo del proyecto que construye un robot de entrega rudimentario, la parte del lenguaje del libro continúa con capítulos sobre manejo de errores y corrección de errores, expresiones regulares (una herramienta importante para trabajar con texto), modularidad (otra defensa contra la complejidad) y programación asíncrona (tratando con eventos que toman tiempo). El segundo capítulo del proyecto, donde implementamos un lenguaje de programación, concluye la primera parte del libro."
              },
              {
                "type": "paragraph",
                "content": "La segunda parte del libro, de los capítulos 13 a 19, describe las herramientas a las que tiene acceso JavaScript en un navegador. Aprenderás a mostrar cosas en la pantalla (Capítulos 14 y 17), responder a la entrada del usuario (Capítulo 15) y comunicarte a través de la red (Capítulo 18). Nuevamente hay dos capítulos de proyecto en esta parte, construyendo un juego de plataformas y un programa de pintura de píxeles."
              }
            ]
          },
          {
            "id": "ch00-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El Capítulo 20 describe Node.js, y el Capítulo 21 construye un pequeño sitio web utilizando esa herramienta."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch00-l6",
        "title": "Convenciones tipográficas",
        "sections": [
          {
            "id": "ch00-l6-s0",
            "title": "Convenciones tipográficas",
            "content": [
              {
                "type": "paragraph",
                "content": "En este libro, el texto escrito en una fuente <code>monoespaciada</code> representará elementos de programas. A veces estos son fragmentos autosuficientes, y a veces simplemente se refieren a partes de un programa cercano. Los programas (de los cuales ya has visto algunos) se escriben de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "A veces, para mostrar la salida que produce un programa, la salida esperada se escribe después, con dos barras inclinadas y una flecha al frente."
              },
              {
                "type": "paragraph",
                "content": "¡Buena suerte!"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      }
    ]
  },
  {
    "id": "ch01",
    "number": 1,
    "title": "Valores, Tipos y Operadores",
    "titleEs": "Valores, Tipos y Operadores",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Debajo de la superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armonía, los electrones se dispersan y se rea...",
    "isProject": false,
    "totalXP": 310,
    "lessons": [
      {
        "id": "ch01-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch01-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Debajo de la superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armonía, los electrones se dispersan y se reagrupan. Las formas en el monitor no son más que ondas en el agua. La esencia permanece invisible debajo. Master Yuan-Ma, El Libro de la Programación"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Valores, Tipos y Operadores __ Eloquent JavaScript_files/chapter_picture_1.jpg",
                "alt": "Una foto de un mar de bits"
              },
              {
                "type": "paragraph",
                "content": "En el mundo de la computadora, solo existe data. Puedes leer data, modificar data, crear nueva data, pero aquello que no es data no puede ser mencionado. Toda esta data se almacena como largas secuencias de bits y, por lo tanto, es fundamentalmente similar."
              }
            ]
          },
          {
            "id": "ch01-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "<em>Los bits</em> son cualquier tipo de cosas de dos valores, generalmente descritos como ceros y unos. Dentro de la computadora, toman formas como una carga eléctrica alta o baja, una señal fuerte o débil, o un punto brillante u opaco en la superficie de un CD. Cualquier pieza de información discreta puede reducirse a una secuencia de ceros y unos y por lo tanto representarse en bits."
              },
              {
                "type": "paragraph",
                "content": "Por ejemplo, podemos expresar el número 13 en bits. Esto funciona de la misma manera que un número decimal, pero en lugar de diez dígitos diferentes, tenemos solo 2, y el peso de cada uno aumenta por un factor de 2 de derecha a izquierda. Aquí están los bits que componen el número 13, con los pesos de los dígitos mostrados debajo de ellos:"
              },
              {
                "type": "paragraph",
                "content": "Ese es el número binario 00001101. Sus dígitos no nulos representan 8, 4 y 1, y suman 13."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch01-l1",
        "title": "Valores",
        "sections": [
          {
            "id": "ch01-l1-s0",
            "title": "Valores",
            "content": [
              {
                "type": "paragraph",
                "content": "Imagina una mar de bits—un océano de ellos. Una computadora moderna típica tiene más de 100 mil millones de bits en su almacenamiento de datos volátil (memoria de trabajo). El almacenamiento no volátil (el disco duro o equivalente) tiende a tener aún unos cuantos órdenes de magnitud más."
              },
              {
                "type": "paragraph",
                "content": "Para poder trabajar con tales cantidades de bits sin perderse, los separamos en trozos que representan piezas de información. En un entorno de JavaScript, esos trozos se llaman <em>valores</em>. Aunque todos los valores están hechos de bits, desempeñan roles diferentes. Cada valor tiene un tipo que determina su función. Algunos valores son números, otros son fragmentos de texto, otros son funciones, y así sucesivamente."
              },
              {
                "type": "paragraph",
                "content": "Para crear un valor, simplemente debes invocar su nombre. Esto es conveniente. No tienes que recolectar material de construcción para tus valores ni pagar por ellos. Solo solicitas uno, y ¡zas!, lo tienes. Por supuesto, los valores no se crean realmente de la nada. Cada uno tiene que almacenarse en algún lugar, y si deseas usar gigantescas cantidades de ellos al mismo tiempo, podrías quedarte sin memoria de computadora. Afortunadamente, este es un problema solo si los necesitas todos simultáneamente. Tan pronto como dejes de usar un valor, se disipará, dejando atrás sus bits para ser reciclados como material de construcción para la próxima generación de valores. El resto de este capítulo presenta los elementos atómicos de los programas de JavaScript, es decir, los tipos de valores simples y los operadores que pueden actuar sobre dichos valores."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch01-l2",
        "title": "Números",
        "sections": [
          {
            "id": "ch01-l2-s0",
            "title": "Números",
            "content": [
              {
                "type": "paragraph",
                "content": "Los valores del tipo <em>number</em> son, como era de esperar, valores numéricos. En un programa de JavaScript, se escriben de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "Usar esto en un programa hará que el patrón de bits para el número 13 exista en la memoria del ordenador."
              },
              {
                "type": "paragraph",
                "content": "JavaScript utiliza un número fijo de bits, 64 de ellos, para almacenar un único valor numérico. Hay un número limitado de patrones que puedes hacer con 64 bits, lo que limita la cantidad de números diferentes que se pueden representar. Con <em>N</em> dígitos decimales, puedes representar 10<sup>N</sup> números. De manera similar, dada una cifra de 64 dígitos binarios, puedes representar 2<sup>64</sup> números diferentes, que son alrededor de 18 mil trillones (un 18 seguido de 18 ceros). Eso es mucho."
              }
            ]
          },
          {
            "id": "ch01-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La memoria de la computadora solía ser mucho más pequeña, y la gente solía utilizar grupos de 8 o 16 bits para representar sus números. Era fácil tener un <em>desbordamiento</em> accidental con números tan pequeños, terminando con un número que no encajaba en la cantidad dada de bits. Hoy en día, incluso las computadoras que caben en tu bolsillo tienen mucha memoria, por lo que puedes utilizar trozos de 64 bits y solo necesitas preocuparte por el desbordamiento cuando lidias con números realmente astronómicos."
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, no todos los números enteros menores que 18 mil trillones encajan en un número de JavaScript. Esos bits también almacenan números negativos, por lo que un bit indica el signo del número. Un problema más grande es representar números no enteros. Para hacer esto, algunos de los bits se utilizan para almacenar la posición del punto decimal. El número entero máximo real que se puede almacenar está más en el rango de 9 cuatrillones (15 ceros), que sigue siendo increíblemente grande."
              },
              {
                "type": "paragraph",
                "content": "Los números fraccionarios se escriben usando un punto:"
              }
            ]
          },
          {
            "id": "ch01-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para números muy grandes o muy pequeños, también puedes usar notación científica agregando una <em>e</em> (de <em>exponente</em>), seguida del exponente del número:"
              },
              {
                "type": "paragraph",
                "content": "Eso es 2.998 × 10<sup>8</sup> = 299,800,000."
              },
              {
                "type": "paragraph",
                "content": "Los cálculos con números enteros (también llamados <em>enteros</em>) que son más pequeños que los mencionados 9 cuatrillones siempre serán precisos. Desafortunadamente, los cálculos con números fraccionarios generalmente no lo son. Así como π (pi) no puede expresarse con precisión mediante un número finito de dígitos decimales, muchos números pierden algo de precisión cuando solo están disponibles 64 bits para almacenarlos. Es una lástima, pero solo causa problemas prácticos en situaciones específicas. Lo importante es ser consciente de esto y tratar los números digitales fraccionarios como aproximaciones, no como valores precisos."
              }
            ]
          },
          {
            "id": "ch01-l2-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Lo principal que se puede hacer con los números es la aritmética. Operaciones aritméticas como la suma o la multiplicación toman dos valores numéricos y producen un nuevo número a partir de ellos. Así es como se ven en JavaScript:"
              },
              {
                "type": "paragraph",
                "content": "Los símbolos <code>+</code> y <code>*</code> se llaman <em>operadores</em>. El primero representa la suma y el segundo representa la multiplicación. Colocar un operador entre dos valores aplicará ese operador a esos valores y producirá un nuevo valor."
              },
              {
                "type": "paragraph",
                "content": "¿Significa este ejemplo “Sumar 4 y 100, y luego multiplicar el resultado por 11”, o se realiza primero la multiplicación antes de la suma? Como habrás adivinado, la multiplicación se realiza primero. Como en matemáticas, puedes cambiar esto envolviendo la suma entre paréntesis:"
              }
            ]
          },
          {
            "id": "ch01-l2-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para la resta, está el operador <code>-</code>. La división se puede hacer con el operador <code>/</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando los operadores aparecen juntos sin paréntesis, el orden en que se aplican se determina por la <em>precedencia</em> de los operadores. El ejemplo muestra que la multiplicación se realiza antes que la suma. El operador <code>/</code> tiene la misma precedencia que <code>*</code>. Igualmente, <code>+</code> y <code>-</code> tienen la misma precedencia. Cuando varios operadores con la misma precedencia aparecen uno al lado del otro, como en <code>1 - 2 + 1</code>, se aplican de izquierda a derecha: <code>(1 - 2) + 1</code>."
              },
              {
                "type": "paragraph",
                "content": "No te preocupes demasiado por estas reglas de precedencia. Cuando tengas dudas, simplemente agrega paréntesis."
              }
            ]
          },
          {
            "id": "ch01-l2-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay un operador aritmético más, que quizás no reconozcas de inmediato. El símbolo <code>%</code> se utiliza para representar la operación de <em>residuo</em>. <code>X % Y</code> es el residuo de dividir <code>X</code> por <code>Y</code>. Por ejemplo, <code>314 % 100</code> produce <code>14</code>, y <code>144 % 12</code> da <code>0</code>. La precedencia del operador de residuo es la misma que la de multiplicación y división. También verás a menudo a este operador referido como <em>módulo</em>."
              },
              {
                "type": "paragraph",
                "content": "Hay tres valores especiales en JavaScript que se consideran números pero no se comportan como números normales. Los dos primeros son <code>Infinity</code> y <code>-Infinity</code>, que representan el infinito positivo y negativo. <code>Infinity - 1</code> sigue siendo <code>Infinity</code>, y así sucesivamente. Sin embargo, no confíes demasiado en los cálculos basados en infinito. No es matemáticamente sólido y rápidamente te llevará al siguiente número especial: <code>NaN</code>."
              },
              {
                "type": "paragraph",
                "content": "<code>NaN</code> significa “no es un número”, aunque <em>es</em> un valor del tipo numérico. Obtendrás este resultado cuando, por ejemplo, intentes calcular <code>0 / 0</code> (cero dividido por cero), <code>Infinity - Infinity</code>, u cualquier otra operación numérica que no produzca un resultado significativo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      },
      {
        "id": "ch01-l3",
        "title": "Cadenas",
        "sections": [
          {
            "id": "ch01-l3-s0",
            "title": "Cadenas",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente tipo de dato básico es la <em>cadena</em>. Las cadenas se utilizan para representar texto. Se escriben encerrando su contenido entre comillas."
              },
              {
                "type": "paragraph",
                "content": "Puedes usar comillas simples, comillas dobles o acentos graves para marcar las cadenas, siempre y cuando las comillas al principio y al final de la cadena coincidan."
              },
              {
                "type": "paragraph",
                "content": "Puedes poner casi cualquier cosa entre comillas para que JavaScript genere un valor de cadena a partir de ello. Pero algunos caracteres son más difíciles. Puedes imaginar lo complicado que sería poner comillas entre comillas, ya que parecerían el final de la cadena. <em>Saltos de línea</em> (los caracteres que obtienes al presionar <span class=\"keyname\">enter</span>) solo se pueden incluir cuando la cadena está entre acentos graves (<code>`</code>)."
              }
            ]
          },
          {
            "id": "ch01-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para poder incluir dichos caracteres en una cadena, se utiliza la siguiente notación: una barra invertida (<code>\\</code>) dentro de un texto entre comillas indica que el carácter posterior tiene un significado especial. Esto se llama <em>escapar</em> el carácter. Una comilla que va precedida por una barra invertida no finalizará la cadena, sino que formará parte de ella. Cuando un carácter <code>n</code> aparece después de una barra invertida, se interpreta como un salto de línea. De manera similar, un <code>t</code> después de una barra invertida significa un carácter de tabulación. Toma la siguiente cadena:"
              },
              {
                "type": "paragraph",
                "content": "Este es el texto real de esa cadena:"
              },
              {
                "type": "paragraph",
                "content": "Por supuesto, hay situaciones en las que deseas que una barra invertida en una cadena sea simplemente una barra invertida, no un código especial. Si dos barras invertidas van seguidas, se colapsarán juntas y solo quedará una en el valor de cadena resultante. Así es como se puede expresar la cadena “<em>Un carácter de nueva línea se escribe como <code>\"</code>\\n<code>\"</code>.</em>”:"
              }
            ]
          },
          {
            "id": "ch01-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las cadenas también deben ser modeladas como una serie de bits para poder existir dentro de la computadora. La forma en que JavaScript lo hace se basa en el estándar <em>Unicode</em>. Este estándar asigna un número a prácticamente cada carácter que puedas necesitar, incluidos los caracteres griegos, árabes, japoneses, armenios, y así sucesivamente. Si tenemos un número para cada carácter, una cadena puede ser descrita por una secuencia de números. Y eso es lo que hace JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, hay una complicación: la representación de JavaScript utiliza 16 bits por elemento de cadena, lo que puede describir hasta 2<sup>16</sup> caracteres diferentes. Sin embargo, Unicode define más caracteres que eso —aproximadamente el doble, en este momento. Por lo tanto, algunos caracteres, como muchos emoji, ocupan dos “posiciones de caracteres” en las cadenas de JavaScript. Volveremos a esto en el Capítulo 5."
              },
              {
                "type": "paragraph",
                "content": "Las cadenas no se pueden dividir, multiplicar o restar. El operador <code>+</code> se puede usar en ellas, no para sumar, sino para <em>concatenar</em> —unir dos cadenas. La siguiente línea producirá la cadena <code>\"concatenar\"</code>:"
              }
            ]
          },
          {
            "id": "ch01-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los valores de cadena tienen una serie de funciones asociadas (<em>métodos</em>) que se pueden utilizar para realizar otras operaciones con ellos. Hablaré más sobre esto en el Capítulo 4."
              },
              {
                "type": "paragraph",
                "content": "Las cadenas escritas con comillas simples o dobles se comportan de manera muy similar, la única diferencia radica en qué tipo de comilla necesitas escapar dentro de ellas. Las cadenas entre acentos graves, generalmente llamadas <em>template literals</em>, pueden hacer algunas cosas más. Aparte de poder abarcar varias líneas, también pueden incrustar otros valores."
              },
              {
                "type": "paragraph",
                "content": "Cuando escribes algo dentro de <code>${}</code> en una plantilla literal, su resultado se calculará, se convertirá en una cadena y se incluirá en esa posición. Este ejemplo produce “<em>la mitad de 100 es 50</em>”."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch01-l4",
        "title": "Operadores unarios",
        "sections": [
          {
            "id": "ch01-l4-s0",
            "title": "Operadores unarios",
            "content": [
              {
                "type": "paragraph",
                "content": "No todos los operadores son símbolos. Algunos se escriben como palabras. Un ejemplo es el operador <code>typeof</code>, que produce un valor de cadena que indica el tipo del valor que le proporcionas."
              },
              {
                "type": "paragraph",
                "content": "Utilizaremos <code>console.log</code> en ejemplos de código para indicar que queremos ver el resultado de evaluar algo. Más sobre eso en el próximo capítulo."
              },
              {
                "type": "paragraph",
                "content": "Los otros operadores mostrados hasta ahora en este capítulo operaron sobre dos valores, pero <code>typeof</code> toma solo uno. Los operadores que utilizan dos valores se llaman operadores <em>binarios</em>, mientras que aquellos que toman uno se llaman operadores <em>unarios</em>. El operador menos se puede usar tanto como un operador binario como un operador unario."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch01-l5",
        "title": "Valores booleanos",
        "sections": [
          {
            "id": "ch01-l5-s0",
            "title": "Valores booleanos",
            "content": [
              {
                "type": "paragraph",
                "content": "A menudo es útil tener un valor que distinga solo entre dos posibilidades, como “sí\" y “no” o “encendido” y “apagado”. Para este propósito, JavaScript tiene un tipo <em>Booleano</em>, que tiene solo dos valores, true y false, escritos como esas palabras."
              },
              {
                "type": "paragraph",
                "content": "Aquí hay una forma de producir valores booleanos:"
              },
              {
                "type": "paragraph",
                "content": "Los signos <code>&gt;</code> y <code>&lt;</code> son símbolos tradicionales para “es mayor que” y “es menor que”, respectivamente. Son operadores binarios. Aplicarlos da como resultado un valor booleano que indica si son verdaderos en este caso."
              }
            ]
          },
          {
            "id": "ch01-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las cadenas se pueden comparar de la misma manera:"
              },
              {
                "type": "paragraph",
                "content": "La forma en que se ordenan las cadenas es aproximadamente alfabética pero no es realmente lo que esperarías ver en un diccionario: las letras mayúsculas son siempre “menores” que las minúsculas, por lo que <code>\"Z\" &lt; \"a\"</code>, y los caracteres no alfabéticos (!, -, y así sucesivamente) también se incluyen en la ordenación. Al comparar cadenas, JavaScript recorre los caracteres de izquierda a derecha, comparando los códigos Unicode uno por uno."
              },
              {
                "type": "paragraph",
                "content": "Otros operadores similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code> (igual a), y <code>!=</code> (no igual a)."
              }
            ]
          },
          {
            "id": "ch01-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Solo hay un valor en JavaScript que no es igual a sí mismo, y ese es <code>NaN</code> (“no es un número”)."
              },
              {
                "type": "paragraph",
                "content": "<code>NaN</code> se supone que denota el resultado de un cálculo sin sentido y, como tal, no es igual al resultado de ningún otro cálculo sin sentido."
              },
              {
                "type": "paragraph",
                "content": "También hay algunas operaciones que se pueden aplicar a los propios valores Booleanos. JavaScript soporta tres operadores lógicos: <em>and</em> (y), <em>or</em> (o), y <em>not</em> (no). Estos se pueden usar para “razonar” sobre valores Booleanos."
              }
            ]
          },
          {
            "id": "ch01-l5-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El operador <code>&amp;&amp;</code> representa el <em>and</em> lógico. Es un operador binario, y su resultado es verdadero solo si ambos valores dados son verdaderos."
              },
              {
                "type": "paragraph",
                "content": "El operador <code>||</code> representa el <em>or</em> lógico. Produce verdadero si cualquiera de los valores dados es verdadero."
              },
              {
                "type": "paragraph",
                "content": "<em>Not</em> se escribe con un signo de exclamación (<code>!</code>). Es un operador unario que invierte el valor dado; <code>!true</code> produce <code>false</code> y <code>!false</code> produce <code>true</code>."
              }
            ]
          },
          {
            "id": "ch01-l5-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al combinar estos operadores Booleanos con operadores aritméticos y otros operadores, no siempre es obvio cuándo se necesitan paréntesis. En la práctica, generalmente puedes avanzar sabiendo que de los operadores que hemos visto hasta ahora, <code>||</code> tiene la menor precedencia, luego viene <code>&amp;&amp;</code>, luego los operadores de comparación (<code>&gt;</code>, <code>==</code>, etc.), y luego el resto. Este orden ha sido elegido de tal manera que, en expresiones típicas como la siguiente, se necesiten la menor cantidad de paréntesis posible:"
              },
              {
                "type": "paragraph",
                "content": "El último operador lógico que veremos no es unario ni binario, sino <em>ternario</em>, operando en tres valores. Se escribe con un signo de interrogación y dos puntos, así:"
              },
              {
                "type": "paragraph",
                "content": "Este se llama el operador <em>condicional</em> (o a veces simplemente <em>el operador ternario</em> ya que es el único operador de este tipo en el lenguaje). El operador usa el valor a la izquierda del signo de interrogación para decidir cuál de los otros dos valores “elegir”. Si escribes <code>a ? b : c</code>, el resultado será <code>b</code> cuando <code>a</code> es verdadero y <code>c</code> de lo contrario."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch01-l6",
        "title": "Valores vacíos",
        "sections": [
          {
            "id": "ch01-l6-s0",
            "title": "Valores vacíos",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay dos valores especiales, escritos <code>null</code> y <code>undefined</code>, que se utilizan para denotar la ausencia de un valor <em>significativo</em>. Son valores en sí mismos, pero no llevan ninguna información. Muchas operaciones en el lenguaje que no producen un valor significativo devuelven <code>undefined</code> simplemente porque tienen que devolver <em>algún</em> valor."
              },
              {
                "type": "paragraph",
                "content": "La diferencia en el significado entre <code>undefined</code> y <code>null</code> es un accidente del diseño de JavaScript, y la mayoría de las veces no importa. En casos en los que realmente tienes que preocuparte por estos valores, recomiendo tratarlos como en su mayoría intercambiables."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch01-l7",
        "title": "Conversión automática de tipos",
        "sections": [
          {
            "id": "ch01-l7-s0",
            "title": "Conversión automática de tipos",
            "content": [
              {
                "type": "paragraph",
                "content": "En la Introducción, mencioné que JavaScript se esfuerza por aceptar casi cualquier programa que le des, incluso programas que hacen cosas extrañas. Esto se demuestra claramente con las siguientes expresiones:"
              },
              {
                "type": "paragraph",
                "content": "Cuando se aplica un operador al tipo de valor “incorrecto”, JavaScript convertirá silenciosamente ese valor al tipo que necesita, utilizando un conjunto de reglas que a menudo no son las que deseas o esperas. Esto se llama <em>coerción de tipos</em>. El <code>null</code> en la primera expresión se convierte en <code>0</code> y el <code>\"5\"</code> en la segunda expresión se convierte en <code>5</code> (de cadena a número). Sin embargo, en la tercera expresión, <code>+</code> intenta la concatenación de cadenas antes que la suma numérica, por lo que el <code>1</code> se convierte en <code>\"1\"</code> (de número a cadena)."
              },
              {
                "type": "paragraph",
                "content": "Cuando algo que no se corresponde con un número de manera obvia (como <code>\"five\"</code> o <code>undefined</code>) se convierte en un número, obtienes el valor <code>NaN</code>. Más operaciones aritméticas en <code>NaN</code> siguen produciendo <code>NaN</code>, así que si te encuentras con uno de estos en un lugar inesperado, busca conversiones de tipo accidentales."
              }
            ]
          },
          {
            "id": "ch01-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se comparan valores del mismo tipo usando el operador <code>==</code>, el resultado es fácil de predecir: deberías obtener verdadero cuando ambos valores son iguales, excepto en el caso de <code>NaN</code>. Pero cuando los tipos difieren, JavaScript utiliza un conjunto de reglas complicado y confuso para determinar qué hacer. En la mayoría de los casos, simplemente intenta convertir uno de los valores al tipo del otro valor. Sin embargo, cuando <code>null</code> o <code>undefined</code> aparece en cualquiera de los lados del operador, produce verdadero solo si ambos lados son uno de <code>null</code> o <code>undefined</code>."
              },
              {
                "type": "paragraph",
                "content": "Ese comportamiento a menudo es útil. Cuando quieres probar si un valor tiene un valor real en lugar de <code>null</code> o <code>undefined</code>, puedes compararlo con <code>null</code> usando el operador <code>==</code> o <code>!=</code>."
              },
              {
                "type": "paragraph",
                "content": "¿Qué sucede si quieres probar si algo se refiere al valor preciso <code>false</code>? Expresiones como <code>0 == false</code> y <code>\"\" == false</code> también son verdaderas debido a la conversión automática de tipos. Cuando <em>no</em> deseas que ocurran conversiones de tipo, hay dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si no es precisamente igual. Por lo tanto, <code>\"\" === false</code> es falso como se espera. Recomiendo usar los operadores de comparación de tres caracteres defensivamente para evitar conversiones de tipo inesperadas que puedan complicarte las cosas. Pero cuando estés seguro de que los tipos en ambos lados serán los mismos, no hay problema en usar los operadores más cortos."
              }
            ]
          },
          {
            "id": "ch01-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los operadores lógicos <code>&amp;&amp;</code> y <code>||</code> manejan valores de diferentes tipos de una manera peculiar. Convertirán el valor del lado izquierdo a tipo Booleano para decidir qué hacer, pero dependiendo del operador y el resultado de esa conversión, devolverán ya sea el valor original del lado izquierdo o el valor del lado derecho."
              },
              {
                "type": "paragraph",
                "content": "El operador <code>||</code>, por ejemplo, devolverá el valor de su izquierda cuando ese valor pueda convertirse en true y devolverá el valor de su derecha de lo contrario. Esto tiene el efecto esperado cuando los valores son Booleanos y hace algo análogo para valores de otros tipos."
              },
              {
                "type": "paragraph",
                "content": "Podemos utilizar esta funcionalidad como una forma de utilizar un valor predeterminado. Si tienes un valor que podría estar vacío, puedes colocar <code>||</code> después de él con un valor de reemplazo. Si el valor inicial se puede convertir en false, obtendrás el valor de reemplazo en su lugar. Las reglas para convertir cadenas y números en valores Booleanos establecen que <code>0</code>, <code>NaN</code> y la cadena vacía (<code>\"\"</code>) cuentan como <code>false</code>, mientras que todos los demás valores cuentan como <code>true</code>. Esto significa que <code>0 || -1</code> produce <code>-1</code>, y <code>\"\" || \"!?\"</code> da como resultado <code>\"!?\"</code>."
              }
            ]
          },
          {
            "id": "ch01-l7-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El operador <code>??</code> se asemeja a <code>||</code>, pero devuelve el valor de la derecha solo si el de la izquierda es null o undefined, no si es algún otro valor que se pueda convertir en <code>false</code>. A menudo, este comportamiento es preferible al de <code>||</code>."
              },
              {
                "type": "paragraph",
                "content": "El operador <code>&amp;&amp;</code> funciona de manera similar pero en sentido contrario. Cuando el valor a su izquierda es algo que se convierte en false, devuelve ese valor, y de lo contrario devuelve el valor de su derecha."
              },
              {
                "type": "paragraph",
                "content": "Otra propiedad importante de estos dos operadores es que la parte de su derecha se evalúa solo cuando es necesario. En el caso de <code>true || X</code>, no importa qué sea <code>X</code>, incluso si es una parte del programa que hace algo <em>terrible</em>, el resultado será true, y <code>X</code> nunca se evaluará. Lo mismo ocurre con <code>false &amp;&amp; X</code>, que es false e ignorará <code>X</code>. Esto se llama <em>evaluación de cortocircuito</em>."
              }
            ]
          },
          {
            "id": "ch01-l7-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El operador condicional funciona de manera similar. De los valores segundo y tercero, solo se evalúa el que sea seleccionado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch01-l8",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch01-l8-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "En este capítulo examinamos cuatro tipos de valores en JavaScript: números, cadenas, Booleanos y valores indefinidos. Tales valores son creados escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>, <code>\"abc\"</code>). Puedes combinar y transformar valores con operadores. Vimos operadores binarios para aritmética (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> y <code>%</code>), concatenación de cadenas (<code>+</code>), comparación (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) y lógica (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>), así como varios operadores unarios (<code>-</code> para negar un número, <code>!</code> para negar lógicamente, y <code>typeof</code> para encontrar el tipo de un valor) y un operador ternario (<code>?:</code>) para elegir uno de dos valores basado en un tercer valor."
              },
              {
                "type": "paragraph",
                "content": "Esto te proporciona suficiente información para usar JavaScript como una calculadora de bolsillo, pero no mucho más. El próximo capítulo comenzará a unir estas expresiones en programas básicos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      }
    ]
  },
  {
    "id": "ch02",
    "number": 2,
    "title": "Estructura del Programa",
    "titleEs": "Estructura del Programa",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Y mi corazón brilla intensamente bajo mi piel diáfana y translúcida, y tienen que administrarme 10cc de JavaScript para hacerme volver. (Respondo bien...",
    "isProject": false,
    "totalXP": 610,
    "lessons": [
      {
        "id": "ch02-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch02-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Y mi corazón brilla intensamente bajo mi piel diáfana y translúcida, y tienen que administrarme 10cc de JavaScript para hacerme volver. (Respondo bien a las toxinas en la sangre.) ¡Hombre, esa cosa sacará los melocotones de tus agallas! _why, Guía (conmovedora) de Ruby de Why"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructura del Programa __ Eloquent JavaScript_files/chapter_picture_2.jpg",
                "alt": "Ilustración que muestra varios tentáculos sujetando piezas de ajedrez"
              },
              {
                "type": "paragraph",
                "content": "En este capítulo, comenzaremos a hacer cosas que realmente pueden ser llamadas <em>programación</em>. Ampliaremos nuestro dominio del lenguaje JavaScript más allá de los sustantivos y fragmentos de oraciones que hemos visto hasta ahora, hasta el punto en que podamos expresar prosa significativa."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l1",
        "title": "Expresiones y declaraciones",
        "sections": [
          {
            "id": "ch02-l1-s0",
            "title": "Expresiones y declaraciones",
            "content": [
              {
                "type": "paragraph",
                "content": "En el Capítulo 1 creamos valores y le aplicamos operadores para obtener nuevos valores. Crear valores de esta manera es la sustancia principal de cualquier programa JavaScript. Pero esa sustancia debe enmarcarse en una estructura más grande para ser útil. Eso es lo que cubriremos en este capítulo."
              },
              {
                "type": "paragraph",
                "content": "Un fragmento de código que produce un valor se llama una <em>expresión</em>. Cada valor que está escrito literalmente (como <code>22</code> o <code>\"psicoanálisis\"</code>) es una expresión. Una expresión entre paréntesis también es una expresión, al igual que un operador binario aplicado a dos expresiones o un operador unario aplicado a uno."
              },
              {
                "type": "paragraph",
                "content": "Esto muestra parte de la belleza de una interfaz basada en un lenguaje. Las expresiones pueden contener otras expresiones de manera similar a cómo las oraciones están anidadas en el lenguaje humano: una oración puede contener sus propias oraciones y así sucesivamente. Esto nos permite construir expresiones que describen cálculos arbitrariamente complejos."
              }
            ]
          },
          {
            "id": "ch02-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si una expresión corresponde a un fragmento de oración, una <em>declaración</em> de JavaScript corresponde a una oración completa. Un programa es una lista de declaraciones."
              },
              {
                "type": "paragraph",
                "content": "El tipo más simple de declaración es una expresión con un punto y coma al final. Este es un programa:"
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, es un programa inútil. Una expresión puede conformarse con simplemente producir un valor, que luego puede ser utilizado por el código que la contiene. Sin embargo, una declaración se mantiene por sí misma, por lo que si no afecta al mundo, es inútil. Puede mostrar algo en la pantalla, como con <code>console.log</code>, o cambiar el estado de la máquina de una manera que afectará a las declaraciones que vienen después de ella. Estos cambios se llaman <em>efectos secundarios</em>. Las declaraciones en el ejemplo anterior simplemente producen los valores <code>1</code> y <code>verdadero</code>, y luego los desechan inmediatamente. Esto no deja ninguna impresión en el mundo en absoluto. Cuando ejecutas este programa no sucede nada observable."
              }
            ]
          },
          {
            "id": "ch02-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En algunos casos, JavaScript te permite omitir el punto y coma al final de una declaración. En otros casos, debe estar ahí, o la próxima línea se tratará como parte de la misma declaración. Las reglas sobre cuándo se puede omitir de manera segura son algo complejas y propensas a errores. Por lo tanto, en este libro, cada declaración que necesite un punto y coma siempre recibirá uno. Te recomiendo que hagas lo mismo, al menos hasta que hayas aprendido más sobre las sutilezas de la omisión del punto y coma."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch02-l2",
        "title": "Enlaces",
        "sections": [
          {
            "id": "ch02-l2-s0",
            "title": "Enlaces",
            "content": [
              {
                "type": "paragraph",
                "content": "¿Cómo mantiene un programa un estado interno? ¿Cómo recuerda las cosas? Hemos visto cómo producir nuevos valores a partir de valores antiguos, pero esto no cambia los valores antiguos, y el nuevo valor debe utilizarse inmediatamente o se disipará nuevamente. Para atrapar y retener valores, JavaScript proporciona una cosa llamada un <em>enlace</em>, o <em>variable</em>:"
              },
              {
                "type": "paragraph",
                "content": "Eso nos da un segundo tipo de declaración. La palabra clave (<em>keyword</em>) <code>let</code> indica que esta frase va a definir un enlace. Está seguida por el nombre del enlace y, si queremos darle inmediatamente un valor, por un operador <code>=</code> y una expresión."
              },
              {
                "type": "paragraph",
                "content": "El ejemplo crea un enlace llamado <code>caught</code> y lo utiliza para capturar el número que se produce al multiplicar 5 por 5."
              }
            ]
          },
          {
            "id": "ch02-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Después de que se haya definido un enlace, su nombre se puede usar como una expresión. El valor de esa expresión es el valor que el enlace mantiene actualmente. Aquí tienes un ejemplo:"
              },
              {
                "type": "paragraph",
                "content": "Cuando un enlace apunta a un valor, eso no significa que esté atado a ese valor para siempre. El operador <code>=</code> se puede usar en cualquier momento en enlaces existentes para desconectarlos de su valor actual y hacer que apunten a uno nuevo:"
              },
              {
                "type": "paragraph",
                "content": "Debes imaginarte los enlaces como tentáculos en lugar de cajas. No <em>contienen</em> valores; los <em>agarran</em>—dos enlaces pueden hacer referencia al mismo valor. Un programa solo puede acceder a los valores a los que todavía tiene una referencia. Cuando necesitas recordar algo, o bien haces crecer un nuevo tentáculo para agarrarlo o lo reconectas con uno de tus tentáculos existentes."
              }
            ]
          },
          {
            "id": "ch02-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Veamos otro ejemplo. Para recordar la cantidad de dólares que Luigi todavía te debe, creas un enlace. Cuando te paga $35, le das a este enlace un nuevo valor:"
              },
              {
                "type": "paragraph",
                "content": "Cuando defines un enlace sin darle un valor, el tentáculo no tiene nada que agarrar, por lo que termina en el aire. Si solicitas el valor de un enlace vacío, obtendrás el valor <code>undefined</code>."
              },
              {
                "type": "paragraph",
                "content": "Una sola instrucción <code>let</code> puede definir múltiples enlaces. Las definiciones deben estar separadas por comas:"
              }
            ]
          },
          {
            "id": "ch02-l2-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las palabras <code>var</code> y <code>const</code> también se pueden usar para crear enlaces, de manera similar a <code>let</code>:"
              },
              {
                "type": "paragraph",
                "content": "La primera de estas, <code>var</code> (abreviatura de “variable”), es la forma en que se declaraban los enlaces en JavaScript anterior a 2015, cuando aún no existía <code>let</code>. Volveré a la forma precisa en que difiere de <code>let</code> en el próximo capítulo. Por ahora, recuerda que en su mayoría hace lo mismo, pero rara vez lo usaremos en este libro porque se comporta de manera extraña en algunas situaciones."
              },
              {
                "type": "paragraph",
                "content": "La palabra <code>const</code> significa <em>constante</em>. Define un enlace constante, que apunta al mismo valor mientras exista. Esto es útil para enlaces que solo dan un nombre a un valor para poder referirse fácilmente a él más tarde."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch02-l3",
        "title": "Nombres de enlaces",
        "sections": [
          {
            "id": "ch02-l3-s0",
            "title": "Nombres de enlaces",
            "content": [
              {
                "type": "paragraph",
                "content": "Los nombres de enlaces pueden ser cualquier secuencia de una o más letras. Los dígitos pueden formar parte de los nombres de enlaces, <code>catch22</code> es un nombre válido, por ejemplo, pero el nombre no puede empezar con un dígito. Un nombre de enlace puede incluir signos de dólar (<code>$</code>) o subrayados (<code>_</code>), pero no otros signos de puntuación o caracteres especiales."
              },
              {
                "type": "paragraph",
                "content": "Palabras con un significado especial, como <code>let</code>, son <em>palabra clave</em>, y no pueden ser usadas como nombres de enlaces. También hay una serie de palabras que están “reservadas para su uso” en futuras versiones de JavaScript, las cuales tampoco se pueden usar como nombres de enlaces. La lista completa de palabras clave y palabras reservadas es bastante larga:"
              },
              {
                "type": "paragraph",
                "content": "No te preocupes por memorizar esta lista. Cuando al crear un enlace se produce un error de sintaxis inesperado, verifica si estás intentando definir una palabra reservada."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l4",
        "title": "El entorno",
        "sections": [
          {
            "id": "ch02-l4-s0",
            "title": "El entorno",
            "content": [
              {
                "type": "paragraph",
                "content": "La colección de enlaces y sus valores que existen en un momento dado se llama <em>entorno</em>. Cuando un programa se inicia, este entorno no está vacío. Siempre contiene enlaces que forman parte del lenguaje estándar, y la mayoría de las veces también tiene enlaces que proporcionan formas de interactuar con el sistema circundante. Por ejemplo, en un navegador, existen funciones para interactuar con el sitio web cargado actualmente y para leer la entrada del ratón y el teclado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l5",
        "title": "Funciones",
        "sections": [
          {
            "id": "ch02-l5-s0",
            "title": "Funciones",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos de los valores proporcionados en el entorno predeterminado tienen el tipo de <em>función</em>. Una función es un fragmento de programa envuelto en un valor. Estos valores pueden ser <em>aplicados</em> para ejecutar el programa envuelto. Por ejemplo, en un entorno de navegador, el enlace <code>prompt</code> contiene una función que muestra un pequeño cuadro de diálogo pidiendo la entrada del usuario. Se utiliza de la siguiente manera:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructura del Programa __ Eloquent JavaScript_files/prompt.png",
                "alt": "Un cuadro de diálogo que dice &#39;Enter passcode&#39;"
              },
              {
                "type": "paragraph",
                "content": "Ejecutar una función se llama <em>invocar</em>, <em>llamar</em>, o <em>aplicar</em> la función. Puedes llamar una función poniendo paréntesis después de una expresión que produce un valor de función. Usualmente usarás directamente el nombre del enlace que contiene la función. Los valores entre paréntesis se le pasan al programa dentro de la función. En el ejemplo, la función <code>prompt</code> utiliza la cadena que le pasamos como el texto a mostrar en el cuadro de diálogo. Los valores dados a las funciones se llaman <em>argumentos</em>. Diferentes funciones pueden necesitar un número diferente o diferentes tipos de argumentos."
              }
            ]
          },
          {
            "id": "ch02-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>prompt</code> no se usa mucho en la programación web moderna, principalmente porque no tienes control sobre cómo se ve el cuadro de diálogo resultante, pero puede ser útil en programas simples y experimentos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch02-l6",
        "title": "La función console.log",
        "sections": [
          {
            "id": "ch02-l6-s0",
            "title": "La función console.log",
            "content": [
              {
                "type": "paragraph",
                "content": "En los ejemplos, utilicé <code>console.log</code> para mostrar valores. La mayoría de los sistemas de JavaScript (incluidos todos los navegadores web modernos y Node.js) proveen una función <code>console.log</code> que escribe sus argumentos en <em>algún</em> dispositivo de salida de texto. En los navegadores, la salida va a la consola de JavaScript. Esta parte de la interfaz del navegador está oculta por defecto, pero la mayoría de los navegadores la abren cuando presionas F12 o, en Mac, <span class=\"keyname\">comando</span>-<span class=\"keyname\">opción</span>-I. Si eso no funciona, busca a través de los menús un elemento llamado Herramientas para Desarrolladores o similar."
              },
              {
                "type": "paragraph",
                "content": "Cuando ejecutas los ejemplos (o tu propio código) en las páginas de este libro, la salida de <code>console.log</code> se mostrará después del ejemplo, en lugar de en la consola de JavaScript del navegador."
              },
              {
                "type": "paragraph",
                "content": "Aunque los nombres de enlaces no pueden contener puntos, <code>console.log</code> tiene uno. Esto se debe a que <code>console.log</code> no es un simple enlace, sino una expresión que recupera la propiedad <code>log</code> del valor contenido por el enlace <code>console</code>. Descubriremos exactamente lo que esto significa en el Capítulo 4."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l7",
        "title": "Valores de retorno",
        "sections": [
          {
            "id": "ch02-l7-s0",
            "title": "Valores de retorno",
            "content": [
              {
                "type": "paragraph",
                "content": "Mostrar un cuadro de diálogo o escribir texto en la pantalla es un efecto secundario. Muchas funciones son útiles debido a los efectos secundarios que producen. Las funciones también pueden producir valores, en cuyo caso no necesitan tener un efecto secundario para ser útiles. Por ejemplo, la función <code>Math.max</code> toma cualquier cantidad de argumentos numéricos y devuelve el mayor:"
              },
              {
                "type": "paragraph",
                "content": "Cuando una función produce un valor, se dice que <em>retorna</em> ese valor. Cualquier cosa que produzca un valor es una expresión en JavaScript, lo que significa que las llamadas a funciones se pueden utilizar dentro de expresiones más grandes. En el siguiente código, una llamada a <code>Math.min</code>, que es lo opuesto a <code>Math.max</code>, se usa como parte de una expresión de suma:"
              },
              {
                "type": "paragraph",
                "content": "El Capítulo 3 explicará cómo escribir tus propias funciones."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l8",
        "title": "Control de flujo",
        "sections": [
          {
            "id": "ch02-l8-s0",
            "title": "Control de flujo",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando tu programa contiene más de una sentencia, las sentencias se ejecutan como si fueran una historia, de arriba hacia abajo. Por ejemplo, el siguiente programa tiene dos sentencias. La primera le pide al usuario un número, y la segunda, que se ejecuta después de la primera, muestra el cuadrado de ese número:"
              },
              {
                "type": "paragraph",
                "content": "La función <code>Number</code> convierte un valor a un número. Necesitamos esa conversión porque el resultado de <code>prompt</code> es un valor de tipo string, y queremos un número. Hay funciones similares llamadas <code>String</code> y <code>Boolean</code> que convierten valores a esos tipos."
              },
              {
                "type": "paragraph",
                "content": "Aquí está la representación esquemática bastante trivial del flujo de control en línea recta:"
              }
            ]
          },
          {
            "id": "ch02-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/Estructura del Programa __ Eloquent JavaScript_files/controlflow-straight.svg",
                "alt": "Diagrama mostrando una flecha recta"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch02-l9",
        "title": "Ejecución condicional",
        "sections": [
          {
            "id": "ch02-l9-s0",
            "title": "Ejecución condicional",
            "content": [
              {
                "type": "paragraph",
                "content": "No todos los programas son caminos rectos. Podríamos, por ejemplo, querer crear una carretera ramificada donde el programa tome la rama adecuada basada en la situación en cuestión. Esto se llama <em>ejecución condicional</em>."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructura del Programa __ Eloquent JavaScript_files/controlflow-if.svg",
                "alt": "Diagrama de una flecha que se divide en dos y luego se une de nuevo"
              },
              {
                "type": "paragraph",
                "content": "La ejecución condicional se crea con la palabra clave <code>if</code> en JavaScript. En el caso simple, queremos que cierto código se ejecute si, y solo si, una cierta condición es verdadera. Por ejemplo, podríamos querer mostrar el cuadrado de la entrada solo si la entrada es realmente un número:"
              }
            ]
          },
          {
            "id": "ch02-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Con esta modificación, si introduces “loro”, no se mostrará ninguna salida."
              },
              {
                "type": "paragraph",
                "content": "La palabra clave <code>if</code> ejecuta o salta una sentencia dependiendo del valor de una expresión booleana. La expresión de decisión se escribe después de la palabra clave, entre paréntesis, seguida de la sentencia a ejecutar."
              },
              {
                "type": "paragraph",
                "content": "La función <code>Number.isNaN</code> es una función estándar de JavaScript que devuelve <code>true</code> solo si el argumento que se le pasa es <code>NaN</code>. La función <code>Number</code> devuelve <code>NaN</code> cuando le das una cadena que no representa un número válido. Por lo tanto, la condición se traduce a “a menos que <code>elNumero</code> no sea un número, haz esto”."
              }
            ]
          },
          {
            "id": "ch02-l9-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La sentencia después del <code>if</code> está envuelta entre llaves (<code>{</code> y <code>}</code>) en este ejemplo. Las llaves se pueden usar para agrupar cualquier cantidad de sentencias en una sola sentencia, llamada un <em>bloque</em>. También podrías haber omitido en este caso, ya que contienen solo una sentencia, pero para evitar tener que pensar si son necesarias, la mayoría de los programadores de JavaScript las usan en cada sentencia envuelta de esta manera. Seguiremos principalmente esa convención en este libro, excepto por los casos ocasionales de una sola línea."
              },
              {
                "type": "paragraph",
                "content": "A menudo no solo tendrás código que se ejecuta cuando una condición es verdadera, sino también código que maneja el otro caso. Esta ruta alternativa está representada por la segunda flecha en el diagrama. Puedes usar la palabra clave <code>else</code>, junto con <code>if</code>, para crear dos caminos de ejecución alternativos y separados:"
              },
              {
                "type": "paragraph",
                "content": "Si tienes más de dos caminos para elegir, puedes “encadenar” múltiples pares <code>if</code>/<code>else</code>. Aquí tienes un ejemplo:"
              }
            ]
          },
          {
            "id": "ch02-l9-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El programa primero comprueba si <code>num</code> es menor que 10. Si lo es, elige esa rama, muestra <code>\"Pequeño\"</code>, y termina. Si no lo es, toma la rama <code>else</code>, la cual contiene a su vez otro <code>if</code>. Si la segunda condición (<code>&lt; 100</code>) se cumple, eso significa que el número es al menos 10 pero menor que 100, y se muestra <code>\"Mediano\"</code>. Si no, se elige la segunda y última rama <code>else</code>."
              },
              {
                "type": "paragraph",
                "content": "El esquema de este programa se ve más o menos así:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructura del Programa __ Eloquent JavaScript_files/controlflow-nested-if.svg",
                "alt": "Diagrama que muestra una flecha que se divide en dos, con una de las ramas dividiéndose nuevamente antes de que todas las ramas se unan de nuevo"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch02-l10",
        "title": "Bucles while y do",
        "sections": [
          {
            "id": "ch02-l10-s0",
            "title": "Bucles while y do",
            "content": [
              {
                "type": "paragraph",
                "content": "Considera un programa que imprime todos los números pares de 0 a 12. Una forma de escribirlo es la siguiente:"
              },
              {
                "type": "paragraph",
                "content": "Eso funciona, pero la idea de escribir un programa es hacer <em>menos</em> trabajo, no más. Si necesitáramos todos los números pares menores que 1,000, este enfoque sería inviable. Lo que necesitamos es una manera de ejecutar un fragmento de código múltiples veces. Esta forma de control de flujo se llama <em>bucle</em>."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructura del Programa __ Eloquent JavaScript_files/controlflow-loop.svg",
                "alt": "Diagrama que muestra una flecha que apunta a un punto que tiene una flecha cíclica que regresa a sí mismo y otra flecha que continúa"
              },
              {
                "type": "paragraph",
                "content": "El control de flujo mediante bucles nos permite regresar a algún punto en el programa donde estábamos antes y repetirlo con nuestro estado de programa actual. Si combinamos esto con una variable que cuente, podemos hacer algo como esto:"
              }
            ]
          },
          {
            "id": "ch02-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una sentencia que comienza con la palabra clave <code>while</code> crea un bucle. La palabra <code>while</code> va seguida de una expresión entre paréntesis y luego un enunciado, similar a <code>if</code>. El bucle sigue ejecutando ese enunciado mientras la expresión produzca un valor que se convierta en <code>true</code> al convertirse a Booleano."
              },
              {
                "type": "paragraph",
                "content": "El enlace ‘numero’ demuestra la forma en que un enlace puede seguir el progreso de un programa. Cada vez que se repite el bucle, ‘numero’ obtiene un valor que es 2 más que su valor anterior. Al comienzo de cada repetición, se compara con el número 12 para decidir si el trabajo del programa ha terminado."
              },
              {
                "type": "paragraph",
                "content": "Como ejemplo de algo realmente útil, ahora podemos escribir un programa que calcule y muestre el valor de 2<sup>10</sup> (2 elevado a la 10ª potencia). Usamos dos enlaces: uno para llevar un seguimiento de nuestro resultado y otro para contar cuántas veces hemos multiplicado este resultado por 2. El bucle comprueba si el segundo enlace ya ha alcanzado 10 y, si no, actualiza ambos enlaces."
              }
            ]
          },
          {
            "id": "ch02-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El contador también podría haber comenzado en <code>1</code> y haber comprobado si era <code>&lt;= 10</code>, pero por razones que se harán evidentes en el Capítulo 4, es buena idea acostumbrarse a contar desde 0."
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que JavaScript también tiene un operador para la potencia (<code>2 ** 10</code>), que usarías para calcular esto en un código real, pero eso habría arruinado el ejemplo."
              },
              {
                "type": "paragraph",
                "content": "Un bucle <code>do</code> es una estructura de control similar a un bucle <code>while</code>. La única diferencia radica en que un bucle <code>do</code> siempre ejecuta su cuerpo al menos una vez, y comienza a probar si debe detenerse solo después de esa primera ejecución. Para reflejar esto, la prueba aparece después del cuerpo del bucle:"
              }
            ]
          },
          {
            "id": "ch02-l10-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este programa te obligará a ingresar un nombre. Preguntará una y otra vez hasta que obtenga algo que no sea una cadena vacía. Aplicar el operador <code>!</code> convertirá un valor al tipo Booleano antes de negarlo, y todas las cadenas excepto <code>\"\"</code> se convierten en <code>true</code>. Esto significa que el bucle continúa hasta que proporciones un nombre no vacío."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch02-l11",
        "title": "Sangrado de Código",
        "sections": [
          {
            "id": "ch02-l11-s0",
            "title": "Sangrado de Código",
            "content": [
              {
                "type": "paragraph",
                "content": "En los ejemplos, he estado agregando espacios delante de las sentencias que son parte de alguna otra sentencia más grande. Estos espacios no son necesarios: la computadora aceptará el programa perfectamente sin ellos. De hecho, incluso los saltos de línea en los programas son opcionales. Podrías escribir un programa como una sola línea larga si así lo deseas."
              },
              {
                "type": "paragraph",
                "content": "El papel de este sangrado dentro de los bloques es hacer que la estructura del código resalte para los lectores humanos. En el código donde se abren nuevos bloques dentro de otros bloques, puede volverse difícil ver dónde termina un bloque y comienza otro. Con un sangrado adecuado, la forma visual de un programa corresponde a la forma de los bloques dentro de él. A mí me gusta usar dos espacios para cada bloque abierto, pero los gustos difieren: algunas personas usan cuatro espacios y otras usan caracteres de tabulación. Lo importante es que cada nuevo bloque agregue la misma cantidad de espacio."
              },
              {
                "type": "paragraph",
                "content": "La mayoría de los programas de edición (incluido el de este libro) ayudarán automáticamente con la sangría adecuada al escribir nuevas líneas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l12",
        "title": "bucles for",
        "sections": [
          {
            "id": "ch02-l12-s0",
            "title": "bucles for",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos bucles siguen el patrón mostrado en los ejemplos de <code>while</code>. Primero se crea una variable de “contador” para rastrear el progreso del bucle. Luego viene un bucle <code>while</code>, generalmente con una expresión de prueba que verifica si el contador ha alcanzado su valor final. Al final del cuerpo del bucle, el contador se actualiza para rastrear el progreso."
              },
              {
                "type": "paragraph",
                "content": "Debido a que este patrón es tan común, JavaScript y lenguajes similares proporcionan una forma ligeramente más corta y completa, el bucle <code>for</code>:"
              },
              {
                "type": "paragraph",
                "content": "Este programa es exactamente equivalente al anterior ejemplo de impresión de números pares. La única diferencia es que todas las declaraciones relacionadas con el “estado” del bucle están agrupadas después de <code>for</code>."
              }
            ]
          },
          {
            "id": "ch02-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los paréntesis después de la palabra clave <code>for</code> deben contener dos punto y coma. La parte antes del primer punto y coma <em>inicializa</em> el bucle, generalmente definiendo una variable. La segunda parte es la expresión que <em>verifica</em> si el bucle debe continuar. La parte final <em>actualiza</em> el estado del bucle después de cada iteración. En la mayoría de los casos, esto es más corto y claro que un <code>while</code> tradicional."
              },
              {
                "type": "paragraph",
                "content": "Este es el código que calcula 2<sup>10</sup> usando <code>for</code> en lugar de <code>while</code>:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch02-l13",
        "title": "Saliendo de un bucle",
        "sections": [
          {
            "id": "ch02-l13-s0",
            "title": "Saliendo de un bucle",
            "content": [
              {
                "type": "paragraph",
                "content": "Hacer que la condición del bucle produzca <code>false</code> no es la única forma en que un bucle puede terminar. La instrucción <code>break</code> tiene el efecto de salir inmediatamente del bucle que la contiene. Su uso se demuestra en el siguiente programa, que encuentra el primer número que es mayor o igual a 20 y divisible por 7:"
              },
              {
                "type": "paragraph",
                "content": "Usar el operador de resto (<code>%</code>) es una forma sencilla de comprobar si un número es divisible por otro. Si lo es, el resto de su división es cero."
              },
              {
                "type": "paragraph",
                "content": "La construcción <code>for</code> en el ejemplo no tiene una parte que verifique el final del bucle. Esto significa que el bucle nunca se detendrá a menos que se ejecute la instrucción <code>break</code> dentro de él."
              }
            ]
          },
          {
            "id": "ch02-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si eliminaras esa declaración <code>break</code> o escribieses accidentalmente una condición final que siempre produzca <code>true</code>, tu programa quedaría atrapado en un <em>bucle infinito</em>. Un programa atrapado en un bucle infinito nunca terminará de ejecutarse, lo cual suele ser algo malo."
              },
              {
                "type": "paragraph",
                "content": "Si creas un bucle infinito en uno de los ejemplos en estas páginas, generalmente se te preguntará si deseas detener el script después de unos segundos. Si eso falla, deberás cerrar la pestaña en la que estás trabajando para recuperarte."
              },
              {
                "type": "paragraph",
                "content": "La palabra clave <code>continue</code> es similar a <code>break</code> en que influye en el progreso de un bucle. Cuando se encuentra <code>continue</code> en el cuerpo de un bucle, el control salta fuera del cuerpo y continúa con la siguiente iteración del bucle."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch02-l14",
        "title": "Actualización concisa de enlaces",
        "sections": [
          {
            "id": "ch02-l14-s0",
            "title": "Actualización concisa de enlaces",
            "content": [
              {
                "type": "paragraph",
                "content": "Especialmente al hacer bucles, un programa a menudo necesita “actualizar” un enlace para que contenga un valor basado en el valor anterior de ese enlace."
              },
              {
                "type": "paragraph",
                "content": "JavaScript proporciona un atajo para esto:"
              },
              {
                "type": "paragraph",
                "content": "Atajos similares funcionan para muchos otros operadores, como <code>result *= 2</code> para duplicar <code>result</code> o <code>counter -= 1</code> para contar hacia atrás."
              }
            ]
          },
          {
            "id": "ch02-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto nos permite acortar aún más nuestro ejemplo de contar:"
              },
              {
                "type": "paragraph",
                "content": "Para <code>counter += 1</code> y <code>counter -= 1</code>, existen equivalentes aún más cortos: <code>counter++</code> y <code>counter--</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch02-l15",
        "title": "Despachar un valor con switch",
        "sections": [
          {
            "id": "ch02-l15-s0",
            "title": "Despachar un valor con switch",
            "content": [
              {
                "type": "paragraph",
                "content": "No es raro que el código luzca así:"
              },
              {
                "type": "paragraph",
                "content": "Existe una construcción llamada <code>switch</code> que está destinada a expresar dicho “despacho” de una manera más directa. Desafortunadamente, la sintaxis que JavaScript utiliza para esto (heredada de la línea de lenguajes de programación C/Java) es algo incómoda; una cadena de declaraciones <code>if</code> puede verse mejor. Aquí hay un ejemplo:"
              },
              {
                "type": "paragraph",
                "content": "Puedes colocar cualquier cantidad de etiquetas <code>case</code> dentro del bloque abierto por <code>switch</code>. El programa comenzará a ejecutarse en la etiqueta que corresponda al valor que se le dio a <code>switch</code>, o en <code>default</code> si no se encuentra ningún valor coincidente. Continuará ejecutándose, incluso a través de otras etiquetas, hasta que alcance una declaración <code>break</code>. En algunos casos, como el caso <code>\"soleado\"</code> en el ejemplo, esto se puede usar para compartir algo de código entre casos (recomienda salir al exterior tanto para el clima soleado como para el nublado). Sin embargo, ten cuidado, es fácil olvidar un <code>break</code> de este tipo, lo que hará que el programa ejecute código que no deseas ejecutar."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l16",
        "title": "Uso de mayúsculas",
        "sections": [
          {
            "id": "ch02-l16-s0",
            "title": "Uso de mayúsculas",
            "content": [
              {
                "type": "paragraph",
                "content": "Los nombres de los enlaces no pueden contener espacios, sin embargo, a menudo es útil usar varias palabras para describir claramente lo que representa el enlace. Estas son básicamente tus opciones para escribir un nombre de enlace con varias palabras:"
              },
              {
                "type": "paragraph",
                "content": "El primer estilo puede ser difícil de leer. Personalmente me gusta más la apariencia de los guiones bajos, aunque ese estilo es un poco difícil de escribir. Las funciones estándar de JavaScript y la mayoría de los programadores de JavaScript siguen el último estilo: escriben con mayúscula cada palabra excepto la primera. No es difícil acostumbrarse a pequeñas cosas como esa, y el código con estilos de nombrado mixtos puede resultar molesto de leer, así que seguimos esta convención."
              },
              {
                "type": "paragraph",
                "content": "En algunos casos, como en la función <code>Number</code>, la primera letra de un enlace también está en mayúscula. Esto se hizo para marcar esta función como un constructor. Quedará claro lo que es un constructor en el Capítulo 6. Por ahora, lo importante es no molestarse por esta aparente falta de consistencia."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l17",
        "title": "Comentarios",
        "sections": [
          {
            "id": "ch02-l17-s0",
            "title": "Comentarios",
            "content": [
              {
                "type": "paragraph",
                "content": "A menudo, el código sin formato no transmite toda la información que deseas que un programa transmita a los lectores humanos, o lo hace de una manera tan críptica que las personas podrían no entenderlo. En otros momentos, es posible que solo quieras incluir algunos pensamientos relacionados como parte de tu programa. Para eso sirven los <em>comentarios</em>."
              },
              {
                "type": "paragraph",
                "content": "Un comentario es un fragmento de texto que forma parte de un programa pero que es completamente ignorado por la computadora. JavaScript tiene dos formas de escribir comentarios. Para escribir un comentario de una sola línea, puedes usar dos caracteres de barra (<code>//</code>) y luego el texto del comentario después de eso:"
              },
              {
                "type": "paragraph",
                "content": "Un comentario con <code>//</code> solo va hasta el final de la línea. Una sección de texto entre <code>/*</code> y <code>*/</code> será ignorada por completo, independientemente de si contiene saltos de línea. Esto es útil para agregar bloques de información sobre un archivo o un fragmento de programa:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l18",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch02-l18-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora sabes que un programa está construido a partir de declaraciones, que a veces contienen más declaraciones. Las declaraciones tienden a contener expresiones, que a su vez pueden estar construidas a partir de expresiones más pequeñas. Poner declaraciones una después de la otra te da un programa que se ejecuta de arriba hacia abajo. Puedes introducir alteraciones en el flujo de control usando declaraciones condicionales (<code>if</code>, <code>else</code> y <code>switch</code>) y bucles (<code>while</code>, <code>do</code> y <code>for</code>)."
              },
              {
                "type": "paragraph",
                "content": "Los enlaces se pueden usar para guardar fragmentos de datos bajo un nombre, y son útiles para hacer un seguimiento del estado en tu programa. El entorno es el conjunto de enlaces que están definidos. Los sistemas de JavaScript siempre colocan varios enlaces estándar útiles en tu entorno."
              },
              {
                "type": "paragraph",
                "content": "Las funciones son valores especiales que encapsulan un fragmento de programa. Puedes invocarlas escribiendo <code>nombreDeFuncion(argumento1, argumento2)</code>. Dicha llamada a función es una expresión y puede producir un valor."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch02-l19",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch02-l19-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Si no estás seguro de cómo probar tus soluciones a los ejercicios, consulta la Introducción."
              },
              {
                "type": "paragraph",
                "content": "Cada ejercicio comienza con una descripción del problema. Lee esta descripción e intenta resolver el ejercicio. Si encuentras problemas, considera leer las pistas después del ejercicio. Puedes encontrar soluciones completas a los ejercicios en línea en <em>https://eloquentjavascript.net/code</em>. Si deseas aprender algo de los ejercicios, te recomiendo mirar las soluciones solo después de haber resuelto el ejercicio, o al menos después de haberlo intentado lo suficiente como para tener un ligero dolor de cabeza."
              },
              {
                "type": "paragraph",
                "content": "Escribe un bucle que realice siete llamadas a <code>console.log</code> para mostrar el siguiente triángulo:"
              }
            ]
          },
          {
            "id": "ch02-l19-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puede ser útil saber que puedes encontrar la longitud de una cadena escribiendo <code>.length</code> después de ella."
              },
              {
                "type": "paragraph",
                "content": "La mayoría de los ejercicios contienen un fragmento de código que puedes modificar para resolver el ejercicio. Recuerda que puedes hacer clic en los bloques de código para editarlos."
              },
              {
                "type": "paragraph",
                "content": "Puedes comenzar con un programa que imprime los números del 1 al 7, el cual puedes obtener haciendo algunas modificaciones al ejemplo de impresión de números pares dado anteriormente en el capítulo, donde se introdujo el bucle <code>for</code>."
              }
            ]
          },
          {
            "id": "ch02-l19-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora considera la equivalencia entre los números y las cadenas de caracteres \"#\" . Puedes pasar de 1 a 2 sumando 1 (<code>+= 1</code>). Puedes pasar de <code>\"#\"</code> a <code>\"##\"</code> agregando un carácter (<code>+= \"#\"</code>). Por lo tanto, tu solución puede seguir de cerca el programa de impresión de números."
              },
              {
                "type": "paragraph",
                "content": "Escribe un programa que use <code>console.log</code> para imprimir todos los números del 1 al 100, con dos excepciones. Para los números divisibles por 3, imprime <code>\"Fizz\"</code> en lugar del número, y para los números divisibles por 5 (y no por 3), imprime <code>\"Buzz\"</code> en su lugar."
              },
              {
                "type": "paragraph",
                "content": "Cuando tengas eso funcionando, modifica tu programa para imprimir <code>\"FizzBuzz\"</code> para los números que son divisibles por 3 y 5 (y sigue imprimiendo <code>\"Fizz\"</code> o <code>\"Buzz\"</code> para los números que son divisibles solo por uno de esos)."
              }
            ]
          },
          {
            "id": "ch02-l19-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "(Esto es en realidad una pregunta de entrevista que se ha afirmado que elimina a un porcentaje significativo de candidatos a programadores. Entonces, si lo resolviste, tu valor en el mercado laboral acaba de aumentar.)"
              },
              {
                "type": "paragraph",
                "content": "Claramente, recorrer los números es un trabajo de bucle, y seleccionar qué imprimir es una cuestión de ejecución condicional. Recuerda el truco de usar el operador de resto (<code>%</code>) para verificar si un número es divisible por otro número (tiene un resto de cero)."
              },
              {
                "type": "paragraph",
                "content": "En la primera versión, hay tres resultados posibles para cada número, por lo que tendrás que crear una cadena <code>if</code>/<code>else if</code>/<code>else</code>."
              }
            ]
          },
          {
            "id": "ch02-l19-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La segunda versión del programa tiene una solución sencilla y una inteligente. La solución simple es agregar otra “rama” condicional para probar exactamente la condición dada. Para la solución inteligente, construye una cadena que contenga la palabra o palabras a imprimir e imprime esta palabra o el número si no hay palabra, potencialmente haciendo un buen uso del operador <code>||</code>."
              },
              {
                "type": "paragraph",
                "content": "Escribe un programa que cree una cadena que represente un tablero de 8x8, usando caracteres de salto de línea para separar las líneas. En cada posición del tablero hay un carácter de espacio o un carácter \"#\". Los caracteres deben formar un tablero de ajedrez."
              },
              {
                "type": "paragraph",
                "content": "Al pasar esta cadena a <code>console.log</code> debería mostrar algo como esto:"
              }
            ]
          },
          {
            "id": "ch02-l19-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando tengas un programa que genere este patrón, define una variable <code>size = 8</code> y cambia el programa para que funcione para cualquier <code>size</code>, generando un tablero con el ancho y alto dados."
              },
              {
                "type": "paragraph",
                "content": "Para trabajar con dos dimensiones, necesitarás un bucle dentro de otro bucle. Pon llaves alrededor de los cuerpos de ambos bucles para que sea fácil ver dónde empiezan y terminan. Intenta indentar correctamente estos cuerpos. El orden de los bucles debe seguir el orden en el que construimos la cadena (línea por línea, de izquierda a derecha, de arriba abajo). Entonces el bucle exterior maneja las líneas y el bucle interior maneja los caracteres en una línea."
              },
              {
                "type": "paragraph",
                "content": "Necesitarás dos variables para hacer un seguimiento de tu progreso. Para saber si debes colocar un espacio o un signo de hash en una posición determinada, podrías verificar si la suma de los dos contadores es par (<code>% 2</code>)."
              }
            ]
          },
          {
            "id": "ch02-l19-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Terminar una línea agregando un carácter de salto de línea debe ocurrir después de que se haya construido la línea, así que hazlo después del bucle interno pero dentro del bucle externo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      }
    ]
  },
  {
    "id": "ch03",
    "number": 3,
    "title": "Funciones",
    "titleEs": "Funciones",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "La gente piensa que la informática es el arte de los genios, pero la realidad actual es la opuesta, simplemente muchas personas haciendo cosas que se ...",
    "isProject": false,
    "totalXP": 490,
    "lessons": [
      {
        "id": "ch03-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch03-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "La gente piensa que la informática es el arte de los genios, pero la realidad actual es la opuesta, simplemente muchas personas haciendo cosas que se construyen unas sobre otras, como un muro de mini piedras. Donald Knuth"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Funciones __ Eloquent JavaScript_files/chapter_picture_3.jpg",
                "alt": "Ilustración de hojas de helecho con una forma fractal, abejas en el fondo"
              },
              {
                "type": "paragraph",
                "content": "Las funciones son una de las herramientas más centrales en la programación en JavaScript. El concepto de envolver un fragmento de programa en un valor tiene muchos usos. Nos proporciona una manera de estructurar programas más grandes, de reducir la repetición, de asociar nombres con subprogramas y de aislar estos subprogramas entre sí."
              }
            ]
          },
          {
            "id": "ch03-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La aplicación más evidente de las funciones es definir nuevo vocabulario. Crear palabras nuevas en el lenguaje escrito suele ser de mal gusto, pero en programación es indispensable."
              },
              {
                "type": "paragraph",
                "content": "Los hablantes de inglés adultos típicos tienen alrededor de 20,000 palabras en su vocabulario. Pocos lenguajes de programación vienen con 20,000 comandos incorporados. Y el vocabulario que <em>está</em> disponible tiende a estar más precisamente definido, y por lo tanto menos flexible, que en el lenguaje humano. Por lo tanto, <em>tenemos</em> que introducir nuevas palabras para evitar la verbosidad excesiva."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l1",
        "title": "Definir una función",
        "sections": [
          {
            "id": "ch03-l1-s0",
            "title": "Definir una función",
            "content": [
              {
                "type": "paragraph",
                "content": "Una definición de función es un enlace habitual donde el valor del enlace es una función. Por ejemplo, este código define <code>square</code> para que se refiera a una función que produce el cuadrado de un número dado:"
              },
              {
                "type": "paragraph",
                "content": "Una función se crea con una expresión que comienza con la palabra clave <code>function</code>. Las funciones tienen un conjunto de <em>parámetros</em> (en este caso, solo <code>x</code>) y un <em>cuerpo</em>, que contiene las declaraciones que se ejecutarán cuando se llame a la función. El cuerpo de una función creada de esta manera siempre debe estar envuelto entre llaves, incluso cuando consiste en una única declaración."
              },
              {
                "type": "paragraph",
                "content": "Una función puede tener varios parámetros o ninguno en absoluto. En el siguiente ejemplo, <code>makeNoise</code> no enumera nombres de parámetros, mientras que <code>roundTo</code> (que redondea <code>n</code> al múltiplo más cercano de <code>step</code>) enumera dos:"
              }
            ]
          },
          {
            "id": "ch03-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunas funciones, como <code>roundTo</code> y <code>square</code>, producen un valor, y otras no, como <code>makeNoise</code>, cuyo único resultado es un efecto secundario. Una instrucción <code>return</code> determina el valor que devuelve la función. Cuando el control llega a una instrucción de ese tipo, salta inmediatamente fuera de la función actual y le da el valor devuelto al código que llamó a la función. Una palabra clave <code>return</code> sin una expresión después de ella hará que la función devuelva <code>undefined</code>. Las funciones que no tienen ninguna instrucción <code>return</code> en absoluto, como <code>makeNoise</code>, devuelven igualmente <code>undefined</code>."
              },
              {
                "type": "paragraph",
                "content": "Los parámetros de una función se comportan como enlaces habituales, pero sus valores iniciales son dados por el <em>llamador</em> de la función, no por el código en la función en sí misma."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l2",
        "title": "Enlaces y ámbitos",
        "sections": [
          {
            "id": "ch03-l2-s0",
            "title": "Enlaces y ámbitos",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada enlace tiene un <em>ámbito</em>, que es la parte del programa en la que el enlace es visible. Para los enlaces definidos fuera de cualquier función, bloque o módulo (ver Capítulo 10), el ámbito es todo el programa—puedes hacer referencia a esos enlaces donde quieras. Estos se llaman <em>globales</em>."
              },
              {
                "type": "paragraph",
                "content": "Los enlaces creados para los parámetros de una función o declarados dentro de una función solo pueden ser referenciados en esa función, por lo que se conocen como enlaces <em>locales</em>. Cada vez que se llama a la función, se crean nuevas instancias de estos enlaces. Esto proporciona cierto aislamiento entre funciones—cada llamada a función actúa en su propio pequeño mundo (su entorno local) y a menudo se puede entender sin saber mucho sobre lo que está sucediendo en el entorno global."
              },
              {
                "type": "paragraph",
                "content": "Los enlaces declarados con <code>let</code> y <code>const</code> en realidad son locales al <em>bloque</em> en el que se declaran, por lo que si creas uno de ellos dentro de un bucle, el código antes y después del bucle no puede “verlo”. En JavaScript anterior a 2015, solo las funciones creaban nuevos ámbitos, por lo que los enlaces de estilo antiguo, creados con la palabra clave <code>var</code>, son visibles en toda función en la que aparecen—o en todo el ámbito global, si no están dentro de una función."
              }
            ]
          },
          {
            "id": "ch03-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada ámbito puede “mirar hacia afuera” al ámbito que lo rodea, por lo que <code>x</code> es visible dentro del bloque en el ejemplo. La excepción es cuando múltiples enlaces tienen el mismo nombre—en ese caso, el código solo puede ver el más interno. Por ejemplo, cuando el código dentro de la función <code>halve</code> hace referencia a <code>n</code>, está viendo su <em>propio</em> <code>n</code>, no el <code>n</code> global."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l3",
        "title": "Ámbito anidado",
        "sections": [
          {
            "id": "ch03-l3-s0",
            "title": "Ámbito anidado",
            "content": [
              {
                "type": "paragraph",
                "content": "JavaScript distingue no solo entre enlaces globales y locales. Bloques y funciones pueden ser creados dentro de otros bloques y funciones, produciendo múltiples grados de localidad."
              },
              {
                "type": "paragraph",
                "content": "Por ejemplo, esta función—que muestra los ingredientes necesarios para hacer un lote de hummus—tiene otra función dentro de ella:"
              },
              {
                "type": "paragraph",
                "content": "El código dentro de la función <code>ingredient</code> puede ver el enlace <code>factor</code> de la función exterior, pero sus enlaces locales, como <code>unit</code> o <code>ingredientAmount</code>, no son visibles en la función exterior."
              }
            ]
          },
          {
            "id": "ch03-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El conjunto de enlaces visibles dentro de un bloque está determinado por el lugar de ese bloque en el texto del programa. Cada bloque local también puede ver todos los bloques locales que lo contienen, y todos los bloques pueden ver el bloque global. Este enfoque de visibilidad de enlaces se llama <em>ámbito léxico</em>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l4",
        "title": "Funciones como valores",
        "sections": [
          {
            "id": "ch03-l4-s0",
            "title": "Funciones como valores",
            "content": [
              {
                "type": "paragraph",
                "content": "Generalmente un enlace de función simplemente actúa como un nombre para una parte específica del programa. Este enlace se define una vez y nunca se cambia. Esto hace que sea fácil confundir la función y su nombre."
              },
              {
                "type": "paragraph",
                "content": "Pero los dos son diferentes. Un valor de función puede hacer todas las cosas que pueden hacer otros valores: se puede utilizar en expresiones arbitrarias, no solo llamarlo. Es posible almacenar un valor de función en un nuevo enlace, pasarlo como argumento a una función, etc. De manera similar, un enlace que contiene una función sigue siendo solo un enlace habitual y, si no es constante, se le puede asignar un nuevo valor, así:"
              },
              {
                "type": "paragraph",
                "content": "En el Capítulo 5, discutiremos las cosas interesantes que podemos hacer al pasar valores de función a otras funciones."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch03-l5",
        "title": "Notación de declaración",
        "sections": [
          {
            "id": "ch03-l5-s0",
            "title": "Notación de declaración",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay una manera ligeramente más corta de crear un enlace de función. Cuando se utiliza la palabra clave <code>function</code> al inicio de una declaración, funciona de manera diferente:"
              },
              {
                "type": "paragraph",
                "content": "Esta es una función <em>declarativa</em>. La declaración define el enlace <code>square</code> y lo apunta a la función dada. Es un poco más fácil de escribir y no requiere un punto y coma después de la función."
              },
              {
                "type": "paragraph",
                "content": "Hay una sutileza con esta forma de definición de función."
              }
            ]
          },
          {
            "id": "ch03-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El código anterior funciona, incluso aunque la función esté definida <em>debajo</em> del código que la usa. Las declaraciones de función no forman parte del flujo de control regular de arriba hacia abajo. Conceptualmente se mueven al principio de su alcance y pueden ser utilizadas por todo el código en ese alcance. A veces esto es útil porque ofrece la libertad de ordenar el código de una manera que parezca más clara, sin tener que preocuparse por definir todas las funciones antes de que se utilicen."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l6",
        "title": "Funciones de flecha",
        "sections": [
          {
            "id": "ch03-l6-s0",
            "title": "Funciones de flecha",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay una tercera notación para funciones, que se ve muy diferente de las otras. En lugar de la palabra clave <code>function</code>, utiliza una flecha (<code>=&gt;</code>) compuesta por un signo igual y un caracter mayor que (no confundir con el operador mayor o igual, que se escribe <code>&gt;=</code>):"
              },
              {
                "type": "paragraph",
                "content": "La flecha viene <em>después</em> de la lista de parámetros y es seguida por el cuerpo de la función. Expresa algo así como “esta entrada (los parámetros) produce este resultado (el cuerpo)”."
              },
              {
                "type": "paragraph",
                "content": "Cuando solo hay un nombre de parámetro, puedes omitir los paréntesis alrededor de la lista de parámetros. Si el cuerpo es una sola expresión, en lugar de un bloque entre llaves, esa expresión será devuelta por la función. Por lo tanto, estas dos definiciones de <code>exponente</code> hacen lo mismo:"
              }
            ]
          },
          {
            "id": "ch03-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando una función de flecha no tiene parámetros en absoluto, su lista de parámetros es simplemente un conjunto vacío de paréntesis."
              },
              {
                "type": "paragraph",
                "content": "No hay una razón profunda para tener tanto funciones de flecha como expresiones <code>function</code> en el lenguaje. Aparte de un detalle menor, que discutiremos en el Capítulo 6, hacen lo mismo. Las funciones de flecha se agregaron en 2015, principalmente para hacer posible escribir expresiones de función pequeñas de una manera menos verbosa. Las usaremos a menudo en el Capítulo 5 ."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l7",
        "title": "La pila de llamadas",
        "sections": [
          {
            "id": "ch03-l7-s0",
            "title": "La pila de llamadas",
            "content": [
              {
                "type": "paragraph",
                "content": "La forma en que el control fluye a través de las funciones es un tanto complicada. Echemos un vistazo más de cerca. Aquí hay un programa simple que realiza algunas llamadas de función:"
              },
              {
                "type": "paragraph",
                "content": "Una ejecución de este programa va más o menos así: la llamada a <code>saludar</code> hace que el control salte al inicio de esa función (línea 2). La función llama a <code>console.log</code>, que toma el control, hace su trabajo, y luego devuelve el control a la línea 2. Allí, llega al final de la función <code>saludar</code>, por lo que regresa al lugar que la llamó, línea 4. La línea siguiente llama a <code>console.log</code> nuevamente. Después de ese retorno, el programa llega a su fin."
              },
              {
                "type": "paragraph",
                "content": "Podríamos mostrar el flujo de control esquemáticamente de esta manera:"
              }
            ]
          },
          {
            "id": "ch03-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dado que una función tiene que regresar al lugar que la llamó cuando termina, la computadora debe recordar el contexto desde el cual se realizó la llamada. En un caso, <code>console.log</code> tiene que regresar a la función <code>saludar</code> cuando haya terminado. En el otro caso, regresa al final del programa."
              },
              {
                "type": "paragraph",
                "content": "El lugar donde la computadora almacena este contexto es la <em>pila de llamadas</em>. Cada vez que se llama a una función, el contexto actual se almacena en la parte superior de esta pila. Cuando una función devuelve, elimina el contexto superior de la pila y usa ese contexto para continuar la ejecución."
              },
              {
                "type": "paragraph",
                "content": "Almacenar esta pila requiere espacio en la memoria de la computadora. Cuando la pila crece demasiado, la computadora fallará con un mensaje como “sin espacio en la pila” o “demasiada recursividad”. El siguiente código ilustra esto al hacerle a la computadora una pregunta realmente difícil que causa un vaivén infinito entre dos funciones. O más bien, <em>sería</em> infinito, si la computadora tuviera una pila infinita. Como no la tiene, nos quedaremos sin espacio o “reventaremos la pila”."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l8",
        "title": "Argumentos Opcionales",
        "sections": [
          {
            "id": "ch03-l8-s0",
            "title": "Argumentos Opcionales",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente código está permitido y se ejecuta sin ningún problema:"
              },
              {
                "type": "paragraph",
                "content": "Hemos definido <code>square</code> con solo un parámetro. Sin embargo, cuando lo llamamos con tres, el lenguaje no se queja. Ignora los argumentos adicionales y calcula el cuadrado del primero."
              },
              {
                "type": "paragraph",
                "content": "JavaScript es extremadamente flexible en cuanto al número de argumentos que puedes pasar a una función. Si pasas demasiados, los extras son ignorados. Si pasas muy pocos, los parámetros faltantes se les asigna el valor <code>undefined</code>."
              }
            ]
          },
          {
            "id": "ch03-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El inconveniente de esto es que es posible —incluso probable— que pases accidentalmente el número incorrecto de argumentos a las funciones. Y nadie te dirá nada al respecto. La ventaja es que puedes utilizar este comportamiento para permitir que una función sea llamada con diferentes números de argumentos. Por ejemplo, esta función <code>minus</code> intenta imitar al operador <code>-</code> actuando sobre uno o dos argumentos:"
              },
              {
                "type": "paragraph",
                "content": "Si escribes un operador <code>=</code> después de un parámetro, seguido de una expresión, el valor de esa expresión reemplazará al argumento cuando no se le dé. Por ejemplo, esta versión de <code>roundTo</code> hace que su segundo argumento sea opcional. Si no lo proporcionas o pasas el valor <code>undefined</code>, por defecto será uno:"
              },
              {
                "type": "paragraph",
                "content": "El próximo capítulo introducirá una forma en que un cuerpo de función puede acceder a la lista completa de argumentos que se le pasaron. Esto es útil porque le permite a una función aceptar cualquier número de argumentos. Por ejemplo, <code>console.log</code> lo hace, mostrando todos los valores que se le dan:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l9",
        "title": "Clausura",
        "sections": [
          {
            "id": "ch03-l9-s0",
            "title": "Clausura",
            "content": [
              {
                "type": "paragraph",
                "content": "La capacidad de tratar las funciones como valores, combinada con el hecho de que los enlaces locales se recrean cada vez que se llama a una función, plantea una pregunta interesante: ¿qué sucede con los enlaces locales cuando la llamada a la función que los creó ya no está activa?El siguiente código muestra un ejemplo de esto. Define una función, <code>wrapValue</code>, que crea un enlace local. Luego devuelve una función que accede a este enlace local y lo devuelve:"
              },
              {
                "type": "paragraph",
                "content": "Esto está permitido y funciona como esperarías: ambas instancias del enlace aún pueden accederse. Esta situación es una buena demostración de que los enlaces locales se crean nuevamente para cada llamada, y las diferentes llamadas no afectan los enlaces locales de los demás."
              },
              {
                "type": "paragraph",
                "content": "Esta característica, poder hacer referencia a una instancia específica de un enlace local en un ámbito superior, se llama <em>clausura</em>. Una función que hace referencia a enlaces de ámbitos locales a su alrededor se llama <em>una</em> clausura. Este comportamiento no solo te libera de tener que preocuparte por la vida útil de los enlaces, sino que también hace posible usar valores de función de formas creativas."
              }
            ]
          },
          {
            "id": "ch03-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Con un ligero cambio, podemos convertir el ejemplo anterior en una forma de crear funciones que multiplican por una cantidad arbitraria:"
              },
              {
                "type": "paragraph",
                "content": "El enlace explícito <code>local</code> del ejemplo <code>wrapValue</code> realmente no es necesario, ya que un parámetro es en sí mismo un enlace local."
              },
              {
                "type": "paragraph",
                "content": "Pensar en programas de esta manera requiere algo de práctica. Un buen modelo mental es pensar en los valores de función como que contienen tanto el código en su cuerpo como el entorno en el que fueron creados. Cuando se llama, el cuerpo de la función ve el entorno en el que fue creado, no el entorno en el que se llama."
              }
            ]
          },
          {
            "id": "ch03-l9-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En el ejemplo anterior, se llama a <code>multiplier</code> y crea un entorno en el que su parámetro <code>factor</code> está vinculado a 2. El valor de función que devuelve, que se almacena en <code>twice</code>, recuerda este entorno para que cuando se llame, multiplique su argumento por 2."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch03-l10",
        "title": "Recursión",
        "sections": [
          {
            "id": "ch03-l10-s0",
            "title": "Recursión",
            "content": [
              {
                "type": "paragraph",
                "content": "Es perfectamente válido que una función se llame a sí misma, siempre y cuando no lo haga tan a menudo que desborde la pila. Una función que se llama a sí misma se llama <em>recursiva</em>. La recursión permite que algunas funciones se escriban de una manera diferente. Toma, por ejemplo, esta función <code>power</code>, que hace lo mismo que el operador <code>**</code> (potenciación):"
              },
              {
                "type": "paragraph",
                "content": "Esto se asemeja bastante a la forma en que los matemáticos definen la potenciación y describe el concepto de manera más clara que el bucle que usamos en el Capítulo 2. La función se llama a sí misma varias veces con exponentes cada vez más pequeños para lograr la multiplicación repetida."
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, esta implementación tiene un problema: en implementaciones típicas de JavaScript, es aproximadamente tres veces más lenta que una versión que utiliza un bucle <code>for</code>. Recorrer un simple bucle suele ser más económico que llamar a una función múltiples veces."
              }
            ]
          },
          {
            "id": "ch03-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El dilema de velocidad versus elegancia es interesante. Se puede ver como una especie de continuo entre la compatibilidad con los humanos y las máquinas. Casi cualquier programa puede ser acelerado haciendo que sea más extenso y complicado. El programador debe encontrar un equilibrio apropiado."
              },
              {
                "type": "paragraph",
                "content": "En el caso de la función <code>power</code>, una versión poco elegante (con bucles) sigue siendo bastante simple y fácil de leer. No tiene mucho sentido reemplazarla con una función recursiva. Sin embargo, a menudo un programa trata con conceptos tan complejos que es útil renunciar a algo de eficiencia para hacer que el programa sea más sencillo."
              },
              {
                "type": "paragraph",
                "content": "Preocuparse por la eficiencia puede ser una distracción. Es otro factor que complica el diseño del programa y cuando estás haciendo algo que ya es difícil, ese extra en lo que preocuparse puede llegar a ser paralizante."
              }
            ]
          },
          {
            "id": "ch03-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por lo tanto, generalmente deberías comenzar escribiendo algo que sea correcto y fácil de entender. Si te preocupa que sea demasiado lento—lo cual suele ser raro, ya que la mayoría del código simplemente no se ejecuta lo suficiente como para tomar una cantidad significativa de tiempo—puedes medir después y mejorarlo si es necesario."
              },
              {
                "type": "paragraph",
                "content": "La recursión no siempre es simplemente una alternativa ineficiente a los bucles. Algunos problemas realmente son más fáciles de resolver con recursión que con bucles. Con mayor frecuencia, estos son problemas que requieren explorar o procesar varias “ramas”, cada una de las cuales podría ramificarse nuevamente en aún más ramas."
              },
              {
                "type": "paragraph",
                "content": "Considera este rompecabezas: al comenzar desde el número 1 y repetidamente sumar 5 o multiplicar por 3, se puede producir un conjunto infinito de números. ¿Cómo escribirías una función que, dado un número, intente encontrar una secuencia de tales sumas y multiplicaciones que produzcan ese número? Por ejemplo, el número 13 podría alcanzarse al multiplicar por 3 y luego sumar 5 dos veces, mientras que el número 15 no podría alcanzarse en absoluto."
              }
            ]
          },
          {
            "id": "ch03-l10-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Aquí tienes una solución recursiva:"
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que este programa no necesariamente encuentra la secuencia de operaciones más <em>corta</em>. Se conforma con encontrar cualquier secuencia."
              },
              {
                "type": "paragraph",
                "content": "No te preocupes si no ves cómo funciona este código de inmediato. Vamos a trabajar juntos, ya que es un gran ejercicio de pensamiento recursivo. La función interna <code>encontrar</code> es la que realiza la recursión real. Toma dos argumentos: el número actual y una cadena que registra cómo llegamos a este número. Si encuentra una solución, devuelve una cadena que muestra cómo llegar al objetivo. Si no puede encontrar una solución comenzando desde este número, devuelve <code>null</code>."
              }
            ]
          },
          {
            "id": "ch03-l10-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para hacer esto, la función realiza una de tres acciones. Si el número actual es el número objetivo, el historial actual es una forma de alcanzar ese objetivo, por lo que se devuelve. Si el número actual es mayor que el objetivo, no tiene sentido explorar más esta rama porque tanto la suma como la multiplicación solo harán que el número sea más grande, por lo que devuelve <code>null</code>. Finalmente, si aún estamos por debajo del número objetivo, la función prueba ambas rutas posibles que parten del número actual llamándose a sí misma dos veces, una vez para la suma y otra vez para la multiplicación. Si la primera llamada devuelve algo que no es <code>null</code>, se devuelve. De lo contrario, se devuelve la segunda llamada, independientemente de si produce una cadena o <code>null</code>."
              },
              {
                "type": "paragraph",
                "content": "Para entender mejor cómo esta función produce el efecto que estamos buscando, veamos todas las llamadas a <code>encontrar</code> que se hacen al buscar una solución para el número 13:"
              },
              {
                "type": "paragraph",
                "content": "La sangría indica la profundidad de la pila de llamadas. La primera vez que se llama a <code>encontrar</code>, la función comienza llamándose a sí misma para explorar la solución que comienza con <code>(1 + 5)</code>. Esa llamada seguirá recursivamente para explorar <em>cada</em> solución a continuación que produzca un número menor o igual al número objetivo. Como no encuentra uno que alcance el objetivo, devuelve <code>null</code> a la primera llamada. Allí, el operador <code>??</code> hace que ocurra la llamada que explora <code>(1 * 3)</code>. Esta búsqueda tiene más suerte: su primera llamada recursiva, a través de otra llamada recursiva, alcanza el número objetivo. Esa llamada más interna devuelve una cadena, y cada uno de los operadores <code>??</code> en las llamadas intermedias pasa esa cadena, devolviendo en última instancia la solución."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch03-l11",
        "title": "Crecimiento de funciones",
        "sections": [
          {
            "id": "ch03-l11-s0",
            "title": "Crecimiento de funciones",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay dos formas más o menos naturales de introducir funciones en los programas."
              },
              {
                "type": "paragraph",
                "content": "La primera ocurre cuando te encuentras escribiendo código similar varias veces. Preferirías no hacer eso, ya que tener más código significa más espacio para que se escondan los errores y más material para que las personas que intentan entender el programa lo lean. Por lo tanto, tomas la funcionalidad repetida, encuentras un buen nombre para ella y la colocas en una función."
              },
              {
                "type": "paragraph",
                "content": "La segunda forma es que te das cuenta de que necesitas alguna funcionalidad que aún no has escrito y que suena como si mereciera su propia función. Comienzas por nombrar la función, luego escribes su cuerpo. Incluso podrías comenzar a escribir código que use la función antes de definir la función en sí."
              }
            ]
          },
          {
            "id": "ch03-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Lo difícil que es encontrar un buen nombre para una función es una buena indicación de lo claro que es el concepto que estás tratando de envolver con ella. Vamos a través de un ejemplo."
              },
              {
                "type": "paragraph",
                "content": "Queremos escribir un programa que imprima dos números: el número de vacas y de pollos en una granja, con las palabras <code>Vacas</code> y <code>Pollos</code> después de ellos y ceros rellenados antes de ambos números para que siempre tengan tres dígitos:"
              },
              {
                "type": "paragraph",
                "content": "Esto pide una función con dos argumentos: el número de vacas y el número de pollos. ¡Vamos a programar!"
              }
            ]
          },
          {
            "id": "ch03-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribir <code>.length</code> después de una expresión de cadena nos dará la longitud de esa cadena. Por lo tanto, los bucles <code>while</code> siguen añadiendo ceros delante de las cadenas de números hasta que tengan al menos tres caracteres de longitud."
              },
              {
                "type": "paragraph",
                "content": "¡Misión cumplida! Pero justo cuando estamos a punto de enviarle a la granjera el código (junto con una jugosa factura), ella llama y nos dice que también ha comenzado a criar cerdos, ¿podríamos extender el software para imprimir también los cerdos?"
              },
              {
                "type": "paragraph",
                "content": "¡Claro que podemos! Pero justo cuando estamos en el proceso de copiar y pegar esas cuatro líneas una vez más, nos detenemos y reconsideramos. Tiene que haber una mejor manera. Aquí está un primer intento:"
              }
            ]
          },
          {
            "id": "ch03-l11-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¡Funciona! Pero ese nombre, <code>imprimirConRellenoYEtiqueta</code>, es un poco incómodo. Confluye tres cosas: imprimir, rellenar con ceros y añadir una etiqueta, en una sola función."
              },
              {
                "type": "paragraph",
                "content": "En lugar de sacar la parte repetida de nuestro programa completamente, intentemos sacar un solo <em>concepto</em>:"
              },
              {
                "type": "paragraph",
                "content": "Una función con un nombre claro y obvio como <code>rellenarConCeros</code> hace que sea más fácil para alguien que lee el código entender qué hace. Además, una función así es útil en más situaciones que solo este programa específico. Por ejemplo, podrías usarla para ayudar a imprimir tablas de números alineadas correctamente."
              }
            ]
          },
          {
            "id": "ch03-l11-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¿Qué tan inteligente y versátil <em>debería</em> ser nuestra función? Podríamos escribir cualquier cosa, desde una función terriblemente simple que solo puede rellenar un número para que tenga tres caracteres de ancho hasta un sistema complejo de formato de números general que maneje números fraccionarios, números negativos, alineación de puntos decimales, relleno con diferentes caracteres y más."
              },
              {
                "type": "paragraph",
                "content": "Un principio útil es abstenerse de agregar ingenio a menos que estés absolutamente seguro de que lo vas a necesitar. Puede ser tentador escribir “frameworks” genéricos para cada trozo de funcionalidad que te encuentres. Resiste esa tentación. No lograrás hacer ningún trabajo real: estarás demasiado ocupado escribiendo código que nunca usarás."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch03-l12",
        "title": "Funciones y efectos secundarios",
        "sections": [
          {
            "id": "ch03-l12-s0",
            "title": "Funciones y efectos secundarios",
            "content": [
              {
                "type": "paragraph",
                "content": "Las funciones pueden dividirse aproximadamente en aquellas que se llaman por sus efectos secundarios y aquellas que se llaman por su valor de retorno (aunque también es posible tener efectos secundarios y devolver un valor)."
              },
              {
                "type": "paragraph",
                "content": "La primera función auxiliar en el ejemplo de la granja, <code>imprimirConRellenoYEtiqueta</code>, se llama por su efecto secundario: imprime una línea. La segunda versión, <code>rellenarConCeros</code>, se llama por su valor de retorno. No es casualidad que la segunda sea útil en más situaciones que la primera. Las funciones que crean valores son más fáciles de combinar de nuevas formas que las funciones que realizan efectos secundarios directamente."
              },
              {
                "type": "paragraph",
                "content": "Una función <em>pura</em> es un tipo específico de función productora de valor que no solo no tiene efectos secundarios, sino que tampoco depende de efectos secundarios de otro código, por ejemplo, no lee enlaces globales cuyo valor podría cambiar. Una función pura tiene la agradable propiedad de que, al llamarla con los mismos argumentos, siempre produce el mismo valor (y no hace nada más). Una llamada a tal función puede sustituirse por su valor de retorno sin cambiar el significado del código. Cuando no estás seguro de si una función pura está funcionando correctamente, puedes probarla llamándola y saber que si funciona en ese contexto, funcionará en cualquier otro. Las funciones no puras tienden a requerir más andamiaje para probarlas."
              }
            ]
          },
          {
            "id": "ch03-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Aún así, no hay necesidad de sentirse mal al escribir funciones que no son puras. Los efectos secundarios a menudo son útiles. No hay forma de escribir una versión pura de <code>console.log</code>, por ejemplo, y es bueno tener <code>console.log</code>. Algunas operaciones también son más fáciles de expresar de manera eficiente cuando usamos efectos secundarios."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch03-l13",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch03-l13-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Este capítulo te enseñó cómo escribir tus propias funciones. La palabra clave <code>function</code>, cuando se usa como expresión, puede crear un valor de función. Cuando se usa como una declaración, puede usarse para declarar un enlace y darle una función como su valor. Las funciones de flecha son otra forma de crear funciones."
              },
              {
                "type": "paragraph",
                "content": "Una parte clave para entender las funciones es comprender los ámbitos (scopes). Cada bloque crea un nuevo ámbito. Los parámetros y los enlaces declarados en un ámbito dado son locales y no son visibles desde el exterior. Los enlaces declarados con <code>var</code> se comportan de manera diferente: terminan en el ámbito de la función más cercana o en el ámbito global."
              },
              {
                "type": "paragraph",
                "content": "Separar las tareas que realiza tu programa en diferentes funciones es útil. No tendrás que repetirte tanto, y las funciones pueden ayudar a organizar un programa agrupando el código en piezas que hacen cosas específicas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch03-l14",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch03-l14-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "El capítulo previo presentó la función estándar <code>Math.min</code> que devuelve su menor argumento. Ahora podemos escribir una función como esa nosotros mismos. Define la función <code>min</code> que toma dos argumentos y devuelve su mínimo."
              },
              {
                "type": "paragraph",
                "content": "Si tienes problemas para colocar llaves y paréntesis en el lugar correcto para obtener una definición de función válida, comienza copiando uno de los ejemplos de este capítulo y modifícalo."
              },
              {
                "type": "paragraph",
                "content": "Una función puede contener múltiples declaraciones <code>return</code>."
              }
            ]
          },
          {
            "id": "ch03-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Hemos visto que podemos usar <code>%</code> (el operador de resto) para verificar si un número es par o impar al usar <code>% 2</code> para ver si es divisible por dos. Aquí hay otra forma de definir si un número entero positivo es par o impar:"
              },
              {
                "type": "list",
                "content": [
                  "El cero es par.",
                  "El uno es impar.",
                  "Para cualquier otro número N, su paridad es la misma que N - 2."
                ]
              },
              {
                "type": "paragraph",
                "content": "Define una función recursiva <code>isEven</code> que corresponda a esta descripción. La función debe aceptar un solo parámetro (un número entero positivo) y devolver un booleano."
              }
            ]
          },
          {
            "id": "ch03-l14-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pruébalo con 50 y 75. Observa cómo se comporta con -1. ¿Por qué? ¿Puedes pensar en una forma de solucionarlo?"
              },
              {
                "type": "paragraph",
                "content": "Es probable que tu función se parezca en cierta medida a la función interna <code>encontrar</code> en el ejemplo recursivo <code>encontrarSolucion</code> ejemplo de este capítulo, con una cadena <code>if</code>/<code>else if</code>/<code>else</code> que prueba cuál de los tres casos aplica. El <code>else</code> final, correspondiente al tercer caso, realiza la llamada recursiva. Cada una de las ramas debe contener una declaración <code>return</code> o de alguna otra manera asegurarse de que se devuelva un valor específico."
              },
              {
                "type": "paragraph",
                "content": "Cuando se le da un número negativo, la función se llamará recursivamente una y otra vez, pasándose a sí misma un número cada vez más negativo, alejándose así más y más de devolver un resultado. Eventualmente se quedará sin espacio en la pila y se abortará."
              }
            ]
          },
          {
            "id": "ch03-l14-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes obtener el *ésimo carácter, o letra, de una cadena escribiendo <code>[N]</code> después de la cadena (por ejemplo, <code>cadena[2]</code>). El valor resultante será una cadena que contiene solo un carácter (por ejemplo, <code>\"b\"</code>). El primer carácter tiene la posición 0, lo que hace que el último se encuentre en la posición <code>cadena.<wbr>length - 1</code>. En otras palabras, una cadena de dos caracteres tiene longitud 2, y sus caracteres tienen posiciones 0 y 1."
              },
              {
                "type": "paragraph",
                "content": "Escribe una función <code>contarBs</code> que tome una cadena como único argumento y devuelva un número que indique cuántos caracteres B en mayúscula hay en la cadena."
              },
              {
                "type": "paragraph",
                "content": "A continuación, escribe una función llamada <code>contarCaracter</code> que se comporte como <code>contarBs</code>, excepto que toma un segundo argumento que indica el carácter que se va a contar (en lugar de contar solo caracteres B en mayúscula). Reescribe <code>contarBs</code> para hacer uso de esta nueva función."
              }
            ]
          },
          {
            "id": "ch03-l14-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tu función necesida un bucle que mire cada carácter en la cadena. Puede ejecutar un índice desde cero hasta uno menos que su longitud (<code>&lt; string.<wbr>length</code>). Si el carácter en la posición actual es el mismo que el que la función está buscando, agrega 1 a una variable de contador. Una vez que el bucle ha terminado, el contador puede ser devuelto."
              },
              {
                "type": "paragraph",
                "content": "Ten cuidado de que todas las vinculaciones utilizadas en la función sean <em>locales</em> a la función, declarándolas correctamente con la palabra clave <code>let</code> o <code>const</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      }
    ]
  },
  {
    "id": "ch04",
    "number": 4,
    "title": "Estructuras de datos: Objetos y Arrays",
    "titleEs": "Estructuras de datos: Objetos y Arrays",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "En dos ocasiones me han preguntado: ‘Dígame, Sr. Babbage, si introduce en la máquina cifras erróneas, ¿saldrán respuestas correctas?’ [...] No soy cap...",
    "isProject": false,
    "totalXP": 710,
    "lessons": [
      {
        "id": "ch04-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch04-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "En dos ocasiones me han preguntado: ‘Dígame, Sr. Babbage, si introduce en la máquina cifras erróneas, ¿saldrán respuestas correctas?’ [...] No soy capaz de entender correctamente el tipo de confusión de ideas que podría provocar tal pregunta. Charles Babbage, Passages from the Life of a Philosopher (1864)"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructuras de datos_ Objetos y Arrays __ Eloquent JavaScript_files/chapter_picture_4.jpg",
                "alt": "Ilustración de una ardilla junto a un montón de libros y un par de gafas. Se pueden ver la luna y las estrellas en el fondo."
              },
              {
                "type": "paragraph",
                "content": "Números, booleanos y cadenas de texto son los átomos a partir de los cuales se construyen las estructuras de datos. Sin embargo, muchos tipos de información requieren más de un átomo. Los <em>objetos</em> nos permiten agrupar valores, incluyendo otros objetos, para construir estructuras más complejas."
              }
            ]
          },
          {
            "id": "ch04-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Hasta ahora, los programas que hemos creado han estado limitados por el hecho de que operaban solo en tipos de datos simples. Después de aprender los conceptos básicos de estructuras de datos en este capítulo, sabrás lo suficiente como para comenzar a escribir programas útiles."
              },
              {
                "type": "paragraph",
                "content": "El capítulo trabajará a través de un ejemplo de programación más o menos realista, introduciendo conceptos a medida que se aplican al problema en cuestión. El código de ejemplo a menudo se basará en funciones y variables introducidas anteriormente en el libro."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l1",
        "title": "El hombreardilla",
        "sections": [
          {
            "id": "ch04-l1-s0",
            "title": "El hombreardilla",
            "content": [
              {
                "type": "paragraph",
                "content": "De vez en cuando, usualmente entre las 8 p. m. y las 10 p. m., Jacques se transforma en un pequeño roedor peludo con una cola espesa."
              },
              {
                "type": "paragraph",
                "content": "Por un lado, Jacques está bastante contento de no tener licantropía clásica. Convertirse en una ardilla causa menos problemas que convertirse en un lobo. En lugar de preocuparse por comer accidentalmente al vecino (<em>eso</em> sería incómodo), se preocupa por ser comido por el gato del vecino. Después de dos ocasiones de despertar en una rama peligrosamente delgada en la copa de un roble, desnudo y desorientado, ha optado por cerrar con llave las puertas y ventanas de su habitación por la noche y poner unas cuantas nueces en el suelo para mantenerse ocupado."
              },
              {
                "type": "paragraph",
                "content": "Pero Jacques preferiría deshacerse por completo de su condición. Las ocurrencias irregulares de la transformación hacen que sospeche que podrían ser desencadenadas por algo. Durante un tiempo, creyó que sucedía solo en días en los que había estado cerca de robles. Sin embargo, evitar los robles no resolvió el problema."
              }
            ]
          },
          {
            "id": "ch04-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cambió a un enfoque más científico, Jacques ha comenzado a llevar un registro diario de todo lo que hace en un día dado y si cambió de forma. Con estos datos, espera estrechar las condiciones que desencadenan las transformaciones. Lo primero que necesita es una estructura de datos para almacenar esta información."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l2",
        "title": "Conjuntos de datos",
        "sections": [
          {
            "id": "ch04-l2-s0",
            "title": "Conjuntos de datos",
            "content": [
              {
                "type": "paragraph",
                "content": "Para trabajar con un conjunto de datos digitales, primero tenemos que encontrar una forma de representarlo en la memoria de nuestra máquina. Digamos, por ejemplo, que queremos representar una colección de los números 2, 3, 5, 7 y 11."
              },
              {
                "type": "paragraph",
                "content": "Podríamos ser creativos con las cadenas, después de todo, las cadenas pueden tener cualquier longitud, por lo que podemos poner muchos datos en ellas, y usar <code>\"2 3 5 7 11\"</code> como nuestra representación. Pero esto es incómodo. Tendríamos que extraer de alguna manera los dígitos y convertirlos de vuelta a números para acceder a ellos."
              },
              {
                "type": "paragraph",
                "content": "Afortunadamente, JavaScript proporciona un tipo de dato específicamente para almacenar secuencias de valores. Se llama un <em>array</em> y se escribe como una lista de valores entre corchetes, separados por comas:"
              }
            ]
          },
          {
            "id": "ch04-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La notación para acceder a los elementos dentro de un array también utiliza corchetes. Un par de corchetes inmediatamente después de una expresión, con otra expresión dentro de ellos, buscará el elemento en la expresión de la izquierda que corresponde al <em>índice</em> dado por la expresión en los corchetes."
              },
              {
                "type": "paragraph",
                "content": "El primer índice de un array es cero, no uno, por lo que el primer elemento se recupera con <code>listaDeNumeros[0]</code>. El conteo basado en cero tiene una larga tradición en tecnología y, de cierta manera, tiene mucho sentido, pero se necesita un poco de tiempo para acostumbrarse. Piensa en el índice como el número de elementos a omitir, contando desde el inicio del array."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l3",
        "title": "Propiedades",
        "sections": [
          {
            "id": "ch04-l3-s0",
            "title": "Propiedades",
            "content": [
              {
                "type": "paragraph",
                "content": "Hemos visto algunas expresiones como <code>miCadena.length</code> (para obtener la longitud de una cadena) y <code>Math.max</code> (la función máxima) en capítulos anteriores. Estas expresiones acceden a una <em>propiedad</em> de algún valor. En el primer caso, accedemos a la propiedad <code>length</code> del valor en <code>miCadena</code>. En el segundo, accedemos a la propiedad llamada <code>max</code> en el objeto <code>Math</code> (que es una colección de constantes y funciones relacionadas con matemáticas)."
              },
              {
                "type": "paragraph",
                "content": "Casi todos los valores de JavaScript tienen propiedades. Las excepciones son <code>null</code> y <code>undefined</code>. Si intentas acceder a una propiedad en uno de estos valores no definidos, obtendrás un error:"
              },
              {
                "type": "paragraph",
                "content": "Las dos formas principales de acceder a propiedades en JavaScript son con un punto y con corchetes. Tanto <code>valor.x</code> como <code>valor[x]</code> acceden a una propiedad en <code>valor</code>, pero no necesariamente a la misma propiedad. La diferencia radica en cómo se interpreta <code>x</code>. Al usar un punto, la palabra después del punto es el nombre literal de la propiedad. Al usar corchetes, la expresión entre los corchetes es <em>evaluada</em> para obtener el nombre de la propiedad. Mientras que <code>valor.x</code> obtiene la propiedad de <code>valor</code> llamada “x”, <code>valor[x]</code> toma el valor de la variable llamada <code>x</code> y lo utiliza, convertido a cadena, como nombre de propiedad. Si sabes que la propiedad en la que estás interesado se llama <em>color</em>, dices <code>valor.color</code>. Si quieres extraer la propiedad nombrada por el valor almacenado en la vinculación <code>i</code>, dices <code>valor[i]</code>. Los nombres de las propiedades son cadenas de texto. Pueden ser cualquier cadena, pero la notación de punto solo funciona con nombres que parecen nombres de vinculaciones válidos, comenzando con una letra o guion bajo, y conteniendo solo letras, números y guiones bajos. Si deseas acceder a una propiedad llamada <em>2</em> o <em>John Doe</em>, debes utilizar corchetes: <code>valor[2]</code> o <code>valor[\"John Doe\"]</code>."
              }
            ]
          },
          {
            "id": "ch04-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los elementos en un array se almacenan como propiedades del array, utilizando números como nombres de propiedades. Dado que no puedes usar la notación de punto con números y generalmente quieres usar una vinculación que contenga el índice de todos modos, debes utilizar la notación de corchetes para acceder a ellos."
              },
              {
                "type": "paragraph",
                "content": "Al igual que las cadenas de texto, los arrays tienen una propiedad <code>length</code> que nos dice cuántos elementos tiene el array."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l4",
        "title": "Métodos",
        "sections": [
          {
            "id": "ch04-l4-s0",
            "title": "Métodos",
            "content": [
              {
                "type": "paragraph",
                "content": "Tanto los valores de cadena como los de array contienen, además de la propiedad <code>length</code>, varias propiedades que contienen valores de función."
              },
              {
                "type": "paragraph",
                "content": "Cada cadena de texto tiene una propiedad <code>toUpperCase</code>. Cuando se llama, devolverá una copia de la cadena en la que todas las letras se han convertido a mayúsculas. También existe <code>toLowerCase</code>, que hace lo contrario."
              },
              {
                "type": "paragraph",
                "content": "Curiosamente, aunque la llamada a <code>toUpperCase</code> no pasa argumentos, de alguna manera la función tiene acceso a la cadena <code>\"Doh\"</code>, el valor cuya propiedad llamamos. Descubrirás cómo funciona esto en el Capítulo 6."
              }
            ]
          },
          {
            "id": "ch04-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las propiedades que contienen funciones generalmente se llaman <em>métodos</em> del valor al que pertenecen, como en “<code>toUpperCase</code> es un método de una cadena”."
              },
              {
                "type": "paragraph",
                "content": "Este ejemplo demuestra dos métodos que puedes utilizar para manipular arrays:"
              },
              {
                "type": "paragraph",
                "content": "El método <code>push</code> agrega valores al final de un array. El método <code>pop</code> hace lo opuesto, eliminando el último valor en el array y devolviéndolo."
              }
            ]
          },
          {
            "id": "ch04-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Estos nombres un tanto tontos son términos tradicionales para operaciones en una <em>pila</em>. Una pila, en programación, es una estructura de datos que te permite agregar valores a ella y sacarlos en el orden opuesto para que lo que se agregó último se elimine primero. Las pilas son comunes en programación; es posible que recuerdes la función call stack del capítulo anterior, que es una instancia de la misma idea."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch04-l5",
        "title": "Objetos",
        "sections": [
          {
            "id": "ch04-l5-s0",
            "title": "Objetos",
            "content": [
              {
                "type": "paragraph",
                "content": "De vuelta al hombre-ardilla. Un conjunto de entradas de registro diario se puede representar como un array, pero las entradas no consisten solo en un número o una cadena, cada entrada necesita almacenar una lista de actividades y un valor booleano que indique si Jacques se convirtió en ardilla o no. Idealmente, nos gustaría agrupar estos elementos en un único valor y luego poner esos valores agrupados en un array de entradas de registro."
              },
              {
                "type": "paragraph",
                "content": "Los valores del tipo object son colecciones arbitrarias de propiedades. Una forma de crear un objeto es usando llaves como una expresión:"
              },
              {
                "type": "paragraph",
                "content": "Dentro de las llaves, se escribe una lista de propiedades separadas por comas. Cada propiedad tiene un nombre seguido por dos puntos y un valor. Cuando un objeto se escribe en varias líneas, indentarlo como se muestra en este ejemplo ayuda a la legibilidad. Las propiedades cuyos nombres no son nombres de enlace válidos o números válidos deben ir entre comillas:"
              }
            ]
          },
          {
            "id": "ch04-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto significa que las llaves tienen <em>dos</em> significados en JavaScript. Al principio de una sentencia, comienzan un bloque de sentencias. En cualquier otra posición, describen un objeto. Afortunadamente, rara vez es útil comenzar una sentencia con un objeto entre llaves, por lo que la ambigüedad entre estos dos casos no es gran problema. El único caso en el que esto surge es cuando quiere devolver un objeto desde una función flecha abreviada: no se puede escribir <code>n =&gt; {prop: n}</code>, ya que las llaves se interpretarán como el cuerpo de una función. En cambio, se debe poner un conjunto de paréntesis alrededor del objeto para dejar claro que es una expresión."
              },
              {
                "type": "paragraph",
                "content": "Al leer una propiedad que no existe, obtendrás el valor <code>undefined</code>."
              },
              {
                "type": "paragraph",
                "content": "Es posible asignar un valor a una expresión de propiedad con el operador <code>=</code>. Esto reemplazará el valor de la propiedad si ya existía o creará una nueva propiedad en el objeto si no existía."
              }
            ]
          },
          {
            "id": "ch04-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para volver brevemente a nuestro modelo de tentáculos de enlaces, los enlaces de propiedad son similares. <em>Agarran</em> valores, pero otros enlaces y propiedades podrían estar aferrándose a esos mismos valores. Puedes pensar en los objetos como pulpos con cualquier cantidad de tentáculos, cada uno con un nombre escrito en él."
              },
              {
                "type": "paragraph",
                "content": "El operador <code>delete</code> corta un tentáculo de dicho pulpo. Es un operador unario que, cuando se aplica a una propiedad de un objeto, eliminará la propiedad nombrada del objeto. Esto no es algo común de hacer, pero es posible."
              },
              {
                "type": "paragraph",
                "content": "El operador binario <code>in</code>, cuando se aplica a una cadena y a un objeto, te dice si ese objeto tiene una propiedad con ese nombre. La diferencia entre establecer una propiedad como <code>undefined</code> y realmente borrarla es que, en el primer caso, el objeto todavía <em>tiene</em> la propiedad (simplemente no tiene un valor muy interesante), mientras que en el segundo caso la propiedad ya no está presente y <code>in</code> devolverá <code>false</code>."
              }
            ]
          },
          {
            "id": "ch04-l5-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para averiguar qué propiedades tiene un objeto, puedes utilizar la función <code>Object.keys</code>. Al darle la función un objeto, devolverá un array de cadenas: los nombres de las propiedades del objeto:"
              },
              {
                "type": "paragraph",
                "content": "Existe una función <code>Object.assign</code> que copia todas las propiedades de un objeto en otro:"
              },
              {
                "type": "paragraph",
                "content": "Los arrays, entonces, son solo un tipo de objeto especializado para almacenar secuencias de cosas. Si evalúas <code>typeof []</code>, producirá <code>\"object\"</code>. Puedes visualizar los arrays como pulpos largos y planos con todos sus tentáculos en una fila ordenada, etiquetados con números."
              }
            ]
          },
          {
            "id": "ch04-l5-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Jacques representará el diario que lleva como un array de objetos:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch04-l6",
        "title": "Mutabilidad",
        "sections": [
          {
            "id": "ch04-l6-s0",
            "title": "Mutabilidad",
            "content": [
              {
                "type": "paragraph",
                "content": "Pronto llegaremos a la programación real, pero primero, hay una pieza más de teoría para entender."
              },
              {
                "type": "paragraph",
                "content": "Vimos que los valores de objetos pueden modificarse. Los tipos de valores discutidos en capítulos anteriores, como números, cadenas y booleanos, son todos <em>inmutables</em>—es imposible cambiar valores de esos tipos. Puedes combinarlos y derivar nuevos valores de ellos, pero al tomar un valor específico de cadena, ese valor siempre permanecerá igual. El texto dentro de él no puede ser cambiado. Si tienes una cadena que contiene <code>\"gato\"</code>, no es posible que otro código cambie un carácter en tu cadena para que diga <code>\"rata\"</code>."
              },
              {
                "type": "paragraph",
                "content": "Los objetos funcionan de manera diferente. <em>Puedes</em> cambiar sus propiedades, lo que hace que un valor de objeto tenga un contenido diferente en momentos diferentes."
              }
            ]
          },
          {
            "id": "ch04-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando tenemos dos números, 120 y 120, podemos considerarlos precisamente el mismo número, tanto si se refieren a los mismos bits físicos como si no. Con los objetos, hay una diferencia entre tener dos referencias al mismo objeto y tener dos objetos diferentes que contienen las mismas propiedades. Considera el siguiente código:"
              },
              {
                "type": "paragraph",
                "content": "Las asignaciones <code>object1</code> y <code>object2</code> contienen la <em>misma</em> referencia al objeto, por lo que al cambiar <code>object1</code> también se cambia el valor de <code>object2</code>. Se dice que tienen la misma <em>identidad</em>. La asignación <code>object3</code> apunta a un objeto diferente, que inicialmente contiene las mismas propiedades que <code>object1</code> pero vive una vida separada."
              },
              {
                "type": "paragraph",
                "content": "Las asignaciones pueden ser modificables o constantes, pero esto es independiente de cómo se comportan sus valores. Aunque los valores numéricos no cambian, puedes utilizar una asignación <code>let</code> para hacer un seguimiento de un número que cambia al cambiar el valor al que apunta la asignación. De manera similar, aunque una asignación <code>const</code> a un objeto en sí no puede cambiarse y seguirá apuntando al mismo objeto, los <em>contenidos</em> de ese objeto pueden cambiar."
              }
            ]
          },
          {
            "id": "ch04-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se comparan objetos con el operador <code>==</code> de JavaScript, se compara por identidad: producirá <code>true</code> solo si ambos objetos son exactamente el mismo valor. Comparar objetos diferentes devolverá <code>false</code>, incluso si tienen propiedades idénticas. No hay una operación de comparación “profunda” incorporada en JavaScript que compare objetos por contenido, pero es posible escribirla tú mismo (lo cual es uno de los ejercicios al final de este capítulo)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch04-l7",
        "title": "El diario del licántropo",
        "sections": [
          {
            "id": "ch04-l7-s0",
            "title": "El diario del licántropo",
            "content": [
              {
                "type": "paragraph",
                "content": "Jacques inicia su intérprete de JavaScript y configura el entorno que necesita para mantener su diario:"
              },
              {
                "type": "paragraph",
                "content": "Observa que el objeto agregado al diario luce un poco extraño. En lugar de declarar propiedades como <code>events: events</code>, simplemente se da un nombre de propiedad: <code>events</code>. Esta es una forma abreviada que significa lo mismo: si un nombre de propiedad en notación de llaves no va seguido de un valor, su valor se toma del enlace con el mismo nombre."
              },
              {
                "type": "paragraph",
                "content": "Cada noche a las 10 p.m., o a veces a la mañana siguiente después de bajar de la repisa superior de su estantería, Jacques registra el día:"
              }
            ]
          },
          {
            "id": "ch04-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una vez que tiene suficientes puntos de datos, tiene la intención de utilizar estadísticas para descubrir qué eventos pueden estar relacionados con las transformaciones en ardilla."
              },
              {
                "type": "paragraph",
                "content": "La <em>correlación</em> es una medida de la dependencia entre variables estadísticas. Una variable estadística no es exactamente igual a una variable de programación. En estadística, típicamente tienes un conjunto de <em>mediciones</em>, y cada variable se mide para cada medición. La correlación entre variables suele expresarse como un valor que va de -1 a 1. Una correlación de cero significa que las variables no están relacionadas. Una correlación de 1 indica que las dos están perfectamente relacionadas: si conoces una, también conoces la otra. Un -1 también significa que las variables están perfectamente relacionadas pero son opuestas: cuando una es verdadera, la otra es falsa."
              },
              {
                "type": "paragraph",
                "content": "Para calcular la medida de correlación entre dos variables booleanas, podemos utilizar el <em>coeficiente phi</em> (<em>ϕ</em>). Esta es una fórmula cuya entrada es una tabla de frecuencias que contiene la cantidad de veces que se observaron las diferentes combinaciones de las variables. La salida de la fórmula es un número entre -1 y 1 que describe la correlación."
              }
            ]
          },
          {
            "id": "ch04-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Podríamos tomar el evento de comer pizza y ponerlo en una tabla de frecuencias como esta, donde cada número indica la cantidad de veces que ocurrió esa combinación en nuestras mediciones."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructuras de datos_ Objetos y Arrays __ Eloquent JavaScript_files/pizza-squirrel.svg",
                "alt": "Una tabla de dos por dos que muestra la variable pizza en el eje horizontal y la variable ardilla en el eje vertical. Cada celda muestra cuántas veces ocurrió esa combinación. En 76 casos, ninguna ocurrió. En 9 casos, solo la pizza era verdadera. En 4 casos, solo la ardilla era verdadera. Y en un caso ambas ocurrieron."
              },
              {
                "type": "paragraph",
                "content": "Si llamamos a esa tabla <em>n</em>, podemos calcular <em>ϕ</em> utilizando la siguiente fórmula:"
              }
            ]
          },
          {
            "id": "ch04-l7-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "(Si en este punto estás dejando el libro para concentrarte en un terrible flashback a la clase de matemáticas de décimo grado, ¡espera! No pretendo torturarte con interminables páginas de notación críptica, solo es esta fórmula por ahora. E incluso con esta, todo lo que haremos es convertirla en JavaScript)."
              },
              {
                "type": "paragraph",
                "content": "La notación <em>n</em><sub>01</sub> indica la cantidad de mediciones donde la primera variable (ardilla) es falsa (0) y la segunda variable (pizza) es verdadera (1). En la tabla de pizza, <em>n</em><sub>01</sub> es 9.El valor <em>n</em><sub>1•</sub> se refiere a la suma de todas las mediciones donde la primera variable es verdadera, que es 5 en el ejemplo de la tabla. De manera similar, <em>n</em><sub>•0</sub> se refiere a la suma de las mediciones donde la segunda variable es falsa."
              },
              {
                "type": "paragraph",
                "content": "Entonces para la tabla de pizza, la parte encima de la línea de división (el dividendo) sería 1×76−4×9 = 40, y la parte debajo de ella (el divisor) sería la raíz cuadrada de 5×85×10×80, o √340,000. Esto da un valor de <em>ϕ</em> ≈ 0.069, que es muy pequeño. Comer pizza no parece tener influencia en las transformaciones."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch04-l8",
        "title": "Calculando la correlación",
        "sections": [
          {
            "id": "ch04-l8-s0",
            "title": "Calculando la correlación",
            "content": [
              {
                "type": "paragraph",
                "content": "Podemos representar una tabla dos por dos en JavaScript con un array de cuatro elementos (<code>[76, 9, 4, 1]</code>). También podríamos usar otras representaciones, como un array que contiene dos arrays de dos elementos cada uno (<code>[[76, 9], [4, 1]]</code>) o un objeto con nombres de propiedades como <code>\"11\"</code> y <code>\"01\"</code>, pero el array plano es simple y hace que las expresiones que acceden a la tabla sean agradabemente cortas. Interpretaremos los índices del array como números binarios de dos bits, donde el dígito más a la izquierda (más significativo) se refiere a la variable ardilla y el dígito más a la derecha (menos significativo) se refiere a la variable de evento. Por ejemplo, el número binario <code>10</code> se refiere al caso donde Jacques se transformó en ardilla, pero el evento (digamos, “pizza”) no ocurrió. Esto sucedió cuatro veces. Y como <code>10</code> en binario es 2 en notación decimal, almacenaremos este número en el índice 2 del array."
              },
              {
                "type": "paragraph",
                "content": "Esta es la función que calcula el coeficiente <em>ϕ</em> a partir de dicho array:"
              },
              {
                "type": "paragraph",
                "content": "Esta es una traducción directa de la fórmula de <em>ϕ</em> a JavaScript. <code>Math.sqrt</code> es la función de raíz cuadrada, como se provee en el objeto <code>Math</code> en un entorno estándar de JavaScript. Debemos agregar dos campos de la tabla para obtener campos como n<sub>1•</sub> porque las sumas de filas o columnas no se almacenan directamente en nuestra estructura de datos."
              }
            ]
          },
          {
            "id": "ch04-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Jacques mantiene su diario por tres meses. El conjunto de datos resultante está disponible en el sandbox de código para este capítulo, donde se almacena en el vínculo <code>JOURNAL</code>, y en un archivo descargable aquí."
              },
              {
                "type": "paragraph",
                "content": "Para extraer una tabla dos por dos para un evento específico del diario, debemos recorrer todas las entradas y contar cuántas veces ocurre el evento en relación con las transformaciones a ardilla:"
              },
              {
                "type": "paragraph",
                "content": "Los arrays tienen un método <code>includes</code> que comprueba si un valor dado existe en el array. La función utiliza esto para determinar si el nombre del evento en el que está interesado forma parte de la lista de eventos de un día dado."
              }
            ]
          },
          {
            "id": "ch04-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El cuerpo del bucle en <code>tableFor</code> determina en qué caja de la tabla cae cada entrada del diario, verificando si la entrada contiene el evento específico en el que está interesado y si el evento ocurre junto con un incidente de ardilla. Luego, el bucle suma uno a la caja correcta de la tabla."
              },
              {
                "type": "paragraph",
                "content": "Ahora tenemos las herramientas necesarias para calcular correlaciones individuales. El único paso restante es encontrar una correlación para cada tipo de evento que se registró y ver si algo destaca."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch04-l9",
        "title": "Bucles de Array",
        "sections": [
          {
            "id": "ch04-l9-s0",
            "title": "Bucles de Array",
            "content": [
              {
                "type": "paragraph",
                "content": "En la función <code>tableFor</code>, hay un bucle como este:"
              },
              {
                "type": "paragraph",
                "content": "Este tipo de bucle es común en el JavaScript clásico; recorrer arrays elemento por elemento es algo que se hace con frecuencia, y para hacerlo se recorre un contador sobre la longitud del array y se selecciona cada elemento por turno."
              },
              {
                "type": "paragraph",
                "content": "Hay una forma más sencilla de escribir tales bucles en JavaScript moderno:"
              }
            ]
          },
          {
            "id": "ch04-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando un bucle <code>for</code> usa la palabra <code>of</code> después de la definición de su variable, recorrerá los elementos del valor dado después de <code>of</code>. Esto no solo funciona para arrays, sino también para cadenas y algunas otras estructuras de datos. Discutiremos <em>cómo</em> funciona en el Capítulo 6."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l10",
        "title": "El análisis final",
        "sections": [
          {
            "id": "ch04-l10-s0",
            "title": "El análisis final",
            "content": [
              {
                "type": "paragraph",
                "content": "Necesitamos calcular una correlación para cada tipo de evento que ocurre en el conjunto de datos. Para hacerlo, primero necesitamos <em>encontrar</em> cada tipo de evento."
              },
              {
                "type": "paragraph",
                "content": "Agregando los nombres de cualquier evento que no estén en él al array <code>events</code>, la función recopila todos los tipos de eventos."
              },
              {
                "type": "paragraph",
                "content": "Usando esa función, podemos ver todas las correlaciones:"
              }
            ]
          },
          {
            "id": "ch04-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría de las correlaciones parecen estar cerca de cero. Comer zanahorias, pan o pudín aparentemente no desencadena la licantropía de las ardillas. Las transformaciones parecen ocurrir un poco más a menudo los fines de semana. Filtraremos los resultados para mostrar solo correlaciones mayores que 0.1 o menores que -0.1:"
              },
              {
                "type": "paragraph",
                "content": "¡Ajá! Hay dos factores con una correlación claramente más fuerte que los demás. Comer cacahuetes tiene un fuerte efecto positivo en la posibilidad de convertirse en una ardilla, mientras que cepillarse los dientes tiene un efecto negativo significativo."
              },
              {
                "type": "paragraph",
                "content": "Interesante. Intentemos algo:"
              }
            ]
          },
          {
            "id": "ch04-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ese es un resultado sólido. El fenómeno ocurre precisamente cuando Jacques come cacahuetes y no se cepilla los dientes. Si tan solo no fuera tan descuidado con la higiene dental, ni siquiera se habría dado cuenta de su aflicción."
              },
              {
                "type": "paragraph",
                "content": "Sabiendo esto, Jacques deja de comer cacahuetes por completo y descubre que sus transformaciones se detienen."
              },
              {
                "type": "paragraph",
                "content": "Pero solo pasan unos pocos meses antes de que se dé cuenta de que algo falta en esta forma de vivir completamente humana. Sin sus aventuras salvajes, Jacques apenas se siente vivo. Decide que prefiere ser un animal salvaje a tiempo completo. Después de construir una hermosa casita en un árbol en el bosque y equiparla con un dispensador de mantequilla de cacahuate y un suministro de diez años de mantequilla de cacahuate, cambia de forma por última vez y vive la corta y enérgica vida de una ardilla."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch04-l11",
        "title": "Más arreología",
        "sections": [
          {
            "id": "ch04-l11-s0",
            "title": "Más arreología",
            "content": [
              {
                "type": "paragraph",
                "content": "Antes de terminar el capítulo, quiero presentarte algunos conceptos más relacionados con objetos. Comenzaré presentando algunos métodos de array generalmente útiles."
              },
              {
                "type": "paragraph",
                "content": "Vimos <code>push</code> y <code>pop</code>, que agregan y eliminan elementos al final de un array, anteriormente en este capítulo. Los métodos correspondientes para agregar y eliminar cosas al principio de un array se llaman <code>unshift</code> y <code>shift</code>."
              },
              {
                "type": "paragraph",
                "content": "Este programa gestiona una cola de tareas. Agregas tareas al final de la cola llamando a <code>recordar(\"comestibles\")</code>, y cuando estás listo para hacer algo, llamas a <code>obtenerTarea()</code> para obtener (y eliminar) el primer elemento de la cola. La función <code>recordarUrgente</code> también agrega una tarea pero la agrega al principio en lugar de al final de la cola."
              }
            ]
          },
          {
            "id": "ch04-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para buscar un valor específico, los arrays proporcionan un método <code>indexOf</code>. Este método busca a través del array desde el principio hasta el final y devuelve el índice en el que se encontró el valor solicitado, o -1 si no se encontró. Para buscar desde el final en lugar de desde el principio, existe un método similar llamado <code>lastIndexOf</code>:"
              },
              {
                "type": "paragraph",
                "content": "Tanto <code>indexOf</code> como <code>lastIndexOf</code> admiten un segundo argumento opcional que indica dónde comenzar la búsqueda."
              },
              {
                "type": "paragraph",
                "content": "Otro método fundamental de los arrays es <code>slice</code>, que toma índices de inicio y fin y devuelve un array que solo contiene los elementos entre ellos. El índice de inicio es inclusivo, mientras que el índice de fin es exclusivo."
              }
            ]
          },
          {
            "id": "ch04-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando no se proporciona el índice de fin, <code>slice</code> tomará todos los elementos después del índice de inicio. También puedes omitir el índice de inicio para copiar todo el array."
              },
              {
                "type": "paragraph",
                "content": "El método <code>concat</code> se puede usar para concatenar arrays y crear un nuevo array, similar a lo que el operador <code>+</code> hace para las strings."
              },
              {
                "type": "paragraph",
                "content": "El siguiente ejemplo muestra tanto <code>concat</code> como <code>slice</code> en acción. Toma un array y un índice y devuelve un nuevo array que es una copia del array original con el elemento en el índice dado eliminado:"
              }
            ]
          },
          {
            "id": "ch04-l11-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si le pasas a <code>concat</code> un argumento que no es un array, ese valor se agregará al nuevo array como si fuera un array de un solo elemento."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch04-l12",
        "title": "Strings y sus propiedades",
        "sections": [
          {
            "id": "ch04-l12-s0",
            "title": "Strings y sus propiedades",
            "content": [
              {
                "type": "paragraph",
                "content": "Podemos acceder a propiedades como <code>length</code> y <code>toUpperCase</code> en valores de tipo string. Pero si intentamos añadir una nueva propiedad, esta no se conserva."
              },
              {
                "type": "paragraph",
                "content": "Los valores de tipo string, number y Boolean no son objetos, y aunque el lenguaje no se queja si intentas establecer nuevas propiedades en ellos, en realidad no almacena esas propiedades. Como se mencionó anteriormente, dichos valores son inmutables y no pueden ser modificados."
              },
              {
                "type": "paragraph",
                "content": "Pero estos tipos tienen propiedades integradas. Cada valor string tiene varios métodos. Algunos muy útiles son <code>slice</code> e <code>indexOf</code>, que se parecen a los métodos de arrays del mismo nombre:"
              }
            ]
          },
          {
            "id": "ch04-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una diferencia es que el <code>indexOf</code> de un string puede buscar un string que contenga más de un carácter, mientras que el método correspondiente de arrays busca solo un elemento:"
              },
              {
                "type": "paragraph",
                "content": "El método <code>trim</code> elimina los espacios en blanco (espacios, saltos de línea, tabulaciones y caracteres similares) del principio y final de una cadena:"
              },
              {
                "type": "paragraph",
                "content": "La función <code>zeroPad</code> del capítulo anterior también existe como un método. Se llama <code>padStart</code> y recibe la longitud deseada y el carácter de relleno como argumentos:"
              }
            ]
          },
          {
            "id": "ch04-l12-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes dividir una cadena en cada ocurrencia de otra cadena con <code>split</code> y unirla nuevamente con <code>join</code>:"
              },
              {
                "type": "paragraph",
                "content": "Una cadena puede repetirse con el método <code>repeat</code>, que crea una nueva cadena que contiene múltiples copias de la cadena original, pegadas juntas:"
              },
              {
                "type": "paragraph",
                "content": "Ya hemos visto la propiedad <code>length</code> del tipo string. Acceder a los caracteres individuales en una cadena se parece a acceder a los elementos de un array (con una complicación que discutiremos en el Capítulo 5)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch04-l13",
        "title": "Parámetros restantes",
        "sections": [
          {
            "id": "ch04-l13-s0",
            "title": "Parámetros restantes",
            "content": [
              {
                "type": "paragraph",
                "content": "Puede ser útil para una función aceptar cualquier cantidad de argumento). Por ejemplo, <code>Math.max</code> calcula el máximo de <em>todos</em> los argumentos que se le pasan. Para escribir una función así, colocas tres puntos antes del último parámetro de la función, de esta manera:"
              },
              {
                "type": "paragraph",
                "content": "Cuando se llama a una función así, el <em>parámetro restante</em> se vincula a un array que contiene todos los argumentos restantes. Si hay otros parámetros antes de él, sus valores no forman parte de ese array. Cuando, como en <code>max</code>, es el único parámetro, contendrá todos los argumentos."
              },
              {
                "type": "paragraph",
                "content": "Puedes usar una notación similar de tres puntos para <em>llamar</em> a una función con un array de argumentos:"
              }
            ]
          },
          {
            "id": "ch04-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto “expande” el array en la llamada de la función, pasando sus elementos como argumentos separados. Es posible incluir un array de esa manera junto con otros argumentos, como en <code>max(9, .<wbr>.<wbr>.<wbr>numbers, 2)</code>."
              },
              {
                "type": "paragraph",
                "content": "La notación de array entre corchetes cuadrados permite al operador de triple punto expandir otro array en el nuevo array:"
              },
              {
                "type": "paragraph",
                "content": "Esto funciona incluso en objetos con llaves, donde agrega todas las propiedades de otro objeto. Si una propiedad se agrega varias veces, el último valor añadido es el que se conserva:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l14",
        "title": "El objeto Math",
        "sections": [
          {
            "id": "ch04-l14-s0",
            "title": "El objeto Math",
            "content": [
              {
                "type": "paragraph",
                "content": "Como hemos visto, <code>Math</code> es una bolsa de funciones de utilidad relacionadas con números, tales como <code>Math.max</code> (máximo), <code>Math.min</code> (mínimo) y <code>Math.sqrt</code> (raíz cuadrada)."
              },
              {
                "type": "paragraph",
                "content": "El objeto <code>Math</code> se utiliza como un contenedor para agrupar un conjunto de funcionalidades relacionadas. Solo hay un objeto <code>Math</code> y casi nunca es útil como un valor. Más bien, proporciona un <em>espacio de nombres</em> para que todas estas funciones y valores no tengan que ser enlaces globales."
              },
              {
                "type": "paragraph",
                "content": "Tener demasiados enlaces globales “contamina” el espacio de nombres. Cuantos más nombres se hayan tomado, más probable es que sobrescribas accidentalmente el valor de algún enlace existente. Por ejemplo, es probable que quieras nombrar algo <code>max</code> en uno de tus programas. Dado que la función <code>max</code> integrada de JavaScript está protegida de forma segura dentro del objeto <code>Math</code>, no tienes que preocuparte por sobrescribirla."
              }
            ]
          },
          {
            "id": "ch04-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos lenguajes te detendrán, o al menos te advertirán, cuando estés definiendo un enlace con un nombre que ya está tomado. JavaScript hace esto para enlaces que declaraste con <code>let</code> o <code>const</code>, pero —perversamente— no para enlaces estándar ni para enlaces declarados con <code>var</code> o <code>function</code>."
              },
              {
                "type": "paragraph",
                "content": "Volviendo al objeto <code>Math</code>. Si necesitas hacer trigonometría, <code>Math</code> puede ayudarte. Contiene <code>cos</code> (coseno), <code>sin</code> (seno) y <code>tan</code> (tangente), así como sus funciones inversas, <code>acos</code>, <code>asin</code> y <code>atan</code>, respectivamente. El número π (pi) —o al menos la aproximación más cercana que cabe en un número de JavaScript— está disponible como <code>Math.PI</code>. Existe una antigua tradición de programación que consiste en escribir los nombres de valores constantes en mayúsculas:"
              },
              {
                "type": "paragraph",
                "content": "Si no estás familiarizado con senos y cosenos, no te preocupes. Los explicaré cuando se utilicen en este libro, en el Capítulo 14."
              }
            ]
          },
          {
            "id": "ch04-l14-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El ejemplo anterior utilizó <code>Math.random</code>. Esta es una función que devuelve un nuevo número pseudoaleatorio entre cero (inclusive) y uno (exclusivo) cada vez que la llamas:"
              },
              {
                "type": "paragraph",
                "content": "Aunque las computadoras son máquinas deterministas —siempre reaccionan de la misma manera si se les da la misma entrada— es posible hacer que produzcan números que parezcan aleatorios. Para lograrlo, la máquina mantiene algún valor oculto y, cada vez que solicitas un nuevo número aleatorio, realiza cálculos complicados en este valor oculto para crear un valor nuevo. Almacena un nuevo valor y devuelve algún número derivado de este. De esta manera, puede producir números nuevos y difíciles de predecir que se <em>aparentan</em> aleatorios."
              },
              {
                "type": "paragraph",
                "content": "Si queremos un número entero aleatorio en lugar de uno fraccionario, podemos usar <code>Math.floor</code> (que redondea hacia abajo al número entero más cercano) en el resultado de <code>Math.random</code>:"
              }
            ]
          },
          {
            "id": "ch04-l14-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al multiplicar el número aleatorio por 10, obtenemos un número mayor o igual a 0 y menor que 10. Dado que <code>Math.floor</code> redondea hacia abajo, esta expresión producirá, con igual probabilidad, cualquier número del 0 al 9."
              },
              {
                "type": "paragraph",
                "content": "También existen las funciones <code>Math.ceil</code> (para “techo”, que redondea hacia arriba al número entero más cercano), <code>Math.round</code> (al número entero más cercano) y <code>Math.abs</code>, que toma el valor absoluto de un número, es decir, niega los valores negativos pero deja los positivos tal como están."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch04-l15",
        "title": "Desestructuración",
        "sections": [
          {
            "id": "ch04-l15-s0",
            "title": "Desestructuración",
            "content": [
              {
                "type": "paragraph",
                "content": "Volviendo por un momento a la función <code>phi</code>."
              },
              {
                "type": "paragraph",
                "content": "Una razón por la que esta función es difícil de leer es que tenemos una asignación apuntando a nuestro array, pero preferiríamos tener asignaciones para los <em>elementos</em> del array, es decir, <code>let n00 = table[0]</code> y así sucesivamente. Afortunadamente, hay una forma concisa de hacer esto en JavaScript:"
              },
              {
                "type": "paragraph",
                "content": "Esto también funciona para asignaciones creadas con <code>let</code>, <code>var</code> o <code>const</code>. Si sabes que el valor que estás asignando es un array, puedes usar corchetes para “mirar dentro” del valor y asignar sus contenidos."
              }
            ]
          },
          {
            "id": "ch04-l15-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un truco similar funciona para objetos, usando llaves en lugar de corchetes:"
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que si intentas desestructurar <code>null</code> o <code>undefined</code>, obtendrás un error, igual que si intentaras acceder directamente a una propiedad de esos valores."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l16",
        "title": "Acceso opcional a propiedades",
        "sections": [
          {
            "id": "ch04-l16-s0",
            "title": "Acceso opcional a propiedades",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando no estás seguro de si un valor dado produce un objeto pero aún deseas leer una propiedad de él cuando lo hace, puedes usar una variante de la notación de punto: <code>objeto?.<wbr>propiedad</code>."
              },
              {
                "type": "paragraph",
                "content": "La expresión <code>a?.b</code> significa lo mismo que <code>a.b</code> cuando <code>a</code> no es nulo o indefinido. Cuando lo es, se evalúa como indefinido. Esto puede ser conveniente cuando, como en el ejemplo, no estás seguro de si una propiedad dada existe o cuando una variable podría contener un valor indefinido."
              },
              {
                "type": "paragraph",
                "content": "Una notación similar se puede utilizar con el acceso a corchetes cuadrados, e incluso con llamadas de funciones, colocando <code>?.</code> delante de los paréntesis o corchetes:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch04-l17",
        "title": "JSON",
        "sections": [
          {
            "id": "ch04-l17-s0",
            "title": "JSON",
            "content": [
              {
                "type": "paragraph",
                "content": "Debido a que las propiedades capturan su valor en lugar de contenerlo, los objetos y arrays se almacenan en la memoria de la computadora como secuencias de bits que contienen las <em>direcciones</em>—el lugar en la memoria—de sus contenidos. Un array con otro array dentro de él consiste en (al menos) una región de memoria para el array interno y otra para el array externo, que contiene (entre otras cosas) un número que representa la dirección del array interno."
              },
              {
                "type": "paragraph",
                "content": "Si deseas guardar datos en un archivo para más tarde o enviarlos a otra computadora a través de la red, debes convertir de alguna manera estas marañas de direcciones de memoria en una descripción que se pueda almacenar o enviar. Podrías enviar toda la memoria de tu computadora junto con la dirección del valor que te interesa, supongo, pero eso no parece ser el mejor enfoque."
              },
              {
                "type": "paragraph",
                "content": "Lo que podemos hacer es <em>serializar</em> los datos. Eso significa que se convierten en una descripción plana. Un formato de serialización popular se llama <em>JSON</em> (pronunciado “Jason”), que significa JavaScript Object Notacion. Se utiliza ampliamente como formato de almacenamiento y comunicación de datos en la Web, incluso en lenguajes que no son JavaScript."
              }
            ]
          },
          {
            "id": "ch04-l17-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "JSON se parece al formato de escritura de arrays y objetos de JavaScript, con algunas restricciones. Todos los nombres de propiedades deben estar rodeados de comillas dobles y solo se permiten expresiones de datos simples—no llamadas a funciones, enlaces, o cualquier cosa que implique cálculos reales. Los comentarios no están permitidos en JSON."
              },
              {
                "type": "paragraph",
                "content": "Una entrada de diario podría verse así cuando se representa como datos JSON:"
              },
              {
                "type": "paragraph",
                "content": "JavaScript nos proporciona las funciones <code>JSON.stringify</code> y <code>JSON.parse</code> para convertir datos a este formato y desde este formato. La primera toma un valor de JavaScript y devuelve una cadena codificada en JSON. La segunda toma dicha cadena y la convierte en el valor que codifica:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l18",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch04-l18-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos y arrays proporcionan formas de agrupar varios valores en un único valor. Esto nos permite poner un montón de cosas relacionadas en una bolsa y correr con la bolsa en lugar de envolver nuestros brazos alrededor de cada una de las cosas individuales e intentar sostenerlas por separado."
              },
              {
                "type": "paragraph",
                "content": "La mayoría de los valores en JavaScript tienen propiedades, con las excepciones de <code>null</code> y <code>undefined</code>. Las propiedades se acceden usando <code>valor.prop</code> o <code>valor[\"prop\"]</code>. Los objetos tienden a usar nombres para sus propiedades y almacenan más o menos un conjunto fijo de ellas. Los arrays, por otro lado, suelen contener cantidades variables de valores conceptualmente idénticos y usan números (comenzando desde 0) como los nombres de sus propiedades."
              },
              {
                "type": "paragraph",
                "content": "Sí <em>hay</em> algunas propiedades nombradas en arrays, como <code>length</code> y varios métodos. Los métodos son funciones que viven en propiedades y (usualmente) actúan sobre el valor del cual son una propiedad."
              }
            ]
          },
          {
            "id": "ch04-l18-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes iterar sobre arrays usando un tipo especial de bucle <code>for</code>: <code>for (let elemento of array)</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch04-l19",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch04-l19-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "La introducción de este libro insinuó lo siguiente como una forma agradable de calcular la suma de un rango de números:"
              },
              {
                "type": "paragraph",
                "content": "Escribe una función <code>range</code> que tome dos argumentos, <code>inicio</code> y <code>fin</code>, y devuelva un array que contenga todos los números desde <code>inicio</code> hasta <code>fin</code>, incluyendo <code>fin</code>."
              },
              {
                "type": "paragraph",
                "content": "Luego, escribe una función <code>sum</code> que tome un array de números y devuelva la suma de estos números. Ejecuta el programa de ejemplo y verifica si realmente devuelve 55."
              }
            ]
          },
          {
            "id": "ch04-l19-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Como asignación adicional, modifica tu función <code>range</code> para que tome un tercer argumento opcional que indique el valor de “paso” utilizado al construir el array. Si no se proporciona un paso, los elementos deberían aumentar en incrementos de uno, correspondiendo al comportamiento anterior. La llamada a la función <code>range(1, 10, 2)</code> debería devolver <code>[1, 3, 5, 7, 9]</code>. Asegúrate de que esto también funcione con valores de paso negativos, de modo que <code>range(5, 2, -1)</code> produzca <code>[5, 4, 3, 2]</code>."
              },
              {
                "type": "paragraph",
                "content": "La construcción de un array se hace más fácilmente inicializando primero un enlace a <code>[]</code> (un array vacío nuevo) y llamando repetidamente a su método <code>push</code> para agregar un valor. No olvides devolver el array al final de la función."
              },
              {
                "type": "paragraph",
                "content": "Dado que el límite final es inclusivo, necesitarás usar el operador <code>&lt;=</code> en lugar de <code>&lt;</code> para verificar el final de tu bucle."
              }
            ]
          },
          {
            "id": "ch04-l19-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El parámetro de paso puede ser un parámetro opcional que por defecto (usando el operador <code>=</code>) es 1."
              },
              {
                "type": "paragraph",
                "content": "Hacer que <code>range</code> comprenda valores negativos de paso probablemente sea mejor haciendo escribiendo dos bucles separados: uno para contar hacia arriba y otro para contar hacia abajo, porque la comparación que verifica si el bucle ha terminado necesita ser <code>&gt;=</code> en lugar de <code>&lt;=</code> al contar hacia abajo."
              },
              {
                "type": "paragraph",
                "content": "También puede valer la pena usar un paso predeterminado diferente, es decir, -1, cuando el final del rango es menor que el principio. De esa manera, <code>range(5, 2)</code> devuelve algo significativo, en lugar de quedarse atascado en un bucle infinito. Es posible hacer referencia a parámetros anteriores en el valor predeterminado de un parámetro."
              }
            ]
          },
          {
            "id": "ch04-l19-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los arrays tienen un método <code>reverse</code> que cambia el array invirtiendo el orden en el que aparecen sus elementos. Para este ejercicio, escribe dos funciones, <code>reverseArray</code> y <code>reverseArrayInPlace</code>. La primera, <code>reverseArray</code>, debería tomar un array como argumento y producir un <em>nuevo</em> array que tenga los mismos elementos en orden inverso. La segunda, <code>reverseArrayInPlace</code>, debería hacer lo que hace el método <code>reverse</code>: <em>modificar</em> el array dado como argumento invirtiendo sus elementos. Ninguna de las funciones puede utilizar el método <code>reverse</code> estándar."
              },
              {
                "type": "paragraph",
                "content": "Recordando las notas sobre efectos secundarios y funciones puras en el capítulo anterior, ¿qué variante esperas que sea útil en más situaciones? ¿Cuál se ejecuta más rápido?"
              },
              {
                "type": "paragraph",
                "content": "Hay dos formas obvias de implementar <code>reverseArray</code>. La primera es simplemente recorrer el array de entrada de principio a fin y usar el método <code>unshift</code> en el nuevo array para insertar cada elemento en su inicio. La segunda es recorrer el array de entrada hacia atrás y utilizar el método <code>push</code>. Iterar sobre un array hacia atrás requiere una especificación de bucle (algo incómoda), como <code>(let i = array.<wbr>length - 1; i &gt;= 0; i--)</code>."
              }
            ]
          },
          {
            "id": "ch04-l19-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Invertir el array en su lugar es más difícil. Debes tener cuidado de no sobrescribir elementos que necesitarás más adelante. Utilizar <code>reverseArray</code> o copiar todo el array de otra manera (usar <code>array.slice()</code> es una buena forma de copiar un array) funciona pero es hacer trampa."
              },
              {
                "type": "paragraph",
                "content": "El truco consiste en <em>intercambiar</em> el primer y último elementos, luego el segundo y el penúltimo, y así sucesivamente. Puedes hacer esto recorriendo la mitad de la longitud del array (utiliza <code>Math.floor</code> para redondear hacia abajo, no necesitas tocar el elemento central en un array con un número impar de elementos) e intercambiando el elemento en la posición <code>i</code> con el que está en la posición <code>array.<wbr>length - 1 - i</code>. Puedes utilizar una asignación local para retener brevemente uno de los elementos, sobrescribirlo con su imagen reflejada, y luego colocar el valor de la asignación local en el lugar donde solía estar la imagen reflejada."
              },
              {
                "type": "paragraph",
                "content": "Como bloques genéricos de valores, los objetos se pueden utilizar para construir todo tipo de estructuras de datos. Una estructura de datos común es la <em>lista</em> (no confundir con arrays). Una lista es un conjunto anidado de objetos, donde el primer objeto contiene una referencia al segundo, el segundo al tercero, y así sucesivamente:"
              }
            ]
          },
          {
            "id": "ch04-l19-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos resultantes forman una cadena, como se muestra en el siguiente diagrama:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Estructuras de datos_ Objetos y Arrays __ Eloquent JavaScript_files/linked-list.svg",
                "alt": "Un diagrama que muestra la estructura de memoria de una lista enlazada. Hay 3 celdas, cada una con un campo de valor que contiene un número y un campo &#39;rest&#39; con una flecha que apunta al resto de la lista. La flecha de la primera celda apunta a la segunda celda, la flecha de la segunda celda apunta a la última celda y el campo &#39;rest&#39; de la última celda contiene nulo."
              },
              {
                "type": "paragraph",
                "content": "Una ventaja de las listas es que pueden compartir partes de su estructura. Por ejemplo, si creo dos nuevos valores <code>{value: 0, rest: list}</code> y <code>{value: -1, rest: list}</code> (siendo <code>list</code> la referencia definida anteriormente), son listas independientes, pero comparten la estructura que conforma sus últimos tres elementos. La lista original también sigue siendo válida como una lista de tres elementos."
              }
            ]
          },
          {
            "id": "ch04-l19-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe una función <code>arrayToList</code> que construya una estructura de lista como la mostrada cuando se le da <code>[1, 2, 3]</code> como argumento. También escribe una función <code>listToArray</code> que produzca un array a partir de una lista. Agrega las funciones auxiliares <code>prepend</code>, que toma un elemento y una lista y crea una nueva lista que añade el elemento al principio de la lista de entrada, y <code>nth</code>, que toma una lista y un número y devuelve el elemento en la posición dada en la lista (siendo cero el primer elemento) o <code>undefined</code> cuando no hay tal elemento."
              },
              {
                "type": "paragraph",
                "content": "Si aún no lo has hecho, escribe también una versión recursiva de <code>nth</code>."
              },
              {
                "type": "paragraph",
                "content": "Construir una lista es más fácil cuando se hace de atrás hacia adelante. Por lo tanto, <code>arrayToList</code> podría iterar sobre el array en reversa (ver ejercicio anterior) y, para cada elemento, agregar un objeto a la lista. Puedes usar un enlace local para mantener la parte de la lista que se ha construido hasta el momento y usar una asignación como <code>lista = {value: X, rest: lista}</code> para añadir un elemento."
              }
            ]
          },
          {
            "id": "ch04-l19-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para recorrer una lista (en <code>listToArray</code> y <code>nth</code>), se puede utilizar una especificación de bucle <code>for</code> de esta forma:"
              },
              {
                "type": "paragraph",
                "content": "¿Puedes ver cómo funciona esto? En cada iteración del bucle, <code>nodo</code> apunta a la sublista actual, y el cuerpo puede leer su propiedad <code>value</code> para obtener el elemento actual. Al final de una iteración, <code>nodo</code> pasa a la siguiente sublista. Cuando eso es nulo, hemos llegado al final de la lista y el bucle ha terminado."
              },
              {
                "type": "paragraph",
                "content": "La versión recursiva de <code>nth</code> mirará de manera similar una parte cada vez más pequeña de la “cola” de la lista y al mismo tiempo contará hacia abajo el índice hasta llegar a cero, momento en el que puede devolver la propiedad <code>value</code> del nodo que está observando. Para obtener el elemento cero de una lista, simplemente tomas la propiedad <code>value</code> de su nodo principal. Para obtener el elemento <em>N</em> + 1, tomas el elemento <em>N</em>-ésimo de la lista que se encuentra en la propiedad <code>rest</code> de esta lista."
              }
            ]
          },
          {
            "id": "ch04-l19-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El operador <code>==</code> compara objetos por identidad, pero a veces preferirías comparar los valores de sus propiedades reales."
              },
              {
                "type": "paragraph",
                "content": "Escribe una función <code>deepEqual</code> que tome dos valores y devuelva true solo si son el mismo valor o son objetos con las mismas propiedades, donde los valores de las propiedades son iguales cuando se comparan con una llamada recursiva a <code>deepEqual</code>."
              },
              {
                "type": "paragraph",
                "content": "Para saber si los valores deben compararse directamente (usando el operador <code>===</code> para eso) o si sus propiedades deben compararse, puedes usar el operador <code>typeof</code>. Si produce <code>\"object\"</code> para ambos valores, deberías hacer una comparación profunda. Pero debes tener en cuenta una excepción tonta: debido a un accidente histórico, <code>typeof null</code> también produce <code>\"object\"</code>."
              }
            ]
          },
          {
            "id": "ch04-l19-s9",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>Object.keys</code> será útil cuando necesites recorrer las propiedades de los objetos para compararlas."
              },
              {
                "type": "paragraph",
                "content": "La prueba para determinar si estás tratando con un objeto real se verá algo así: <code>typeof x == \"object\" &amp;&amp; x != null</code>. Ten cuidado de comparar propiedades solo cuando <em>ambos</em> argumentos sean objetos. En todos los demás casos, simplemente puedes devolver inmediatamente el resultado de aplicar <code>===</code>."
              },
              {
                "type": "paragraph",
                "content": "Utiliza <code>Object.keys</code> para recorrer las propiedades. Necesitas comprobar si ambos objetos tienen el mismo conjunto de nombres de propiedades y si esas propiedades tienen valores idénticos. Una forma de hacerlo es asegurarse de que ambos objetos tengan el mismo número de propiedades (las longitudes de las listas de propiedades son iguales). Y luego, al recorrer las propiedades de uno de los objetos para compararlas, asegúrate siempre primero de que el otro realmente tenga una propiedad con ese nombre. Si tienen el mismo número de propiedades y todas las propiedades en uno también existen en el otro, tienen el mismo conjunto de nombres de propiedades."
              }
            ]
          },
          {
            "id": "ch04-l19-s10",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Devolver el valor correcto de la función se hace mejor devolviendo inmediatamente false cuando se encuentra una diferencia y devolviendo true al final de la función."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 75
      }
    ]
  },
  {
    "id": "ch05",
    "number": 5,
    "title": "Funciones de Orden Superior",
    "titleEs": "Funciones de Orden Superior",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "“Hay dos formas de construir un diseño de software: Una forma es hacerlo tan simple que obviamente no haya deficiencias, y la otra forma es hacerlo ta...",
    "isProject": false,
    "totalXP": 385,
    "lessons": [
      {
        "id": "ch05-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch05-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "paragraph",
                "content": "<em>“Hay dos formas de construir un diseño de software: Una forma es hacerlo tan simple que obviamente no haya deficiencias, y la otra forma es hacerlo tan complicado que no haya deficiencias obvias.”</em>"
              },
              {
                "type": "paragraph",
                "content": "— C.A.R. Hoare, <em>Discurso de Recepción del Premio Turing de la ACM de 1980</em>"
              },
              {
                "type": "paragraph",
                "content": "Un programa grande es un programa costoso, y no solo por el tiempo que lleva construirlo. El tamaño casi siempre implica complejidad, y la complejidad confunde a los programadores. Los programadores confundidos, a su vez, introducen errores (<em>bugs</em>) en los programas. Un programa grande proporciona mucho espacio para que estos errores se escondan, lo que los hace difíciles de encontrar."
              }
            ]
          },
          {
            "id": "ch05-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Volviendo brevemente a los dos ejemplos finales de programas en la introducción. El primero es autocontenido y tiene seis líneas:"
              },
              {
                "type": "paragraph",
                "content": "El segundo depende de dos funciones externas y tiene una línea:"
              },
              {
                "type": "paragraph",
                "content": "¿Cuál es más probable que contenga un error?"
              }
            ]
          },
          {
            "id": "ch05-l0-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si contamos el tamaño de las definiciones de <code>suma</code> y <code>rango</code>, el segundo programa también es grande, incluso más que el primero. Pero, aún así, argumentaría que es más probable que sea correcto."
              },
              {
                "type": "paragraph",
                "content": "Esto se debe a que la solución se expresa en un vocabulary que corresponde al problema que se está resolviendo. Sumar un rango de números no se trata de bucles y contadores. Se trata de rangos y sumas."
              },
              {
                "type": "paragraph",
                "content": "Las definiciones de este vocabulario (las funciones <code>suma</code> y <code>rango</code>) seguirán involucrando bucles, contadores y otros detalles incidentales. Pero debido a que expresan conceptos más simples que el programa en su totalidad, son más fáciles de hacer correctamente."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch05-l1",
        "title": "Abstracción",
        "sections": [
          {
            "id": "ch05-l1-s0",
            "title": "Abstracción",
            "content": [
              {
                "type": "paragraph",
                "content": "En el contexto de la programación, este tipo de vocabularios se suelen llamar <em>abstractions</em>. Las abstracciones nos brindan la capacidad de hablar sobre problemas a un nivel superior (o más abstracto), sin distraernos con detalles no interesantes."
              },
              {
                "type": "paragraph",
                "content": "Como analogía, compara estas dos recetas de sopa de guisantes. La primera es así:"
              },
              {
                "type": "paragraph",
                "content": "_”Pon 1 taza de guisantes secos por persona en un recipiente. Agrega agua hasta que los guisantes estén bien cubiertos. Deja los guisantes en agua durante al menos 12 horas. Saca los guisantes del agua y ponlos en una olla. Agrega 4 tazas de agua por persona. Cubre la olla y deja que los guisantes hiervan a fuego lento durante dos horas. Toma media cebolla por persona. Córtala en trozos con un cuchillo. Agrégala a los guisantes. Toma un tallo de apio por persona. Córtalo en trozos con un cuchillo. Agrégalo a los guisantes. Toma una zanahoria por persona. ¡Córtala en trozos! ¡Con un cuchillo! Agrégala a los guisantes. Cocina durante 10 minutos más.”_Cita:"
              }
            ]
          },
          {
            "id": "ch05-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Y esta es la segunda receta:"
              },
              {
                "type": "paragraph",
                "content": "Por persona: 1 taza de guisantes partidos secos, 4 tazas de agua, media cebolla picada, un tallo de apio y una zanahoria."
              },
              {
                "type": "paragraph",
                "content": "Remoja los guisantes durante 12 horas. Cocina a fuego lento durante 2 horas. Pica y agrega las verduras. Cocina durante 10 minutos más."
              }
            ]
          },
          {
            "id": "ch05-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El segundo es más corto y más fácil de interpretar. Pero necesitas entender algunas palabras más relacionadas con la cocina, como <em>remojar</em>, <em>cocinar a fuego lento</em>, <em>picar</em>, y, supongo, <em>verdura</em>."
              },
              {
                "type": "paragraph",
                "content": "Cuando se programa, no podemos depender de que todas las palabras que necesitamos estén esperándonos en el diccionario. Por lo tanto, podríamos caer en el patrón de la primera receta: trabajar en los pasos precisos que la computadora tiene que realizar, uno por uno, ciegos a los conceptos de más alto nivel que expresan."
              },
              {
                "type": "paragraph",
                "content": "Abstraer la repetición"
              }
            ]
          },
          {
            "id": "ch05-l1-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las funciones simples, como las hemos visto hasta ahora, son una buena manera de construir abstracciones. Pero a veces se quedan cortas."
              },
              {
                "type": "paragraph",
                "content": "Es común que un programa haga algo un número determinado de veces. Puedes escribir un <code>for</code> para eso, así:"
              },
              {
                "type": "paragraph",
                "content": "¿Podemos abstraer “hacer algo <em>N</em> veces” como una función? Bueno, es fácil escribir una función que llame a <code>console.log</code> <em>N</em> veces:"
              }
            ]
          },
          {
            "id": "ch05-l1-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¿Y si queremos hacer algo que no sea solo registrar los números? Dado que “hacer algo” se puede representar como una función y las funciones son solo valores, podemos pasar nuestra acción como un valor de función:"
              },
              {
                "type": "paragraph",
                "content": "No tenemos que pasar una función predefinida a <code>repetir</code>. A menudo, es más fácil crear un valor de función en el momento:"
              },
              {
                "type": "paragraph",
                "content": "Esto está estructurado un poco como un <code>for</code> loop: primero describe el tipo de loop y luego proporciona un cuerpo. Sin embargo, el cuerpo ahora está escrito como un valor de función, que está envuelto entre los paréntesis de la llamada a <code>repetir</code>. Por eso tiene que cerrarse con el corchete de cierre y el paréntesis de cierre. En casos como este ejemplo donde el cuerpo es una sola expresión pequeña, también podrías omitir los corchetes y escribir el bucle en una sola línea."
              }
            ]
          },
          {
            "id": "ch05-l1-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Funciones de orden superior"
              },
              {
                "type": "paragraph",
                "content": "Las funciones que operan en otras funciones, ya sea tomandolas como argumentos o devolviéndolas, se llaman <em>funciones de orden superior</em>. Dado que ya hemos visto que las funciones son valores regulares, no hay nada particularmente notable sobre el hecho de que existan tales funciones. El término proviene de las matemáticas, donde se toma más en serio la distinción entre funciones y otros valores."
              },
              {
                "type": "paragraph",
                "content": "Las funciones de orden superior nos permiten abstraer sobre <em>acciones</em>, no solo sobre valores. Vienen en varias formas. Por ejemplo, podemos tener funciones que crean nuevas funciones:"
              }
            ]
          },
          {
            "id": "ch05-l1-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "También podemos tener funciones que modifican otras funciones:"
              },
              {
                "type": "paragraph",
                "content": "Incluso podemos escribir funciones que proveen nuevos tipos de flujo de control:"
              },
              {
                "type": "paragraph",
                "content": "Existe un método incorporado de arrays, <code>forEach</code>, que proporciona algo similar a un bucle <code>for</code>/<code>of</code> como una función de orden superior:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      },
      {
        "id": "ch05-l2",
        "title": "Conjunto de datos de script",
        "sections": [
          {
            "id": "ch05-l2-s0",
            "title": "Conjunto de datos de script",
            "content": [
              {
                "type": "paragraph",
                "content": "Un área donde las funciones de orden superior destacan es en el procesamiento de datos. Para procesar datos, necesitaremos algunos ejemplos de datos reales. Este capítulo utilizará un conjunto de datos sobre scripts—sistemas de escritura tales como el latín, cirílico o árabe."
              },
              {
                "type": "paragraph",
                "content": "¿Recuerdas Unicode del Capítulo 1, el sistema que asigna un número a cada carácter en lenguaje escrito? La mayoría de estos caracteres están asociados con un script específico. El estándar contiene 140 scripts diferentes, de los cuales 81 aún se utilizan hoy en día y 59 son históricos."
              },
              {
                "type": "paragraph",
                "content": "Aunque solo puedo leer con fluidez caracteres latinos, aprecio el hecho de que las personas estén escribiendo textos en al menos otros 80 sistemas de escritura, muchos de los cuales ni siquiera reconocería. Por ejemplo, aquí tienes una muestra de escritura Tamil:"
              }
            ]
          },
          {
            "id": "ch05-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/Funciones de Orden Superior __ Eloquent JavaScript_files/tamil.png",
                "alt": "Una línea de verso en escritura Tamil. Los caracteres son relativamente simples y separados ordenadamente, pero completamente diferentes de los caracteres latinos."
              },
              {
                "type": "paragraph",
                "content": "El ejemplo del conjunto de datos contiene algunas piezas de información sobre los 140 scripts definidos en Unicode. Está disponible en el sandbox de código para este capítulo como el enlace <code>SCRIPTS</code>. El enlace contiene un array de objetos, cada uno describe un script:"
              },
              {
                "type": "paragraph",
                "content": "Tal objeto nos informa sobre el nombre del script, los rangos Unicode asignados a él, la dirección en la que se escribe, el tiempo de origen (aproximado), si todavía se utiliza, y un enlace a más información. La dirección puede ser <code>\"ltr\"</code> para izquierda a derecha, <code>\"rtl\"</code> para derecha a izquierda (como se escribe el texto en árabe y hebreo) o <code>\"ttb\"</code> para arriba hacia abajo (como en la escritura mongola)."
              }
            ]
          },
          {
            "id": "ch05-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad <code>ranges</code> contiene una matriz de rangos de caracteres Unicode, cada uno de los cuales es una matriz de dos elementos que contiene un límite inferior y un límite superior. Todos los códigos de caracteres dentro de estos rangos se asignan al guion. El límite inferior es inclusivo (el código 994 es un carácter copto) y el límite superior no es inclusivo (el código 1008 no lo es)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch05-l3",
        "title": "Filtrado de arrays",
        "sections": [
          {
            "id": "ch05-l3-s0",
            "title": "Filtrado de arrays",
            "content": [
              {
                "type": "paragraph",
                "content": "Si queremos encontrar los guiones en el conjunto de datos que todavía se utilizan, la siguiente función puede ser útil. Filtra los elementos de una matriz que no pasan una prueba."
              },
              {
                "type": "paragraph",
                "content": "La función utiliza el argumento llamado <code>test</code>, un valor de función, para llenar un “vacío” en la computación, el proceso de decidir qué elementos recopilar."
              },
              {
                "type": "paragraph",
                "content": "Observa cómo la función <code>filter</code>, en lugar de eliminar elementos de la matriz existente, construye una nueva matriz con solo los elementos que pasan la prueba. Esta función es <em>pura</em>. No modifica la matriz que se le pasa."
              }
            ]
          },
          {
            "id": "ch05-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al igual que <code>forEach</code>, <code>filter</code> es un método de matriz estándar. El ejemplo definió la función solo para mostrar qué hace internamente. De ahora en adelante, lo usaremos de esta manera en su lugar:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch05-l4",
        "title": "Transformación con map",
        "sections": [
          {
            "id": "ch05-l4-s0",
            "title": "Transformación con map",
            "content": [
              {
                "type": "paragraph",
                "content": "Digamos que tenemos una matriz de objetos que representan guiones, producida al filtrar la matriz <code>SCRIPTS</code> de alguna manera. Queremos una matriz de nombres en su lugar, que es más fácil de inspeccionar."
              },
              {
                "type": "paragraph",
                "content": "El método <code>map</code> transforma una matriz aplicando una función a todos sus elementos y construyendo una nueva matriz a partir de los valores devueltos. La nueva matriz tendrá la misma longitud que la matriz de entrada, pero su contenido habrá sido <em>mapeado</em> a una nueva forma por la función:"
              },
              {
                "type": "paragraph",
                "content": "Al igual que <code>forEach</code> y <code>filter</code>, <code>map</code> es un método de matriz estándar."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch05-l5",
        "title": "Resumen con reduce",
        "sections": [
          {
            "id": "ch05-l5-s0",
            "title": "Resumen con reduce",
            "content": [
              {
                "type": "paragraph",
                "content": "Otra cosa común que hacer con matrices es calcular un único valor a partir de ellas. Nuestro ejemplo recurrente, sumar una colección de números, es una instancia de esto. Otro ejemplo es encontrar el guion con más caracteres."
              },
              {
                "type": "paragraph",
                "content": "La operación de orden superior que representa este patrón se llama <em>reduce</em> (a veces también llamada <em>fold</em>). Construye un valor tomando repetidamente un único elemento del array y combinándolo con el valor actual. Al sumar números, comenzarías con el número cero y, para cada elemento, lo sumarías al total."
              },
              {
                "type": "paragraph",
                "content": "Los parámetros de <code>reduce</code> son, además del array, una función de combinación y un valor inicial. Esta función es un poco menos directa que <code>filter</code> y <code>map</code>, así que obsérvala detenidamente:"
              }
            ]
          },
          {
            "id": "ch05-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método estándar de arrays <code>reduce</code>, que por supuesto corresponde a esta función, tiene una conveniencia adicional. Si tu array contiene al menos un elemento, puedes omitir el argumento <code>start</code>. El método tomará el primer elemento del array como su valor inicial y comenzará a reducir en el segundo elemento."
              },
              {
                "type": "paragraph",
                "content": "Para usar <code>reduce</code> (dos veces) y encontrar el script con más caracteres, podemos escribir algo así:"
              },
              {
                "type": "paragraph",
                "content": "La función <code>characterCount</code> reduce los rangos asignados a un script sumando sus tamaños. Observa el uso de la desestructuración en la lista de parámetros de la función reductora. La segunda llamada a <code>reduce</code> luego utiliza esto para encontrar el script más grande comparando repetidamente dos scripts y devolviendo el más grande."
              }
            ]
          },
          {
            "id": "ch05-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El script Han tiene más de 89,000 caracteres asignados en el estándar Unicode, convirtiéndolo en el sistema de escritura más grande en el conjunto de datos. Han es un script a veces utilizado para texto en chino, japonés y coreano. Esos idiomas comparten muchos caracteres, aunque tienden a escribirlos de manera diferente. El Consorcio Unicode (con sede en EE. UU.) decidió tratarlos como un único sistema de escritura para ahorrar códigos de caracteres. Esto se llama <em>unificación Han</em> y todavía molesta a algunas personas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch05-l6",
        "title": "Composabilidad",
        "sections": [
          {
            "id": "ch05-l6-s0",
            "title": "Composabilidad",
            "content": [
              {
                "type": "paragraph",
                "content": "Considera cómo hubiéramos escrito el ejemplo anterior (encontrando el script más grande) sin funciones de orden superior. El código no es mucho peor:"
              },
              {
                "type": "paragraph",
                "content": "Hay algunas variables adicionales y el programa tiene cuatro líneas más, pero sigue siendo muy legible."
              },
              {
                "type": "paragraph",
                "content": "Las abstracciones proporcionadas por estas funciones brillan realmente cuando necesitas <em>componer</em> operaciones. Como ejemplo, escribamos un código que encuentre el año promedio de origen para scripts vivos y muertos en el conjunto de datos:"
              }
            ]
          },
          {
            "id": "ch05-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Como puedes ver, los scripts muertos en Unicode son, en promedio, más antiguos que los vivos. Esta no es una estadística muy significativa o sorprendente. Pero espero que estés de acuerdo en que el código utilizado para calcularlo no es difícil de leer. Puedes verlo como un pipeline: empezamos con todos los scripts, filtramos los vivos (o muertos), tomamos los años de esos scripts, calculamos el promedio y redondeamos el resultado."
              },
              {
                "type": "paragraph",
                "content": "Definitivamente también podrías escribir este cálculo como un único loop grande:"
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, es más difícil ver qué se estaba calculando y cómo. Y debido a que los resultados intermedios no se representan como valores coherentes, sería mucho más trabajo extraer algo como <code>average</code> en una función separada."
              }
            ]
          },
          {
            "id": "ch05-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En términos de lo que realmente está haciendo la computadora, estos dos enfoques también son bastante diferentes. El primero construirá nuevos arrays al ejecutar <code>filter</code> y <code>map</code>, mientras que el segundo calcula solo algunos números, haciendo menos trabajo. Por lo general, puedes permitirte el enfoque legible, pero si estás procesando matrices enormes y haciéndolo muchas veces, el estilo menos abstracto podría valer la pena por la velocidad adicional."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch05-l7",
        "title": "Cadenas y códigos de caracteres",
        "sections": [
          {
            "id": "ch05-l7-s0",
            "title": "Cadenas y códigos de caracteres",
            "content": [
              {
                "type": "paragraph",
                "content": "Un uso interesante de este conjunto de datos sería averiguar qué script está utilizando un fragmento de texto. Vamos a través de un programa que hace esto."
              },
              {
                "type": "paragraph",
                "content": "Recuerda que cada script tiene asociado un array de intervalos de códigos de caracteres. Dado un código de carácter, podríamos usar una función como esta para encontrar el script correspondiente (si lo hay):"
              },
              {
                "type": "paragraph",
                "content": "El método <code>some</code> es otra función de orden superior. Toma una función de prueba y te dice si esa función devuelve true para alguno de los elementos en el array."
              }
            ]
          },
          {
            "id": "ch05-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero, ¿cómo obtenemos los códigos de caracteres en una cadena?"
              },
              {
                "type": "paragraph",
                "content": "En Chapter 1 mencioné que las cadenas de JavaScript están codificadas como una secuencia de números de 16 bits. Estos se llaman <em>unidades de código</em>. Un código de carácter Unicode inicialmente se suponía que cabía dentro de tal unidad (lo que te da un poco más de 65,000 caracteres). Cuando quedó claro que eso no iba a ser suficiente, muchas personas se mostraron reacias a la necesidad de usar más memoria por carácter. Para abordar estas preocupaciones, se inventó UTF-16, el formato también utilizado por las cadenas de JavaScript. Describe la mayoría de los caracteres comunes usando una única unidad de código de 16 bits, pero usa un par de dos unidades de dicho tipo para otros."
              },
              {
                "type": "paragraph",
                "content": "UTF-16 generalmente se considera una mala idea hoy en día. Parece casi diseñado intencionalmente para invitar a errores. Es fácil escribir programas que pretendan que las unidades de código y los caracteres son lo mismo. Y si tu lenguaje no utiliza caracteres de dos unidades, eso parecerá funcionar perfectamente. Pero tan pronto como alguien intente usar dicho programa con algunos caracteres chinos menos comunes, fallará. Afortunadamente, con la llegada de los emoji, todo el mundo ha comenzado a usar caracteres de dos unidades, y la carga de tratar con tales problemas está más equitativamente distribuida."
              }
            ]
          },
          {
            "id": "ch05-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Lamentablemente, las operaciones obvias en las cadenas de JavaScript, como obtener su longitud a través de la propiedad <code>length</code> y acceder a su contenido usando corchetes cuadrados, tratan solo con unidades de código."
              },
              {
                "type": "paragraph",
                "content": "El método <code>charCodeAt</code> de JavaScript te da una unidad de código, no un código de carácter completo. El método <code>codePointAt</code>, añadido más tarde, sí da un carácter Unicode completo, por lo que podríamos usarlo para obtener caracteres de una cadena. Pero el argumento pasado a <code>codePointAt</code> sigue siendo un índice en la secuencia de unidades de código. Para recorrer todos los caracteres en una cadena, aún necesitaríamos abordar la cuestión de si un carácter ocupa una o dos unidades de código."
              },
              {
                "type": "paragraph",
                "content": "En el capítulo anterior, mencioné que un bucle <code>for</code>/<code>of</code> también se puede usar en cadenas. Al igual que <code>codePointAt</code>, este tipo de bucle se introdujo en un momento en que la gente era muy consciente de los problemas con UTF-16. Cuando lo usas para recorrer una cadena, te proporciona caracteres reales, no unidades de código:"
              }
            ]
          },
          {
            "id": "ch05-l7-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si tienes un carácter (que será una cadena de una o dos unidades de código), puedes usar <code>codePointAt(0)</code> para obtener su código."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch05-l8",
        "title": "Reconociendo texto",
        "sections": [
          {
            "id": "ch05-l8-s0",
            "title": "Reconociendo texto",
            "content": [
              {
                "type": "paragraph",
                "content": "Tenemos una función <code>characterScript</code> y una forma de recorrer correctamente los caracteres. El próximo paso es contar los caracteres que pertenecen a cada script. La siguiente abstracción de conteo será útil para eso:"
              },
              {
                "type": "paragraph",
                "content": "La función <code>countBy</code> espera una colección (cualquier cosa por la que podamos iterar con <code>for</code>/<code>of</code>) y una función que calcule un nombre de grupo para un elemento dado. Devuelve una matriz de objetos, cada uno de los cuales nombra un grupo y te dice el número de elementos que se encontraron en ese grupo."
              },
              {
                "type": "paragraph",
                "content": "Utiliza otro método de array, <code>find</code>, que recorre los elementos en el array y devuelve el primero para el cual una función devuelve true. Devuelve <code>undefined</code> cuando no se encuentra dicho elemento."
              }
            ]
          },
          {
            "id": "ch05-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Usando <code>countBy</code>, podemos escribir la función que nos dice qué scripts se utilizan en un fragmento de texto:"
              },
              {
                "type": "paragraph",
                "content": "La función primero cuenta los caracteres por nombre, usando <code>characterScript</code> para asignarles un nombre y retrocediendo a la cadena <code>\"ninguno\"</code> para los caracteres que no forman parte de ningún script. La llamada a <code>filter</code> elimina la entrada de <code>\"ninguno\"</code> del array resultante, ya que no nos interesan esos caracteres."
              },
              {
                "type": "paragraph",
                "content": "Para poder calcular porcentajes, primero necesitamos el número total de caracteres que pertenecen a un script, lo cual podemos calcular con <code>reduce</code>. Si no se encuentran dichos caracteres, la función devuelve una cadena específica. De lo contrario, transforma las entradas de conteo en cadenas legibles con <code>map</code> y luego las combina con <code>join</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch05-l9",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch05-l9-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Poder pasar valores de funciones a otras funciones es un aspecto muy útil de JavaScript. Nos permite escribir funciones que modelan cálculos con “vacíos”. El código que llama a estas funciones puede llenar los vacíos proporcionando valores de funciones."
              },
              {
                "type": "paragraph",
                "content": "Los arrays proporcionan diversos métodos de orden superior útiles. Puedes usar <code>forEach</code> para recorrer los elementos de un array. El método <code>filter</code> devuelve un nuevo array que contiene solo los elementos que pasan la función de predicado. Transformar un array poniendo cada elemento en una función se hace con <code>map</code>. Puedes usar <code>reduce</code> para combinar todos los elementos de un array en un único valor. El método <code>some</code> comprueba si algún elemento coincide con una función de predicado dada, mientras que <code>find</code> encuentra el primer elemento que coincide con un predicado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch05-l10",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch05-l10-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Utiliza el método <code>reduce</code> en combinación con el método <code>concat</code> para “aplanar” un array de arrays en un único array que contenga todos los elementos de los arrays originales."
              },
              {
                "type": "paragraph",
                "content": "Escribe una función de orden superior <code>loop</code> que proporcione algo similar a una declaración <code>for</code> loop. Debería recibir un valor, una función de prueba, una función de actualización y una función de cuerpo. En cada iteración, primero debe ejecutar la función de prueba en el valor actual del bucle y detenerse si devuelve falso. Luego debe llamar a la función de cuerpo, dándole el valor actual, y finalmente llamar a la función de actualización para crear un nuevo valor y empezar de nuevo desde el principio."
              },
              {
                "type": "paragraph",
                "content": "Al definir la función, puedes usar un bucle regular para hacer el bucle real."
              }
            ]
          },
          {
            "id": "ch05-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los arrays también tienen un método <code>every</code> análogo al método <code>some</code>. Este método devuelve <code>true</code> cuando la función dada devuelve <code>true</code> para <em>cada</em> elemento en el array. En cierto modo, <code>some</code> es una versión del operador <code>||</code> que actúa en arrays, y <code>every</code> es como el operador <code>&amp;&amp;</code>."
              },
              {
                "type": "paragraph",
                "content": "Implementa <code>every</code> como una función que recibe un array y una función de predicado como parámetros. Escribe dos versiones, una usando un bucle y otra usando el método <code>some</code>."
              },
              {
                "type": "paragraph",
                "content": "Como el operador <code>&amp;&amp;</code>, el método <code>every</code> puede dejar de evaluar más elementos tan pronto como encuentre uno que no coincida. Por lo tanto, la versión basada en bucle puede salir del bucle—con <code>break</code> o `return—tan pronto como encuentre un elemento para el que la función de predicado devuelva false. Si el bucle se ejecuta hasta el final sin encontrar dicho elemento, sabemos que todos los elementos coincidieron y deberíamos devolver true."
              }
            ]
          },
          {
            "id": "ch05-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para construir <code>every</code> sobre <code>some</code>, podemos aplicar <em>leyes de De Morgan</em>, que establecen que <code>a &amp;&amp; b</code> es igual a <code>!(!a || !b)</code>. Esto se puede generalizar a arrays, donde todos los elementos en el array coinciden si no hay ningún elemento en el array que no coincida."
              },
              {
                "type": "paragraph",
                "content": "Escribe una función que calcule la dirección de escritura dominante en una cadena de texto. Recuerda que cada objeto script tiene una propiedad <code>direction</code> que puede ser <code>\"ltr\"</code> (de izquierda a derecha), <code>\"rtl\"</code> (de derecha a izquierda) o <code>\"ttb\"</code> (de arriba a abajo)."
              },
              {
                "type": "paragraph",
                "content": "Tu solución podría parecerse mucho a la primera mitad del ejemplo de <code>textScripts</code>. De nuevo, debes contar caracteres según un criterio basado en <code>characterScript</code> y luego filtrar la parte del resultado que se refiere a caracteres no interesantes (sin script)."
              }
            ]
          },
          {
            "id": "ch05-l10-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Encontrar la dirección con el recuento de caracteres más alto se puede hacer con <code>reduce</code>. Si no está claro cómo hacerlo, consulta el ejemplo anterior en el capítulo, donde se usó <code>reduce</code> para encontrar el script con más caracteres."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      }
    ]
  },
  {
    "id": "ch06",
    "number": 6,
    "title": "La Vida Secreta de los Objetos",
    "titleEs": "La Vida Secreta de los Objetos",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Un tipo de dato abstracto se realiza escribiendo un tipo especial de programa [...] que define el tipo en términos de las operaciones que se pueden re...",
    "isProject": false,
    "totalXP": 550,
    "lessons": [
      {
        "id": "ch06-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch06-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Un tipo de dato abstracto se realiza escribiendo un tipo especial de programa [...] que define el tipo en términos de las operaciones que se pueden realizar en él. Barbara Liskov, Programando con Tipos de Datos Abstractos"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/La Vida Secreta de los Objetos __ Eloquent JavaScript_files/chapter_picture_6.jpg",
                "alt": "Ilustración de un conejo junto a su prototipo, una representación esquemática de un conejo"
              },
              {
                "type": "paragraph",
                "content": "El Capítulo 4 introdujo los objetos de JavaScript, como contenedores que almacenan otros datos."
              }
            ]
          },
          {
            "id": "ch06-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En la cultura de la programación, tenemos algo llamado <em>programación orientada a objetos</em>, un conjunto de técnicas que utilizan objetos como principio central de la organización de programas. Aunque nadie realmente se pone de acuerdo en su definición precisa, la programación orientada a objetos ha dado forma al diseño de muchos lenguajes de programación, incluido JavaScript. Este capítulo describe la forma en que estas ideas se pueden aplicar en JavaScript."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch06-l1",
        "title": "Tipos de Datos Abstractos",
        "sections": [
          {
            "id": "ch06-l1-s0",
            "title": "Tipos de Datos Abstractos",
            "content": [
              {
                "type": "paragraph",
                "content": "La idea principal en la programación orientada a objetos es utilizar objetos, o más bien <em>tipos</em> de objetos, como la unidad de organización del programa. Configurar un programa como una serie de tipos de objetos estrictamente separados proporciona una forma de pensar en su estructura y, por lo tanto, de imponer algún tipo de disciplina para evitar que todo se entrelace."
              },
              {
                "type": "paragraph",
                "content": "La forma de hacer esto es pensar en objetos de alguna manera similar a como pensarías en una batidora eléctrica u otro electrodoméstico para el consumidor. Hay personas que diseñaron y ensamblaron una batidora, y tienen que realizar un trabajo especializado que requiere ciencia de materiales y comprensión de la electricidad. Cubren todo eso con una carcasa de plástico suave, de modo que las personas que solo quieren mezclar masa para panqueques no tengan que preocuparse por todo eso, solo tienen que entender los pocos botones con los que se puede operar la batidora."
              },
              {
                "type": "paragraph",
                "content": "De manera similar, un tipo de dato abstracto, o clase de objeto, es un subprograma que puede contener un código arbitrariamente complicado, pero expone un conjunto limitado de métodos y propiedades que se supone que las personas que trabajan con él deben usar. Esto permite construir programas grandes a partir de varios tipos de electrodomésticos, limitando el grado en que estas diferentes partes están entrelazadas al requerir que solo interactúen entre sí de formas específicas."
              }
            ]
          },
          {
            "id": "ch06-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si se encuentra un problema en una clase de objeto como esta, a menudo se puede reparar, o incluso reescribir completamente, sin afectar el resto del programa."
              },
              {
                "type": "paragraph",
                "content": "Incluso mejor, puede ser posible utilizar clases de objetos en varios programas diferentes, evitando la necesidad de recrear su funcionalidad desde cero. Puedes pensar en las estructuras de datos integradas de JavaScript, como arrays y strings, como tipos de datos abstractos reutilizables de este tipo."
              },
              {
                "type": "paragraph",
                "content": "Cada tipo de dato abstracto tiene una <em>interfaz</em>, que es la colección de operaciones que el código externo puede realizar en él. Incluso cosas básicas como los números pueden considerarse un tipo de dato abstracto cuya interfaz nos permite sumarlos, multiplicarlos, compararlos, y así sucesivamente. De hecho, la fijación en objetos <em>individuales</em> como la unidad principal de organización en la programación orientada a objetos clásica es un tanto desafortunada, ya que a menudo las piezas de funcionalidad útiles involucran un grupo de diferentes clases de objetos que trabajan estrechamente juntos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch06-l2",
        "title": "Métodos",
        "sections": [
          {
            "id": "ch06-l2-s0",
            "title": "Métodos",
            "content": [
              {
                "type": "paragraph",
                "content": "En JavaScript, los métodos no son más que propiedades que contienen valores de función. Este es un método simple:"
              },
              {
                "type": "paragraph",
                "content": "Típicamente, un método necesita hacer algo con el objeto en el que fue invocado. Cuando una función es llamada como método—buscada como propiedad y llamada inmediatamente, como en <code>objeto.método()</code>—la vinculación llamada <code>this</code> en su cuerpo apunta automáticamente al objeto en el que fue llamada."
              },
              {
                "type": "paragraph",
                "content": "Puedes pensar en <code>this</code> como un parámetro extra que se pasa a la función de una manera diferente a los parámetros regulares. Si deseas proveerlo explícitamente, puedes usar el método <code>call</code> de una función, el cual toma el valor de <code>this</code> como su primer argumento y trata los siguientes argumentos como parámetros normales."
              }
            ]
          },
          {
            "id": "ch06-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dado que cada función tiene su propia vinculación <code>this</code>, cuyo valor depende de la forma en que es llamada, no puedes hacer referencia al <code>this</code> del ámbito envolvente en una función regular definida con la palabra clave <code>function</code>."
              },
              {
                "type": "paragraph",
                "content": "Las funciones flecha son diferentes—no vinculan su propio <code>this</code> pero pueden ver la vinculación <code>this</code> del ámbito que las rodea. Por lo tanto, puedes hacer algo como el siguiente código, el cual hace referencia a <code>this</code> desde dentro de una función local:"
              },
              {
                "type": "paragraph",
                "content": "Una propiedad como <code>find(array)</code> en una expresión de objeto es una forma abreviada de definir un método. Crea una propiedad llamada <code>find</code> y le asigna una función como su valor."
              }
            ]
          },
          {
            "id": "ch06-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si hubiera escrito el argumento de <code>some</code> usando la palabra clave <code>function</code>, este código no funcionaría."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch06-l3",
        "title": "Prototipos",
        "sections": [
          {
            "id": "ch06-l3-s0",
            "title": "Prototipos",
            "content": [
              {
                "type": "paragraph",
                "content": "Entonces, una forma de crear un tipo de conejo abstracto con un método <code>speak</code> sería crear una función de ayuda que tenga un tipo de conejo como parámetro, y devuelva un objeto que contenga eso como su propiedad <code>type</code> y nuestra función <code>speak</code> en su propiedad <code>speak</code>."
              },
              {
                "type": "paragraph",
                "content": "Todos los conejos comparten ese mismo método. Especialmente para tipos con muchos métodos, sería conveniente tener una forma de mantener los métodos de un tipo en un solo lugar, en lugar de añadirlos a cada objeto individualmente."
              },
              {
                "type": "paragraph",
                "content": "En JavaScript, los <em>prototipos</em> son la forma de lograr eso. Los objetos pueden estar enlazados a otros objetos, para obtener mágicamente todas las propiedades que ese otro objeto tiene. Los simples objetos creados con la notación <code>{}</code> están enlazados a un objeto llamado <code>Object.prototype</code>."
              }
            ]
          },
          {
            "id": "ch06-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Parece que acabamos de extraer una propiedad de un objeto vacío. Pero de hecho, <code>toString</code> es un método almacenado en <code>Object.prototype</code>, lo que significa que está disponible en la mayoría de los objetos."
              },
              {
                "type": "paragraph",
                "content": "Cuando a un objeto se le solicita una propiedad que no tiene, se buscará en su prototipo la propiedad. Si éste no la tiene, se buscará en <em>su</em> prototipo, y así sucesivamente hasta llegar a un objeto que no tiene prototipo (<code>Object.prototype</code> es un objeto de este tipo)."
              },
              {
                "type": "paragraph",
                "content": "Como podrás imaginar, <code>Object.<wbr>getPrototypeOf</code> devuelve el prototipo de un objeto."
              }
            ]
          },
          {
            "id": "ch06-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos objetos no tienen directamente <code>Object.prototype</code> como su prototipo, sino que tienen otro objeto que proporciona un conjunto diferente de propiedades predeterminadas. Las funciones se derivan de <code>Function.<wbr>prototype</code>, y los arreglos se derivan de <code>Array.prototype</code>."
              },
              {
                "type": "paragraph",
                "content": "Un objeto prototipo de este tipo tendrá a su vez un prototipo, a menudo <code>Object.prototype</code>, de modo que aún proporciona de forma indirecta métodos como <code>toString</code>."
              },
              {
                "type": "paragraph",
                "content": "Puedes utilizar <code>Object.create</code> para crear un objeto con un prototipo específico."
              }
            ]
          },
          {
            "id": "ch06-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El conejo “proto” actúa como un contenedor para las propiedades que son compartidas por todos los conejos. Un objeto de conejo individual, como el conejo negro, contiene propiedades que se aplican solo a él mismo, en este caso su tipo, y deriva propiedades compartidas de su prototipo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch06-l4",
        "title": "Clases",
        "sections": [
          {
            "id": "ch06-l4-s0",
            "title": "Clases",
            "content": [
              {
                "type": "paragraph",
                "content": "El sistema de prototipos de JavaScript puede interpretarse como una versión algo libre de los tipos de datos abstractos o clases. Una clase define la forma de un tipo de objeto, los métodos y propiedades que tiene. A dicho objeto se le llama una <em>instancia</em> de la clase."
              },
              {
                "type": "paragraph",
                "content": "Los prototipos son útiles para definir propiedades cuyo valor es compartido por todas las instancias de una clase. Las propiedades que difieren por instancia, como la propiedad <code>type</code> de nuestros conejos, deben ser almacenadas directamente en los objetos mismos."
              },
              {
                "type": "paragraph",
                "content": "Así que para crear una instancia de una clase, debes hacer un objeto que se derive del prototipo adecuado, pero <em>también</em> debes asegurarte de que él mismo tenga las propiedades que se supone que deben tener las instancias de esta clase. Esto es lo que hace una función <em>constructor</em>."
              }
            ]
          },
          {
            "id": "ch06-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La notación de class de JavaScript facilita la definición de este tipo de función, junto con un objeto prototype."
              },
              {
                "type": "paragraph",
                "content": "La palabra clave <code>class</code> inicia una declaración de clase, que nos permite definir un constructor y un conjunto de métodos juntos. Se pueden escribir cualquier cantidad de métodos dentro de las llaves de la declaración. Este código tiene el efecto de definir un enlace llamado <code>Rabbit</code>, que contiene una función que ejecuta el código en <code>constructor</code>, y tiene una propiedad <code>prototype</code> que contiene el método <code>speak</code>."
              },
              {
                "type": "paragraph",
                "content": "Esta función no puede ser llamada normalmente. Los constructores, en JavaScript, se llaman colocando la palabra clave <code>new</code> delante de ellos. Al hacerlo, se crea un objeto nuevo con el objeto contenido en la propiedad <code>prototype</code> de la función como prototipo, luego se ejecuta la función con <code>this</code> vinculado al nuevo objeto, y finalmente se devuelve el objeto."
              }
            ]
          },
          {
            "id": "ch06-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "De hecho, la palabra clave <code>class</code> se introdujo solo en la edición de JavaScript de 2015. Cualquier función puede ser utilizada como constructor, y antes de 2015 la forma de definir una clase era escribir una función regular y luego manipular su propiedad <code>prototype</code>."
              },
              {
                "type": "paragraph",
                "content": "Por esta razón, todas las funciones que no sean de flecha comienzan con una propiedad <code>prototype</code> que contiene un objeto vacío."
              },
              {
                "type": "paragraph",
                "content": "Por convención, los nombres de constructores se escriben con mayúscula inicial para que puedan distinguirse fácilmente de otras funciones."
              }
            ]
          },
          {
            "id": "ch06-l4-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Es importante entender la distinción entre la forma en que un prototipo está asociado con un constructor (a través de su <em>propiedad</em> <code>prototype</code>) y la forma en que los objetos <em>tienen</em> un prototipo (que se puede encontrar con <code>Object.<wbr>getPrototypeOf</code>). El prototipo real de un constructor es <code>Function.<wbr>prototype</code> ya que los constructores son funciones. Su <em>propiedad</em> <code>prototype</code> contiene el prototipo utilizado para las instancias creadas a través de él."
              },
              {
                "type": "paragraph",
                "content": "Por lo general, los constructores agregarán algunas propiedades específicas de instancia a <code>this</code>. También es posible declarar propiedades directamente en la declaración de clase. A diferencia de los métodos, dichas propiedades se agregan a los objetos instancia, no al prototipo."
              },
              {
                "type": "paragraph",
                "content": "Al igual que <code>function</code>, <code>class</code> se puede utilizar tanto en declaraciones como en expresiones. Cuando se usa como una expresión, no define un enlace sino que simplemente produce el constructor como un valor. Se te permite omitir el nombre de la clase en una expresión de clase."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch06-l5",
        "title": "Propiedades privadas",
        "sections": [
          {
            "id": "ch06-l5-s0",
            "title": "Propiedades privadas",
            "content": [
              {
                "type": "paragraph",
                "content": "Es común que las clases definan algunas propiedades y métodos para uso interno, que no forman parte de su interfaz. Estas se llaman propiedades <em>privadas</em>, en contraposición a las públicas, que son parte de la interfaz externa del objeto."
              },
              {
                "type": "paragraph",
                "content": "Para declarar un método privado, coloca un signo <code>#</code> delante de su nombre. Estos métodos solo pueden ser llamados desde dentro de la declaración de la <code>class</code> que los define."
              },
              {
                "type": "paragraph",
                "content": "Si intentas llamar a <code>#getSecret</code> desde fuera de la clase, obtendrás un error. Su existencia está completamente oculta dentro de la declaración de la clase."
              }
            ]
          },
          {
            "id": "ch06-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para usar propiedades de instancia privadas, debes declararlas. Las propiedades regulares se pueden crear simplemente asignándoles un valor, pero las propiedades privadas <em>deben</em> declararse en la declaración de la clase para estar disponibles en absoluto."
              },
              {
                "type": "paragraph",
                "content": "Esta clase implementa un dispositivo para obtener un número entero aleatorio por debajo de un número máximo dado. Solo tiene una propiedad pública: <code>getNumber</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch06-l6",
        "title": "Sobrescribiendo propiedades derivadas",
        "sections": [
          {
            "id": "ch06-l6-s0",
            "title": "Sobrescribiendo propiedades derivadas",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando agregas una propiedad a un objeto, ya sea que esté presente en el prototipo o no, la propiedad se agrega al objeto <em>mismo</em>. Si ya existía una propiedad con el mismo nombre en el prototipo, esta propiedad ya no afectará al objeto, ya que ahora está oculta detrás de la propiedad propia del objeto."
              },
              {
                "type": "paragraph",
                "content": "El siguiente diagrama esquematiza la situación después de que se ha ejecutado este código. Los prototipos <code>Rabbit</code> y <code>Object</code> están detrás de <code>killerRabbit</code> como un telón de fondo, donde se pueden buscar propiedades que no se encuentran en el objeto mismo."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/La Vida Secreta de los Objetos __ Eloquent JavaScript_files/rabbits.svg",
                "alt": "Un diagrama que muestra la estructura de objetos de conejos y sus prototipos. Hay un cuadro para la instancia &#39;killerRabbit&#39; (que tiene propiedades de instancia como &#39;tipo&#39;), con sus dos prototipos, &#39;Rabbit.prototype&#39; (que tiene el método &#39;hablar&#39;) y &#39;Object.prototype&#39; (que tiene métodos como &#39;toString&#39;) apilados detrás de él."
              },
              {
                "type": "paragraph",
                "content": "Sobrescribir propiedades que existen en un prototipo puede ser algo útil de hacer. Como muestra el ejemplo de los dientes del conejo, sobrescribir se puede utilizar para expresar propiedades excepcionales en instancias de una clase más genérica de objetos, mientras se permite que los objetos no excepcionales tomen un valor estándar de su prototipo."
              }
            ]
          },
          {
            "id": "ch06-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "También se utiliza la sobrescritura para dar a los prototipos estándar de funciones y arrays un método <code>toString</code> diferente al del prototipo básico de objeto."
              },
              {
                "type": "paragraph",
                "content": "Llamar a <code>toString</code> en un array produce un resultado similar a llamar a <code>.<wbr>join(\",\")</code> en él—coloca comas entre los valores en el array. Llamar directamente a <code>Object.<wbr>prototype.<wbr>toString</code> con un array produce una cadena diferente. Esa función no conoce acerca de los arrays, por lo que simplemente coloca la palabra <em>object</em> y el nombre del tipo entre corchetes."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch06-l7",
        "title": "Mapas",
        "sections": [
          {
            "id": "ch06-l7-s0",
            "title": "Mapas",
            "content": [
              {
                "type": "paragraph",
                "content": "Vimos la palabra <em>map</em> utilizada en el capítulo anterior para una operación que transforma una estructura de datos aplicando una función a sus elementos. Por confuso que sea, en programación la misma palabra también se utiliza para una cosa relacionada pero bastante diferente."
              },
              {
                "type": "paragraph",
                "content": "Un <em>mapa</em> (sustantivo) es una estructura de datos que asocia valores (las claves) con otros valores. Por ejemplo, podrías querer mapear nombres a edades. Es posible usar objetos para esto."
              },
              {
                "type": "paragraph",
                "content": "Aquí, los nombres de propiedad del objeto son los nombres de las personas, y los valores de las propiedades son sus edades. Pero ciertamente no listamos a nadie con el nombre toString en nuestro mapa. Sin embargo, dado que los objetos simples derivan de <code>Object.prototype</code>, parece que la propiedad está allí."
              }
            ]
          },
          {
            "id": "ch06-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por lo tanto, usar objetos simples como mapas es peligroso. Hay varias formas posibles de evitar este problema. Primero, es posible crear objetos sin <em>ningún</em> prototipo. Si pasas <code>null</code> a <code>Object.create</code>, el objeto resultante no derivará de <code>Object.prototype</code> y se puede usar de forma segura como un mapa."
              },
              {
                "type": "paragraph",
                "content": "Los nombres de las propiedades de los objetos deben ser cadenas. Si necesitas un mapa cuyas claves no puedan convertirse fácilmente en cadenas—como objetos—no puedes usar un objeto como tu mapa."
              },
              {
                "type": "paragraph",
                "content": "Afortunadamente, JavaScript viene con una clase llamada <code>Map</code> que está escrita para este propósito exacto. Almacena un mapeo y permite cualquier tipo de claves."
              }
            ]
          },
          {
            "id": "ch06-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los métodos <code>set</code>, <code>get</code> y <code>has</code> forman parte de la interfaz del objeto <code>Map</code>. Escribir una estructura de datos que pueda actualizar y buscar rápidamente un gran conjunto de valores no es fácil, pero no tenemos que preocuparnos por eso. Alguien más lo hizo por nosotros, y podemos utilizar su trabajo a través de esta interfaz sencilla."
              },
              {
                "type": "paragraph",
                "content": "Si tienes un objeto simple que necesitas tratar como un mapa por alguna razón, es útil saber que <code>Object.keys</code> devuelve solo las claves <em>propias</em> de un objeto, no las del prototipo. Como alternativa al operador <code>in</code>, puedes utilizar la función <code>Object.hasOwn</code>, que ignora el prototipo del objeto."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch06-l8",
        "title": "Polimorfismo",
        "sections": [
          {
            "id": "ch06-l8-s0",
            "title": "Polimorfismo",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando llamas a la función <code>String</code> (que convierte un valor a una cadena) en un objeto, llamará al método <code>toString</code> en ese objeto para intentar crear una cadena significativa a partir de él. Mencioné que algunos de los prototipos estándar definen su propia versión de <code>toString</code> para poder crear una cadena que contenga información más útil que <code>\"[object Object]\"</code>. También puedes hacerlo tú mismo."
              },
              {
                "type": "paragraph",
                "content": "Este es un ejemplo simple de una idea poderosa. Cuando se escribe un código para trabajar con objetos que tienen una determinada interfaz, en este caso, un método <code>toString</code>, cualquier tipo de objeto que accidentalmente admita esta interfaz puede ser enchufado en el código, y este podrá funcionar con él."
              },
              {
                "type": "paragraph",
                "content": "Esta técnica se llama <em>polimorfismo</em>. El código polimórfico puede trabajar con valores de diferentes formas, siempre y cuando admitan la interfaz que espera."
              }
            ]
          },
          {
            "id": "ch06-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un ejemplo de una interfaz ampliamente utilizada es la de los objeto similar a un array que tiene una propiedad <code>length</code> que contiene un número, y propiedades numeradas para cada uno de sus elementos. Tanto los arreglos como las cadenas admiten esta interfaz, al igual que varios otros objetos, algunos de los cuales veremos más adelante en los capítulos sobre el navegador. Nuestra implementación de <code>forEach</code> en el Capítulo 5 funciona en cualquier cosa que proporcione esta interfaz. De hecho, también lo hace <code>Array.<wbr>prototype.<wbr>forEach</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch06-l9",
        "title": "Getters, setters y estáticos",
        "sections": [
          {
            "id": "ch06-l9-s0",
            "title": "Getters, setters y estáticos",
            "content": [
              {
                "type": "paragraph",
                "content": "Las interfaces a menudo contienen propiedades simples, no solo métodos. Por ejemplo, los objetos <code>Map</code> tienen una propiedad <code>size</code> que te dice cuántas claves están almacenadas en ellos."
              },
              {
                "type": "paragraph",
                "content": "No es necesario que dicho objeto calcule y almacene directamente esa propiedad en la instancia. Incluso las propiedades que se acceden directamente pueden ocultar una llamada a un método. Dichos métodos se llaman <em>getter</em> y se definen escribiendo <code>get</code> delante del nombre del método en una expresión de objeto o declaración de clase."
              },
              {
                "type": "paragraph",
                "content": "Cada vez que alguien lee la propiedad <code>size</code> de este objeto, se llama al método asociado. Puedes hacer algo similar cuando se escribe en una propiedad, utilizando un <em>setter</em>."
              }
            ]
          },
          {
            "id": "ch06-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La clase <code>Temperature</code> te permite leer y escribir la temperatura en grados Celsius o grados Fahrenheit, pero internamente solo almacena Celsius y convierte automáticamente de y a Celsius en el <em>getter</em> y <em>setter</em> de <code>fahrenheit</code>."
              },
              {
                "type": "paragraph",
                "content": "A veces quieres adjuntar algunas propiedades directamente a tu función constructora, en lugar de al prototipo. Estos métodos no tendrán acceso a una instancia de clase, pero pueden, por ejemplo, usarse para proporcionar formas adicionales de crear instancias."
              },
              {
                "type": "paragraph",
                "content": "Dentro de una declaración de clase, los métodos o propiedades que tienen <code>static</code> escrito antes de su nombre se almacenan en el constructor. Por lo tanto, la clase <code>Temperature</code> te permite escribir <code>Temperature.<wbr>fromFahrenheit(100)</code> para crear una temperatura usando grados Fahrenheit."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch06-l10",
        "title": "Símbolos",
        "sections": [
          {
            "id": "ch06-l10-s0",
            "title": "Símbolos",
            "content": [
              {
                "type": "paragraph",
                "content": "Mencioné en el Capítulo 4 que un bucle <code>for</code>/<code>of</code> puede recorrer varios tipos de estructuras de datos. Este es otro caso de polimorfismo: tales bucles esperan que la estructura de datos exponga una interfaz específica, la cual hacen los arrays y las cadenas. ¡Y también podemos agregar esta interfaz a nuestros propios objetos! Pero antes de hacerlo, debemos echar un vistazo breve al tipo de símbolo."
              },
              {
                "type": "paragraph",
                "content": "Es posible que múltiples interfaces utilicen el mismo nombre de propiedad para diferentes cosas. Por ejemplo, en objetos similares a arrays, <code>length</code> se refiere a la cantidad de elementos en la colección. Pero una interfaz de objeto que describa una ruta de senderismo podría usar <code>length</code> para proporcionar la longitud de la ruta en metros. No sería posible que un objeto cumpla con ambas interfaces."
              },
              {
                "type": "paragraph",
                "content": "Un objeto que intente ser una ruta y similar a un array (quizás para enumerar sus puntos de referencia) es algo un tanto improbable, y este tipo de problema no es tan común en la práctica. Pero para cosas como el protocolo de iteración, los diseñadores del lenguaje necesitaban un tipo de propiedad que <em>realmente</em> no entrara en conflicto con ninguna otra. Por lo tanto, en 2015, se agregaron los <em>símbolos</em> al lenguaje."
              }
            ]
          },
          {
            "id": "ch06-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría de las propiedades, incluidas todas las propiedades que hemos visto hasta ahora, se nombran con cadenas. Pero también es posible usar símbolos como nombres de propiedades. Los símbolos son valores creados con la función <code>Symbol</code>. A diferencia de las cadenas, los símbolos recién creados son únicos: no puedes crear el mismo símbolo dos veces."
              },
              {
                "type": "paragraph",
                "content": "La cadena que pasas a <code>Symbol</code> se incluye cuando la conviertes en una cadena y puede facilitar reconocer un símbolo cuando, por ejemplo, se muestra en la consola. Pero no tiene otro significado más allá de eso: varios símbolos pueden tener el mismo nombre."
              },
              {
                "type": "paragraph",
                "content": "Ser tanto únicos como utilizables como nombres de propiedades hace que los símbolos sean adecuados para definir interfaces que pueden convivir pacíficamente junto a otras propiedades, independientemente de cuáles sean sus nombres."
              }
            ]
          },
          {
            "id": "ch06-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Es posible incluir propiedades de símbolos en expresiones de objetos y clases mediante el uso de corchetes. Esto hace que la expresión entre los corchetes se evalúe para producir el nombre de la propiedad, análogo a la notación de acceso a propiedades mediante corchetes cuadrados."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch06-l11",
        "title": "La interfaz del iterador",
        "sections": [
          {
            "id": "ch06-l11-s0",
            "title": "La interfaz del iterador",
            "content": [
              {
                "type": "paragraph",
                "content": "Se espera que el objeto proporcionado a un bucle <code>for</code>/<code>of</code> sea <em>iterable</em>. Esto significa que tiene un método nombrado con el símbolo <code>Symbol.iterator</code> (un valor de símbolo definido por el lenguaje, almacenado como una propiedad de la función <code>Symbol</code>)."
              },
              {
                "type": "paragraph",
                "content": "Cuando se llama, ese método debería devolver un objeto que proporcione una segunda interfaz, <em>iterador</em>. Este es lo que realmente itera. Tiende un método <code>next</code> que devuelve el próximo resultado. Ese resultado debería ser un objeto con una propiedad <code>value</code> que proporciona el siguiente valor, si lo hay, y una propiedad <code>done</code>, que debería ser <code>true</code> cuando no hay más resultados y <code>false</code> en caso contrario."
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que los nombres de propiedad <code>next</code>, <code>value</code> y <code>done</code> son simples cadenas, no símbolos. Solo <code>Symbol.iterator</code>, que probablemente se agregará a <em>muchos</em> objetos diferentes, es un símbolo real."
              }
            ]
          },
          {
            "id": "ch06-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Podemos usar esta interfaz directamente nosotros mismos."
              },
              {
                "type": "paragraph",
                "content": "Implementemos una estructura de datos iterable similar a la lista enlazada del ejercicio en el Capítulo 4. Esta vez escribiremos la lista como una clase."
              },
              {
                "type": "paragraph",
                "content": "Toma en cuenta que <code>this</code>, en un método estático, apunta al constructor de la clase, no a una instancia, ya que no hay una instancia disponible cuando se llama a un método estático."
              }
            ]
          },
          {
            "id": "ch06-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Iterar sobre una lista debería devolver todos los elementos de la lista desde el principio hasta el final. Escribiremos una clase separada para el iterador."
              },
              {
                "type": "paragraph",
                "content": "La clase realiza un seguimiento del progreso de la iteración a través de la lista actualizando su propiedad <code>list</code> para moverse al siguiente objeto de lista cada vez que se devuelve un valor, y reporta que ha terminado cuando esa lista está vacía (null)."
              },
              {
                "type": "paragraph",
                "content": "Ahora configuraremos la clase <code>List</code> para que sea iterable. A lo largo de este libro, ocasionalmente utilizaré la manipulación de prototipos posterior al hecho para agregar métodos a las clases de modo que las piezas individuales de código se mantengan pequeñas y autónomas. En un programa regular, donde no hay necesidad de dividir el código en piezas pequeñas, declararías estos métodos directamente en la clase en su lugar."
              }
            ]
          },
          {
            "id": "ch06-l11-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora podemos iterar sobre una lista con <code>for</code>/<code>of</code>."
              },
              {
                "type": "paragraph",
                "content": "La sintaxis <code>...</code> en notación de arrays y en llamadas a funciones funciona de forma similar con cualquier objeto iterable. Por ejemplo, puedes usar <code>[...valor]</code> para crear un array que contenga los elementos de un objeto iterable arbitrario."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch06-l12",
        "title": "Herencia",
        "sections": [
          {
            "id": "ch06-l12-s0",
            "title": "Herencia",
            "content": [
              {
                "type": "paragraph",
                "content": "Imaginemos que necesitamos un tipo de lista, bastante parecido a la clase <code>List</code> que vimos anteriormente, pero como siempre estaremos preguntando por su longitud, no queremos tener que recorrer su <code>rest</code> cada vez, en su lugar, queremos almacenar la longitud en cada instancia para un acceso eficiente."
              },
              {
                "type": "paragraph",
                "content": "El sistema de prototipos de JavaScript permite crear una <em>nueva</em> clase, muy similar a la clase antigua, pero con nuevas definiciones para algunas de sus propiedades. El prototipo de la nueva clase se deriva del prototipo antiguo pero agrega una nueva definición, por ejemplo, para el <code>getter</code> de <code>length</code>."
              },
              {
                "type": "paragraph",
                "content": "En términos de programación orientada a objetos, esto se llama <em>herencia</em>. La nueva clase hereda propiedades y comportamientos de la clase antigua."
              }
            ]
          },
          {
            "id": "ch06-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El uso de la palabra <code>extends</code> indica que esta clase no debería basarse directamente en el prototipo predeterminado de <code>Object</code>, sino en alguna otra clase. Esta se llama la <em>superclase</em>. La clase derivada es la <em>subclase</em>."
              },
              {
                "type": "paragraph",
                "content": "Para inicializar una instancia de <code>LengthList</code>, el constructor llama al constructor de su superclase a través de la palabra clave <code>super</code>. Esto es necesario porque si este nuevo objeto se va a comportar (aproximadamente) como una <code>List</code>, va a necesitar las propiedades de instancia que tienen las listas."
              },
              {
                "type": "paragraph",
                "content": "Luego, el constructor almacena la longitud de la lista en una propiedad privada. Si hubiéramos escrito <code>this.longitud</code> ahí, se habría llamado al getter de la propia clase, lo cual no funciona aún, ya que <code>#longitud</code> aún no ha sido completado. Podemos usar <code>super.algo</code> para llamar a métodos y getters en el prototipo de la superclase, lo cual a menudo es útil."
              }
            ]
          },
          {
            "id": "ch06-l12-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La herencia nos permite construir tipos de datos ligeramente diferentes a partir de tipos de datos existentes con relativamente poco trabajo. Es una parte fundamental de la tradición orientada a objetos, junto con la encapsulación y la polimorfismo. Pero, mientras que los dos últimos se consideran generalmente ideas maravillosas, la herencia es más controvertida."
              },
              {
                "type": "paragraph",
                "content": "Mientras que encapsulación y polimorfismo se pueden utilizar para <em>separar</em> las piezas de código unas de otras, reduciendo el enredo del programa en general, herencia fundamentalmente ata clases juntas, creando <em>más</em> enredo. Al heredar de una clase, generalmente tienes que saber más sobre cómo funciona que cuando simplemente la usas. La herencia puede ser una herramienta útil para hacer que algunos tipos de programas sean más concisos, pero no debería ser la primera herramienta a la que recurras, y probablemente no deberías buscar activamente oportunidades para construir jerarquías de clases (árboles genealógicos de clases)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch06-l13",
        "title": "El operador instanceof",
        "sections": [
          {
            "id": "ch06-l13-s0",
            "title": "El operador instanceof",
            "content": [
              {
                "type": "paragraph",
                "content": "A veces es útil saber si un objeto se derivó de una clase específica. Para esto, JavaScript proporciona un operador binario llamado <code>instanceof</code>."
              },
              {
                "type": "paragraph",
                "content": "El operador podrá ver a través de tipos heredados, por lo que un <code>LengthList</code> es una instancia de <code>List</code>. El operador también se puede aplicar a constructores estándar como <code>Array</code>. Casi todo objeto es una instancia de <code>Object</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch06-l14",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch06-l14-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos hacen más que simplemente contener sus propias propiedades. Tienen prototipos, que son otros objetos. Actuarán como si tuvieran propiedades que no tienen siempre y cuando su prototipo tenga esa propiedad. Los objetos simples tienen <code>Object.prototype</code> como su prototipo."
              },
              {
                "type": "paragraph",
                "content": "Los constructores, que son funciones cuyos nombres generalmente comienzan con una letra mayúscula, se pueden usar con el operador <code>new</code> para crear nuevos objetos. El prototipo del nuevo objeto será el objeto encontrado en la propiedad <code>prototype</code> del constructor. Puedes sacar buen provecho de esto poniendo las propiedades que comparten todos los valores de un tipo dado en su prototipo. Existe una notación de <code>class</code> que proporciona una forma clara de definir un constructor y su prototipo."
              },
              {
                "type": "paragraph",
                "content": "Puedes definir getters y setters para llamar secretamente a métodos cada vez que se accede a una propiedad de un objeto. Los métodos estáticos son métodos almacenados en el constructor de una clase, en lugar de en su prototipo."
              }
            ]
          },
          {
            "id": "ch06-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El operador <code>instanceof</code> puede, dado un objeto y un constructor, decirte si ese objeto es una instancia de ese constructor."
              },
              {
                "type": "paragraph",
                "content": "Una cosa útil que se puede hacer con objetos es especificar una interfaz para ellos y decirle a todo el mundo que se supone que deben comunicarse con tu objeto solo a través de esa interfaz. El resto de los detalles que componen tu objeto están ahora <em>encapsulados</em>, escondidos detrás de la interfaz. Puedes usar propiedades privadas para ocultar una parte de tu objeto del mundo exterior."
              },
              {
                "type": "paragraph",
                "content": "Más de un tipo puede implementar la misma interfaz. El código escrito para usar una interfaz automáticamente sabe cómo trabajar con cualquier número de objetos diferentes que proporcionen la interfaz. Esto se llama <em>polimorfismo</em>."
              }
            ]
          },
          {
            "id": "ch06-l14-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se implementan múltiples clases que difieren solo en algunos detalles, puede ser útil escribir las nuevas clases como <em>subclases</em> de una clase existente, <em>heredando</em> parte de su comportamiento."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch06-l15",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch06-l15-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe una clase <code>Vec</code> que represente un vector en el espacio bidimensional. Toma los parámetros <code>x</code> e <code>y</code> (números), que debería guardar en propiedades del mismo nombre."
              },
              {
                "type": "paragraph",
                "content": "Dale a la clase <code>Vec</code> dos métodos en su prototipo, <code>plus</code> y <code>minus</code>, que tomen otro vector como parámetro y devuelvan un nuevo vector que tenga la suma o la diferencia de los valores <em>x</em> e <em>y</em> de los dos vectores (<code>this</code> y el parámetro)."
              },
              {
                "type": "paragraph",
                "content": "Agrega una propiedad getter <code>length</code> al prototipo que calcule la longitud del vector, es decir, la distancia del punto (<em>x</em>, <em>y</em>) desde el origen (0, 0)."
              }
            ]
          },
          {
            "id": "ch06-l15-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Mira de nuevo el ejemplo de la clase <code>Rabbit</code> si no estás seguro de cómo se ven las declaraciones de <code>class</code>."
              },
              {
                "type": "paragraph",
                "content": "Agregar una propiedad getter al constructor se puede hacer poniendo la palabra <code>get</code> antes del nombre del método. Para calcular la distancia desde (0, 0) hasta (x, y), puedes usar el teorema de Pitágoras, que dice que el cuadrado de la distancia que estamos buscando es igual al cuadrado de la coordenada x más el cuadrado de la coordenada y. Por lo tanto, √(x<sup>2</sup> + y<sup>2</sup>) es el número que buscas. <code>Math.sqrt</code> es la forma de calcular una raíz cuadrada en JavaScript y <code>x ** 2</code> se puede usar para elevar al cuadrado un número."
              },
              {
                "type": "paragraph",
                "content": "El entorno estándar de JavaScript proporciona otra estructura de datos llamada <code>Set</code>. Al igual que una instancia de <code>Map</code>, un conjunto contiene una colección de valores. A diferencia de <code>Map</code>, no asocia otros valores con esos, solo realiza un seguimiento de qué valores forman parte del conjunto. Un valor puede formar parte de un conjunto solo una vez: agregarlo nuevamente no tiene ningún efecto."
              }
            ]
          },
          {
            "id": "ch06-l15-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe una clase llamada <code>Group</code> (ya que <code>Set</code> está siendo utilizado). Al igual que <code>Set</code>, tiene los métodos <code>add</code>, <code>delete</code> y <code>has</code>. Su constructor crea un grupo vacío, <code>add</code> agrega un valor al grupo (pero solo si aún no es miembro), <code>delete</code> elimina su argumento del grupo (si era miembro), y <code>has</code> devuelve un valor booleano que indica si su argumento es miembro del grupo."
              },
              {
                "type": "paragraph",
                "content": "Usa el operador <code>===</code>, o algo equivalente como <code>indexOf</code>, para determinar si dos valores son iguales."
              },
              {
                "type": "paragraph",
                "content": "Dale a la clase un método estático <code>from</code> que tome un objeto iterable como argumento y cree un grupo que contenga todos los valores producidos al iterar sobre él."
              }
            ]
          },
          {
            "id": "ch06-l15-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La forma más sencilla de hacer esto es almacenar un array de miembros del grupo en una propiedad de instancia. Los métodos <code>includes</code> o <code>indexOf</code> se pueden usar para verificar si un valor dado está en el array."
              },
              {
                "type": "paragraph",
                "content": "El constructor de tu clase puede establecer la colección de miembros en un array vacío. Cuando se llama a <code>add</code>, debe verificar si el valor dado está en el array o agregarlo, por ejemplo con <code>push</code>, de lo contrario."
              },
              {
                "type": "paragraph",
                "content": "Eliminar un elemento de un array, en <code>delete</code>, es menos directo, pero puedes usar <code>filter</code> para crear un nuevo array sin el valor. No olvides sobrescribir la propiedad que contiene los miembros con la nueva versión filtrada del array."
              }
            ]
          },
          {
            "id": "ch06-l15-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>from</code> puede usar un bucle <code>for</code>/<code>of</code> para obtener los valores del objeto iterable y llamar a <code>add</code> para colocarlos en un grupo recién creado."
              },
              {
                "type": "paragraph",
                "content": "Haz que la clase <code>Group</code> del ejercicio anterior sea iterable. Refiérete a la sección sobre la interfaz del iterador anteriormente en el capítulo si no tienes claro la forma exacta de la interfaz."
              },
              {
                "type": "paragraph",
                "content": "Si utilizaste un array para representar los miembros del grupo, no devuelvas simplemente el iterador creado al llamar al método <code>Symbol.iterator</code> en el array. Eso funcionaría, pero va en contra del propósito de este ejercicio."
              }
            ]
          },
          {
            "id": "ch06-l15-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Está bien si tu iterador se comporta de manera extraña cuando el grupo se modifica durante la iteración."
              },
              {
                "type": "paragraph",
                "content": "Probablemente valga la pena definir una nueva clase <code>GroupIterator</code>. Las instancias del iterador deberían tener una propiedad que rastree la posición actual en el grupo. Cada vez que se llama a <code>next</code>, verifica si ha terminado y, si no, avanza más allá del valor actual y lo devuelve."
              },
              {
                "type": "paragraph",
                "content": "La clase <code>Group</code> en sí misma obtiene un método nombrado <code>Symbol.iterator</code> que, al ser llamado, devuelve una nueva instancia de la clase iteradora para ese grupo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      }
    ]
  },
  {
    "id": "ch07",
    "number": 7,
    "title": "Proyecto: Un Robot",
    "titleEs": "Proyecto: Un Robot",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "[...] la pregunta de si las Máquinas Pueden Pensar [...] es tan relevante como la pregunta de si los Submarinos Pueden Nadar....",
    "isProject": true,
    "totalXP": 300,
    "lessons": [
      {
        "id": "ch07-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch07-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "[...] la pregunta de si las Máquinas Pueden Pensar [...] es tan relevante como la pregunta de si los Submarinos Pueden Nadar. Edsger Dijkstra, Las amenazas a la ciencia informática"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un Robot __ Eloquent JavaScript_files/chapter_picture_7.jpg",
                "alt": "Ilustración de un robot sosteniendo una pila de paquetes"
              },
              {
                "type": "paragraph",
                "content": "En los capítulos del “proyecto”, dejaré de golpearte con nueva teoría por un breve momento, y en su lugar trabajaremos en un programa juntos. La teoría es necesaria para aprender a programar, pero leer y entender programas reales es igual de importante."
              }
            ]
          },
          {
            "id": "ch07-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Nuestro proyecto en este capítulo es construir un autómata, un pequeño programa que realiza una tarea en un mundo virtual. Nuestro autómata será un robot de entrega de correo que recoge y deja paquetes."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch07-l1",
        "title": "Meadowfield",
        "sections": [
          {
            "id": "ch07-l1-s0",
            "title": "Meadowfield",
            "content": [
              {
                "type": "paragraph",
                "content": "El pueblo de Meadowfield no es muy grande. Consiste en 11 lugares con 14 carreteras entre ellos. Se puede describir con este array de carreteras:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un Robot __ Eloquent JavaScript_files/village2x.png",
                "alt": "Ilustración de arte pixelado de un pequeño pueblo con 11 ubicaciones, etiquetadas con letras, y carreteras entre ellas"
              },
              {
                "type": "paragraph",
                "content": "La red de carreteras en el pueblo forma un <em>gráfico</em>. Un gráfico es una colección de puntos (lugares en el pueblo) con líneas entre ellos (carreteras). Este gráfico será el mundo por el que se moverá nuestro robot."
              }
            ]
          },
          {
            "id": "ch07-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El array de cadenas no es muy fácil de trabajar. Lo que nos interesa son los destinos a los que podemos llegar desde un lugar dado. Vamos a convertir la lista de carreteras en una estructura de datos que, para cada lugar, nos diga qué se puede alcanzar desde allí."
              },
              {
                "type": "paragraph",
                "content": "Dado un array de aristas, <code>buildGraph</code> crea un objeto de mapa que, para cada nodo, almacena un array de nodos conectados."
              },
              {
                "type": "paragraph",
                "content": "Utiliza el método <code>split</code> para pasar de las cadenas de carreteras, que tienen la forma <code>\"Inicio-Fin\"</code>, a arrays de dos elementos que contienen el inicio y el fin como cadenas separadas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch07-l2",
        "title": "La tarea",
        "sections": [
          {
            "id": "ch07-l2-s0",
            "title": "La tarea",
            "content": [
              {
                "type": "paragraph",
                "content": "Nuestro robot se moverá por el pueblo. Hay paquetes en varios lugares, cada uno dirigido a algún otro lugar. El robot recoge los paquetes cuando llega a ellos y los entrega cuando llega a sus destinos."
              },
              {
                "type": "paragraph",
                "content": "El autómata debe decidir, en cada punto, hacia dónde ir a continuación. Habrá terminado su tarea cuando todos los paquetes hayan sido entregados."
              },
              {
                "type": "paragraph",
                "content": "Para poder simular este proceso, debemos definir un mundo virtual que pueda describirlo. Este modelo nos dice dónde está el robot y dónde están los paquetes. Cuando el robot decide moverse a algún lugar, necesitamos actualizar el modelo para reflejar la nueva situación."
              }
            ]
          },
          {
            "id": "ch07-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si estás pensando en términos de programación orientada a objetos, tu primer impulso podría ser empezar a definir objetos para los diferentes elementos en el mundo: una clase para el robot, una para un paquete, tal vez una para lugares. Estos podrían tener propiedades que describen su estado actual, como la pila de paquetes en un lugar, que podríamos cambiar al actualizar el mundo."
              },
              {
                "type": "paragraph",
                "content": "Esto es incorrecto. Al menos, usualmente lo es. El hecho de que algo suene como un objeto no significa automáticamente que deba ser un objeto en tu programa. Escribir reflexivamente clases para cada concepto en tu aplicación tiende a dejarte con una colección de objetos interconectados que tienen su propio estado interno cambiable. Estos programas a menudo son difíciles de entender y, por lo tanto, fáciles de romper."
              },
              {
                "type": "paragraph",
                "content": "En lugar de eso, vamos a condensar el estado del pueblo en el conjunto mínimo de valores que lo define. Está la ubicación actual del robot y la colección de paquetes no entregados, cada uno de los cuales tiene una ubicación actual y una dirección de destino. Eso es todo."
              }
            ]
          },
          {
            "id": "ch07-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Y mientras lo hacemos, hagamos que no <em>cambiemos</em> este estado cuando el robot se mueve, sino que calculemos un <em>nuevo</em> estado para la situación después del movimiento."
              },
              {
                "type": "paragraph",
                "content": "El método <code>move</code> es donde ocurre la acción. Primero verifica si hay un camino desde el lugar actual hasta el destino, y si no lo hay, devuelve el estado anterior ya que este no es un movimiento válido."
              },
              {
                "type": "paragraph",
                "content": "Luego crea un nuevo estado con el destino como el nuevo lugar del robot. Pero también necesita crear un nuevo conjunto de paquetes: los paquetes que lleva el robot (que están en el lugar actual del robot) deben ser trasladados al nuevo lugar. Y los paquetes dirigidos al nuevo lugar deben ser entregados, es decir, deben ser eliminados del conjunto de paquetes no entregados. La llamada a <code>map</code> se encarga del traslado y la llamada a <code>filter</code> de la entrega."
              }
            ]
          },
          {
            "id": "ch07-l2-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos de parcela no se modifican cuando se mueven, sino que se vuelven a crear. El método <code>move</code> nos proporciona un nuevo estado de aldea pero deja intacto por completo el anterior."
              },
              {
                "type": "paragraph",
                "content": "El movimiento hace que la parcela se entregue, y esto se refleja en el siguiente estado. Pero el estado inicial sigue describiendo la situación en la que el robot está en la oficina de correos y la parcela no se ha entregado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch07-l3",
        "title": "Datos persistentes",
        "sections": [
          {
            "id": "ch07-l3-s0",
            "title": "Datos persistentes",
            "content": [
              {
                "type": "paragraph",
                "content": "Las estructuras de datos que no cambian se llaman <em>inmutables</em> o <em>persistentes</em>. Se comportan de manera similar a las cadenas de texto y los números en el sentido de que son lo que son y se mantienen así, en lugar de contener cosas diferentes en momentos diferentes."
              },
              {
                "type": "paragraph",
                "content": "En JavaScript, casi todo <em>puede</em> cambiarse, por lo que trabajar con valores que se supone que son persistentes requiere cierta moderación. Existe una función llamada <code>Object.freeze</code> que cambia un objeto para que la escritura en sus propiedades sea ignorada. Podrías usar esto para asegurarte de que tus objetos no se modifiquen, si así lo deseas. Congelar requiere que la computadora realice un trabajo adicional, y que las actualizaciones se ignoren es casi tan propenso a confundir a alguien como hacer que hagan lo incorrecto. Por lo tanto, suelo preferir simplemente decirle a las personas que un objeto dado no debe ser modificado y esperar que lo recuerden."
              },
              {
                "type": "paragraph",
                "content": "¿Por qué me estoy esforzando tanto en no cambiar los objetos cuando el lenguaje obviamente espera que lo haga?"
              }
            ]
          },
          {
            "id": "ch07-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Porque me ayuda a entender mis programas. Una vez más, esto se trata de gestionar la complejidad. Cuando los objetos en mi sistema son cosas fijas y estables, puedo considerar operaciones sobre ellos de forma aislada: moverse a la casa de Alice desde un estado inicial dado siempre produce el mismo nuevo estado. Cuando los objetos cambian con el tiempo, eso añade toda una nueva dimensión de complejidad a este tipo de razonamiento."
              },
              {
                "type": "paragraph",
                "content": "Para un sistema pequeño como el que estamos construyendo en este capítulo, podríamos manejar ese poco de complejidad extra. Pero el límite más importante respecto a qué tipo de sistemas podemos construir es cuánto podemos entender. Cualquier cosa que haga que tu código sea más fácil de entender te permite construir un sistema más ambicioso."
              },
              {
                "type": "paragraph",
                "content": "Desafortunadamente, aunque entender un sistema construido sobre estructuras de datos persistentes es más fácil, <em>diseñar</em> uno, especialmente cuando tu lenguaje de programación no ayuda, puede ser un poco más difícil. Buscaremos oportunidades para usar estructuras de datos persistentes en este libro, pero también usaremos aquellas que pueden cambiar."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch07-l4",
        "title": "Simulación",
        "sections": [
          {
            "id": "ch07-l4-s0",
            "title": "Simulación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un robot de entrega observa el mundo y decide en qué dirección quiere moverse. Como tal, podríamos decir que un robot es una función que toma un objeto <code>VillageState</code> y devuelve el nombre de un lugar cercano."
              },
              {
                "type": "paragraph",
                "content": "Dado que queremos que los robots puedan recordar cosas, para que puedan hacer y ejecutar planes, también les pasamos su memoria y les permitimos devolver una nueva memoria. Por lo tanto, lo que un robot devuelve es un objeto que contiene tanto la dirección en la que quiere moverse como un valor de memoria que se le dará la próxima vez que se llame."
              },
              {
                "type": "paragraph",
                "content": "Consideremos lo que un robot tiene que hacer para “resolver” un estado dado. Debe recoger todos los paquetes visitando cada ubicación que tenga un paquete y entregarlos visitando cada ubicación a la que esté dirigido un paquete, pero solo después de recoger el paquete."
              }
            ]
          },
          {
            "id": "ch07-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¿Cuál es la estrategia más tonta que podría funcionar? El robot podría simplemente caminar en una dirección aleatoria en cada turno. Eso significa que, con gran probabilidad, eventualmente se topará con todos los paquetes y en algún momento también llegará al lugar donde deben ser entregados."
              },
              {
                "type": "paragraph",
                "content": "Esto es cómo podría lucir eso:"
              },
              {
                "type": "paragraph",
                "content": "Recuerda que <code>Math.random()</code> devuelve un número entre cero y uno, pero siempre por debajo de uno. Multiplicar dicho número por la longitud de un array y luego aplicarle <code>Math.floor</code> nos da un índice aleatorio para el array."
              }
            ]
          },
          {
            "id": "ch07-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dado que este robot no necesita recordar nada, ignora su segundo argumento (recuerda que las funciones de JavaScript pueden ser llamadas con argumentos adicionales sin efectos adversos) y omite la propiedad <code>memory</code> en su objeto devuelto."
              },
              {
                "type": "paragraph",
                "content": "Para poner a trabajar a este sofisticado robot, primero necesitaremos una forma de crear un nuevo estado con algunos paquetes. Un método estático (escrito aquí añadiendo directamente una propiedad al constructor) es un buen lugar para poner esa funcionalidad."
              },
              {
                "type": "paragraph",
                "content": "No queremos ningún paquete que sea enviado desde el mismo lugar al que está dirigido. Por esta razón, el bucle <code>do</code> sigue eligiendo nuevos lugares cuando obtiene uno que es igual a la dirección."
              }
            ]
          },
          {
            "id": "ch07-l4-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Vamos a iniciar un mundo virtual."
              },
              {
                "type": "paragraph",
                "content": "Al robot le lleva muchas vueltas entregar los paquetes porque no está planificando muy bien. Abordaremos eso pronto."
              },
              {
                "type": "paragraph",
                "content": "Para tener una perspectiva más agradable de la simulación, puedes usar la función <code>runRobotAnimation</code> que está disponible en el entorno de programación de este capítulo. Esto ejecuta la simulación, pero en lugar de mostrar texto, te muestra al robot moviéndose por el mapa del pueblo."
              }
            ]
          },
          {
            "id": "ch07-l4-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La forma en que <code>runRobotAnimation</code> está implementada permanecerá como un misterio por ahora, pero después de que hayas leído los capítulos posteriores de este libro, que tratan sobre la integración de JavaScript en los navegadores web, podrás adivinar cómo funciona."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch07-l5",
        "title": "Ruta del camión de correo",
        "sections": [
          {
            "id": "ch07-l5-s0",
            "title": "Ruta del camión de correo",
            "content": [
              {
                "type": "paragraph",
                "content": "Deberíamos poder hacerlo mucho mejor que el robot aleatorio. Una mejora sencilla sería inspirarnos en la forma en que funciona la entrega de correo en el mundo real. Si encontramos una ruta que pase por todos los lugares del pueblo, el robot podría recorrer esa ruta dos veces, momento en que se garantizaría que ha terminado. Aquí tienes una de esas rutas (comenzando desde la oficina de correos):"
              },
              {
                "type": "paragraph",
                "content": "Para implementar el robot que sigue la ruta, necesitaremos hacer uso de la memoria del robot. El robot guarda el resto de su ruta en su memoria y deja caer el primer elemento en cada turno."
              },
              {
                "type": "paragraph",
                "content": "Este robot es mucho más rápido ya. Tomará un máximo de 26 vueltas (el doble de la ruta de 13 pasos) pero generalmente menos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch07-l6",
        "title": "Búsqueda de caminos",
        "sections": [
          {
            "id": "ch07-l6-s0",
            "title": "Búsqueda de caminos",
            "content": [
              {
                "type": "paragraph",
                "content": "Aún así, no llamaría a seguir ciegamente una ruta fija un comportamiento inteligente. Sería más eficiente si el robot ajustara su comportamiento a la tarea real que debe realizarse."
              },
              {
                "type": "paragraph",
                "content": "Para hacer eso, tiene que poder moverse deliberadamente hacia un paquete dado o hacia la ubicación donde se debe entregar un paquete. Hacer eso, incluso cuando el objetivo está a más de un movimiento de distancia, requerirá algún tipo de función de búsqueda de ruta."
              },
              {
                "type": "paragraph",
                "content": "El problema de encontrar una ruta a través de un grafo es un <em>problema de búsqueda</em> típico. Podemos determinar si una solución dada (una ruta) es una solución válida, pero no podemos calcular directamente la solución como podríamos hacerlo para 2 + 2. En su lugar, debemos seguir creando soluciones potenciales hasta encontrar una que funcione."
              }
            ]
          },
          {
            "id": "ch07-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El número de rutas posibles a través de un grafo es infinito. Pero al buscar una ruta de <em>A</em> a <em>B</em>, solo estamos interesados en aquellas que comienzan en <em>A</em>. Además, no nos importan las rutas que visiten el mismo lugar dos veces, esas definitivamente no son las rutas más eficientes en ningún lugar. Así que eso reduce la cantidad de rutas que el buscador de rutas debe considerar.De hecho, estamos mayormente interesados en la ruta <em>más corta</em>. Por lo tanto, queremos asegurarnos de buscar rutas cortas antes de mirar las más largas. Un buen enfoque sería “expandir” rutas desde el punto de inicio, explorando cada lugar alcanzable que aún no haya sido visitado, hasta que una ruta llegue al objetivo. De esta manera, solo exploraremos rutas que sean potencialmente interesantes, y sabremos que la primera ruta que encontremos es la ruta más corta (o una de las rutas más cortas, si hay más de una)."
              },
              {
                "type": "paragraph",
                "content": "Aquí hay una función que hace esto:"
              },
              {
                "type": "paragraph",
                "content": "La exploración debe realizarse en el orden correcto: los lugares que se alcanzaron primero deben explorarse primero. No podemos explorar de inmediato un lugar tan pronto como lleguemos a él porque eso significaría que los lugares alcanzados <em>desde allí</em> también se explorarían de inmediato, y así sucesivamente, incluso si puede haber otros caminos más cortos que aún no se han explorado."
              }
            ]
          },
          {
            "id": "ch07-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por lo tanto, la función mantiene una <em>lista de trabajo</em>. Esta es una matriz de lugares que deben ser explorados a continuación, junto con la ruta que nos llevó allí. Comienza con solo la posición de inicio y una ruta vacía."
              },
              {
                "type": "paragraph",
                "content": "La búsqueda luego opera tomando el siguiente elemento en la lista y explorándolo, lo que significa que se ven todas las rutas que salen de ese lugar. Si una de ellas es el objetivo, se puede devolver una ruta terminada. De lo contrario, si no hemos mirado este lugar antes, se agrega un nuevo elemento a la lista. Si lo hemos mirado antes, dado que estamos buscando rutas cortas primero, hemos encontrado o bien una ruta más larga a ese lugar o una exactamente tan larga como la existente, y no necesitamos explorarla."
              },
              {
                "type": "paragraph",
                "content": "Puedes imaginar visualmente esto como una red de rutas conocidas que se extienden desde la ubicación de inicio, creciendo de manera uniforme en todos los lados (pero nunca enredándose de nuevo en sí misma). Tan pronto como el primer hilo alcance la ubicación objetivo, ese hilo se rastrea de vuelta al inicio, dándonos nuestra ruta."
              }
            ]
          },
          {
            "id": "ch07-l6-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Nuestro código no maneja la situación en la que no hay más elementos de trabajo en la lista de trabajo porque sabemos que nuestro gráfico está <em>conectado</em>, lo que significa que se puede llegar a cada ubicación desde todas las demás ubicaciones. Siempre podremos encontrar una ruta entre dos puntos, y la búsqueda no puede fallar."
              },
              {
                "type": "paragraph",
                "content": "Este robot utiliza el valor de su memoria como una lista de direcciones en las que moverse, al igual que el robot que sigue la ruta. Cuando esa lista está vacía, debe averiguar qué hacer a continuación. Toma el primer paquete no entregado del conjunto y, si ese paquete aún no ha sido recogido, traza una ruta hacia él. Si el paquete ya ha sido recogido, todavía necesita ser entregado, por lo que el robot crea una ruta hacia la dirección de entrega."
              },
              {
                "type": "paragraph",
                "content": "Veamos cómo lo hace."
              }
            ]
          },
          {
            "id": "ch07-l6-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este robot suele terminar la tarea de entregar 5 paquetes en aproximadamente 16 turnos. Eso es ligeramente mejor que <code>routeRobot</code> pero definitivamente no es óptimo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch07-l7",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch07-l7-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Es difícil comparar de manera objetiva los robots solo dejando que resuelvan algunos escenarios. Tal vez un robot simplemente tuvo tareas más fáciles o el tipo de tareas en las que es bueno, mientras que el otro no."
              },
              {
                "type": "paragraph",
                "content": "Escribe una función <code>compareRobots</code> que tome dos robots (y su memoria inicial). Debería generar 100 tareas y permitir que cada uno de los robots resuelva cada una de estas tareas. Cuando termine, debería mostrar el número promedio de pasos que cada robot dio por tarea."
              },
              {
                "type": "paragraph",
                "content": "Por el bien de la equidad, asegúrate de darle a cada tarea a ambos robots, en lugar de generar tareas diferentes por robot."
              }
            ]
          },
          {
            "id": "ch07-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tendrás que escribir una variante de la función <code>runRobot</code> que, en lugar de registrar los eventos en la consola, devuelva el número de pasos que el robot tomó para completar la tarea."
              },
              {
                "type": "paragraph",
                "content": "Tu función de medición puede, entonces, en un bucle, generar nuevos estados y contar los pasos que toma cada uno de los robots. Cuando haya generado suficientes mediciones, puede usar <code>console.log</code> para mostrar el promedio de cada robot, que es el número total de pasos tomados dividido por el número de mediciones."
              },
              {
                "type": "paragraph",
                "content": "¿Puedes escribir un robot que termine la tarea de entrega más rápido que <code>goalOrientedRobot</code>? Si observas el comportamiento de ese robot, ¿qué cosas claramente absurdas hace? ¿Cómo podrían mejorarse?"
              }
            ]
          },
          {
            "id": "ch07-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si resolviste el ejercicio anterior, es posible que desees utilizar tu función <code>compareRobots</code> para verificar si mejoraste el robot."
              },
              {
                "type": "paragraph",
                "content": "La principal limitación de <code>goalOrientedRobot</code> es que solo considera un paquete a la vez. A menudo caminará de un lado a otro del pueblo porque el paquete en el que está centrando su atención sucede que está en el otro lado del mapa, incluso si hay otros mucho más cerca."
              },
              {
                "type": "paragraph",
                "content": "Una posible solución sería calcular rutas para todos paquetes y luego tomar la más corta. Se pueden obtener resultados aún mejores, si hay múltiples rutas más cortas, al preferir aquellas que van a recoger un paquete en lugar de entregarlo."
              }
            ]
          },
          {
            "id": "ch07-l7-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría de las estructuras de datos proporcionadas en un entorno estándar de JavaScript no son muy adecuadas para un uso persistente. Los Arrays tienen métodos <code>slice</code> y <code>concat</code>, que nos permiten crear fácilmente nuevos arrays sin dañar el antiguo. Pero <code>Set</code>, por ejemplo, no tiene métodos para crear un nuevo conjunto con un elemento añadido o eliminado."
              },
              {
                "type": "paragraph",
                "content": "Escribe una nueva clase <code>PGroup</code>, similar a la clase <code>Grupo</code> del Capítulo 6, que almacena un conjunto de valores. Al igual que <code>Grupo</code>, tiene métodos <code>add</code>, <code>delete</code>, y <code>has</code>."
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, su método <code>add</code> debería devolver una <em>nueva</em> instancia de <code>PGroup</code> con el miembro dado añadido y dejar la anterior sin cambios. De manera similar, <code>delete</code> crea una nueva instancia sin un miembro dado."
              }
            ]
          },
          {
            "id": "ch07-l7-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La clase debería funcionar para valores de cualquier tipo, no solo para strings. No tiene que ser eficiente cuando se utiliza con grandes cantidades de valores."
              },
              {
                "type": "paragraph",
                "content": "El constructor no debería ser parte de la interfaz de la clase (aunque definitivamente querrás usarlo internamente). En su lugar, hay una instancia vacía, <code>PGroup.empty</code>, que se puede usar como valor inicial."
              },
              {
                "type": "paragraph",
                "content": "¿Por qué necesitas solo un valor <code>PGroup.empty</code>, en lugar de tener una función que cree un nuevo mapa vacío cada vez?"
              }
            ]
          },
          {
            "id": "ch07-l7-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La forma más conveniente de representar el conjunto de valores miembro sigue siendo como un array, ya que los arrays son fáciles de copiar."
              },
              {
                "type": "paragraph",
                "content": "Cuando se añade un valor al grupo, puedes crear un nuevo grupo con una copia del array original que tenga el valor añadido (por ejemplo, usando <code>concat</code>). Cuando se elimina un valor, puedes filtrarlo del array."
              },
              {
                "type": "paragraph",
                "content": "El constructor de la clase puede tomar dicho array como argumento y almacenarlo como propiedad única de la instancia. Este array nunca se actualiza."
              }
            ]
          },
          {
            "id": "ch07-l7-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para añadir la propiedad <code>empty</code> al constructor, puedes declararla como una propiedad estática."
              },
              {
                "type": "paragraph",
                "content": "Solo necesitas una instancia <code>empty</code> porque todos los grupos vacíos son iguales y las instancias de la clase no cambian. Puedes crear muchos grupos diferentes a partir de ese único grupo vacío sin afectarlo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      }
    ]
  },
  {
    "id": "ch08",
    "number": 8,
    "title": "Bugs y Errores",
    "titleEs": "Bugs y Errores",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Depurar es el doble de difícil que escribir el código en primer lugar. Por lo tanto, si escribes el código lo más ingeniosamente posible, por definici...",
    "isProject": false,
    "totalXP": 440,
    "lessons": [
      {
        "id": "ch08-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch08-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Depurar es el doble de difícil que escribir el código en primer lugar. Por lo tanto, si escribes el código lo más ingeniosamente posible, por definición, no eres lo suficientemente inteligente como para depurarlo. Brian Kernighan and P.J. Plauger, The Elements of Programming Style"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Bugs y Errores __ Eloquent JavaScript_files/chapter_picture_8.jpg",
                "alt": "Ilustración mostrando varios insectos y un ciempiés"
              },
              {
                "type": "paragraph",
                "content": "Las fallas en los programas de computadora generalmente se llaman <em>bugs</em>. Hace que los programadores se sientan bien imaginarlos como pequeñas cosas que simplemente se meten en nuestro trabajo. En realidad, por supuesto, nosotros mismos los colocamos allí."
              }
            ]
          },
          {
            "id": "ch08-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si un programa es pensamiento cristalizado, puedes clasificar aproximadamente los errores en aquellos causados por pensamientos confusos y aquellos causados por errores introducidos al convertir un pensamiento en código. El primer tipo generalmente es más difícil de diagnosticar y arreglar que el último."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch08-l1",
        "title": "Lenguaje",
        "sections": [
          {
            "id": "ch08-l1-s0",
            "title": "Lenguaje",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos errores podrían ser señalados automáticamente por la computadora, si supiera lo suficiente sobre lo que estamos intentando hacer. Pero la laxitud de JavaScript es un obstáculo aquí. Su concepto de enlaces y propiedades es lo suficientemente vago como para rara vez atrapar typos antes de ejecutar realmente el programa. E incluso entonces, te permite hacer algunas cosas claramente absurdas sin quejarse, como calcular <code>true * \"monkey\"</code>."
              },
              {
                "type": "paragraph",
                "content": "Hay algunas cosas sobre las que JavaScript sí se queja. Escribir un programa que no siga la gramática del lenguaje hará que la computadora se queje de inmediato. Otras cosas, como llamar a algo que no es una función o buscar una propiedad en un valor undefined harán que se reporte un error cuando el programa intente realizar la acción."
              },
              {
                "type": "paragraph",
                "content": "Pero a menudo, tu cálculo absurdo simplemente producirá <code>NaN</code> (no es un número) o un valor indefinido, mientras que el programa continúa felizmente, convencido de que está haciendo algo significativo. El error se manifestará solo más tarde, después de que el valor falso haya pasado por varias funciones. Es posible que no desencadene un error en absoluto, pero silenciosamente cause que la salida del programa sea incorrecta. Encontrar la fuente de tales problemas puede ser difícil."
              }
            ]
          },
          {
            "id": "ch08-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El proceso de encontrar errores—bugs—en los programas se llama <em>depuración</em>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch08-l2",
        "title": "Modo estricto",
        "sections": [
          {
            "id": "ch08-l2-s0",
            "title": "Modo estricto",
            "content": [
              {
                "type": "paragraph",
                "content": "JavaScript puede ser un <em>poco</em> más estricto al habilitar el <em>modo estricto</em>. Esto se hace colocando la cadena <code>\"use strict\"</code> en la parte superior de un archivo o en el cuerpo de una función. Aquí tienes un ejemplo:"
              },
              {
                "type": "paragraph",
                "content": "Normalmente, cuando olvidas poner <code>let</code> frente a tu enlace, como en el caso de <code>counter</code> en el ejemplo, JavaScript silenciosamente crea un enlace global y lo utiliza. En modo estricto, se reporta un error en su lugar. Esto es muy útil. Sin embargo, cabe mencionar que esto no funciona cuando el enlace en cuestión ya existe en algún lugar del ámbito. En ese caso, el bucle seguirá sobrescribiendo silenciosamente el valor del enlace."
              },
              {
                "type": "paragraph",
                "content": "Otro cambio en el modo estricto es que el enlace <code>this</code> mantiene el valor <code>undefined</code> en funciones que no son llamadas como métodos. Al hacer una llamada de este tipo fuera del modo estricto, <code>this</code> se refiere al objeto de ámbito global, que es un objeto cuyas propiedades son los enlaces globales. Entonces, si accidentalmente llamas incorrectamente a un método o constructor en modo estricto, JavaScript producirá un error tan pronto como intente leer algo de <code>this</code>, en lugar de escribir felizmente en el ámbito global."
              }
            ]
          },
          {
            "id": "ch08-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por ejemplo, considera el siguiente código, que llama a una función constructor sin la palabra clave <code>new</code> para que su <code>this</code> <em>no</em> se refiera a un objeto recién construido:"
              },
              {
                "type": "paragraph",
                "content": "Entonces, la llamada falsa a <code>Person</code> tuvo éxito pero devolvió un valor no definido y creó el enlace global <code>name</code>. En modo estricto, el resultado es diferente."
              },
              {
                "type": "paragraph",
                "content": "Inmediatamente se nos informa que algo está mal. Esto es útil."
              }
            ]
          },
          {
            "id": "ch08-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Afortunadamente, los constructores creados con la notación <code>class</code> siempre mostrarán una queja si se llaman sin <code>new</code>, lo que hace que esto sea menos problemático incluso en modo no estricto."
              },
              {
                "type": "paragraph",
                "content": "El modo estricto hace algunas cosas más. Prohíbe darle a una función múltiples parámetros con el mismo nombre y elimina ciertas características problemáticas del lenguaje por completo (como la declaración <code>with</code>, que es tan incorrecta que no se discute más en este libro)."
              },
              {
                "type": "paragraph",
                "content": "En resumen, colocar <code>\"use strict\"</code> al principio de tu programa rara vez duele y podría ayudarte a identificar un problema."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch08-l3",
        "title": "Tipos",
        "sections": [
          {
            "id": "ch08-l3-s0",
            "title": "Tipos",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunos lenguajes quieren saber los tipos de todos tus enlaces y expresiones antes de ejecutar un programa. Te indicarán de inmediato cuando un tipo se utiliza de manera inconsistente. JavaScript considera los tipos solo cuando realmente se ejecuta el programa, e incluso allí a menudo intenta convertir valores implícitamente al tipo que espera, por lo que no es de mucha ayuda."
              },
              {
                "type": "paragraph",
                "content": "No obstante, los tipos proporcionan un marco útil para hablar sobre programas. Muchos errores provienen de estar confundido acerca del tipo de valor que entra o sale de una función. Si tienes esa información escrita, es menos probable que te confundas.Podrías agregar un comentario como el siguiente antes de la función <code>findRoute</code> del capítulo anterior para describir su tipo:"
              },
              {
                "type": "paragraph",
                "content": "Existen varias convenciones diferentes para anotar programas de JavaScript con tipos."
              }
            ]
          },
          {
            "id": "ch08-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una cosa sobre los tipos es que necesitan introducir su propia complejidad para poder describir suficiente código para ser útiles. ¿Qué tipo crees que tendría la función <code>randomPick</code> que devuelve un elemento aleatorio de un array? Necesitarías introducir una <em>variable de tipo</em>, <em>T</em>, que pueda representar cualquier tipo, para que puedas darle a <code>randomPick</code> un tipo como <code>(T[]) → T</code> (función de un array de <em>T</em> a un <em>T</em>)."
              },
              {
                "type": "paragraph",
                "content": "Cuando los tipos de un programa son conocidos, es posible que la computadora los <em>verifique</em> por ti, señalando errores antes de que se ejecute el programa. Hay varios dialectos de JavaScript que añaden tipos al lenguaje y los verifican. El más popular se llama TypeScript. Si estás interesado en agregar más rigor a tus programas, te recomiendo que lo pruebes."
              },
              {
                "type": "paragraph",
                "content": "En este libro, continuaremos utilizando código JavaScript crudo, peligroso y sin tipos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch08-l4",
        "title": "Pruebas",
        "sections": [
          {
            "id": "ch08-l4-s0",
            "title": "Pruebas",
            "content": [
              {
                "type": "paragraph",
                "content": "Si el lenguaje no nos va a ayudar mucho a encontrar errores, tendremos que encontrarlos a la antigua: ejecutando el programa y viendo si hace lo correcto."
              },
              {
                "type": "paragraph",
                "content": "Hacer esto manualmente, una y otra vez, es una idea muy mala. No solo es molesto, también tiende a ser ineficaz, ya que lleva demasiado tiempo probar exhaustivamente todo cada vez que haces un cambio."
              },
              {
                "type": "paragraph",
                "content": "Las computadoras son buenas en tareas repetitivas, y las pruebas son la tarea repetitiva ideal. Las pruebas automatizadas son el proceso de escribir un programa que prueba otro programa. Es un poco más trabajo escribir pruebas que probar manualmente, pero una vez que lo has hecho, adquieres una especie de superpoder: solo te llevará unos segundos verificar que tu programa siga comportándose correctamente en todas las situaciones para las que escribiste pruebas. Cuando rompes algo, lo notarás de inmediato en lugar de encontrártelo al azar en algún momento posterior."
              }
            ]
          },
          {
            "id": "ch08-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las pruebas suelen tomar la forma de pequeños programas etiquetados que verifican algún aspecto de tu código. Por ejemplo, un conjunto de pruebas para el (probablemente ya probado por alguien más) método <code>toUpperCase</code> estándar podría lucir así:"
              },
              {
                "type": "paragraph",
                "content": "Escribir pruebas de esta forma tiende a producir código bastante repetitivo y torpe. Afortunadamente, existen software que te ayudan a construir y ejecutar colecciones de pruebas (<em>suites de pruebas</em>) al proporcionar un lenguaje (en forma de funciones y métodos) adecuado para expresar pruebas y al producir información informativa cuando una prueba falla. Estos suelen llamarse <em>corredores de pruebas</em>."
              },
              {
                "type": "paragraph",
                "content": "Alguno código es más fácil de probar que otro código. Generalmente, cuantos más objetos externos interactúan con el código, más difícil es configurar el contexto para probarlo. El estilo de programación mostrado en el capítulo anterior, que utiliza valores persistentes autocontenidos en lugar de objetos cambiantes, tiende a ser fácil de probar."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch08-l5",
        "title": "Depuración",
        "sections": [
          {
            "id": "ch08-l5-s0",
            "title": "Depuración",
            "content": [
              {
                "type": "paragraph",
                "content": "Una vez que notas que hay algo mal en tu programa porque se comporta de manera incorrecta o produce errores, el siguiente paso es descubrir <em>cuál</em> es el problema."
              },
              {
                "type": "paragraph",
                "content": "A veces es obvio. El mensaje de error señalará una línea específica de tu programa, y si miras la descripción del error y esa línea de código, a menudo puedes ver el problema."
              },
              {
                "type": "paragraph",
                "content": "Pero no siempre. A veces la línea que desencadenó el problema es simplemente el primer lugar donde se utiliza de manera incorrecta un valor defectuoso producido en otro lugar. Si has estado resolviendo los ejercicios en capítulos anteriores, probablemente ya hayas experimentado estas situaciones."
              }
            ]
          },
          {
            "id": "ch08-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente programa de ejemplo intenta convertir un número entero en una cadena en una base dada (decimal, binaria, y así sucesivamente) al seleccionar repetidamente el último dígito y luego dividir el número para deshacerse de este dígito. Pero la extraña salida que produce actualmente sugiere que tiene un error."
              },
              {
                "type": "paragraph",
                "content": "Incluso si ya ves el problema, finge por un momento que no lo haces. Sabemos que nuestro programa no funciona correctamente, y queremos descubrir por qué."
              },
              {
                "type": "paragraph",
                "content": "Aquí es donde debes resistir la tentación de empezar a hacer cambios aleatorios en el código para ver si eso lo mejora. En cambio, <em>piensa</em>. Analiza lo que está sucediendo y elabora una teoría sobre por qué podría estar ocurriendo. Luego, realiza observaciones adicionales para probar esta teoría, o si aún no tienes una teoría, realiza observaciones adicionales para ayudarte a crear una."
              }
            ]
          },
          {
            "id": "ch08-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Colocar algunas llamadas <code>console.log</code> estratégicas en el programa es una buena manera de obtener información adicional sobre lo que está haciendo el programa. En este caso, queremos que <code>n</code> tome los valores <code>13</code>, <code>1</code> y luego <code>0</code>. Vamos a escribir su valor al inicio del ciclo."
              },
              {
                "type": "paragraph",
                "content": "<em>Correcto</em>. Al dividir 13 por 10 no se produce un número entero. En lugar de <code>n /= base</code>, lo que realmente queremos es <code>n = Math.<wbr>floor(n /<wbr> base)</code> para que el número se “desplace” correctamente hacia la derecha."
              },
              {
                "type": "paragraph",
                "content": "Una alternativa a usar <code>console.log</code> para observar el comportamiento del programa es utilizar las capacidades del <em>depurador</em> de tu navegador. Los navegadores vienen con la capacidad de establecer un <em>punto de interrupción</em> en una línea específica de tu código. Cuando la ejecución del programa llega a una línea con un punto de interrupción, se pausa y puedes inspeccionar los valores de las asignaciones en ese punto. No entraré en detalles, ya que los depuradores difieren de un navegador a otro, pero busca en las herramientas de desarrollo de tu navegador o busca instrucciones en la Web.Otra forma de establecer un punto de interrupción es incluir una instrucción <code>debugger</code> (consistente únicamente en esa palabra clave) en tu programa. Si las herramientas de desarrollo de tu navegador están activas, el programa se pausará cada vez que alcance dicha instrucción."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch08-l6",
        "title": "Propagación de errores",
        "sections": [
          {
            "id": "ch08-l6-s0",
            "title": "Propagación de errores",
            "content": [
              {
                "type": "paragraph",
                "content": "Lamentablemente, no todos los problemas pueden ser prevenidos por el programador. Si tu programa se comunica de alguna manera con el mundo exterior, es posible recibir entradas malformadas, sobrecargarse de trabajo o que falle la red."
              },
              {
                "type": "paragraph",
                "content": "Si estás programando solo para ti, puedes permitirte simplemente ignorar esos problemas hasta que ocurran. Pero si estás construyendo algo que será utilizado por alguien más, generalmente quieres que el programa haga algo más que simplemente colapsar. A veces lo correcto es aceptar la entrada incorrecta y continuar ejecutándose. En otros casos, es mejor informar al usuario sobre lo que salió mal y luego rendirse. Pero en cualquier situación, el programa debe hacer algo activamente en respuesta al problema."
              },
              {
                "type": "paragraph",
                "content": "Imaginemos que tienes una función <code>promptNumber</code> que solicita al usuario un número y lo retorna. ¿Qué debería retornar si el usuario ingresa “naranja”?"
              }
            ]
          },
          {
            "id": "ch08-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una opción es hacer que retorne un valor especial. Las opciones comunes para tales valores son <code>null</code>, <code>undefined</code> o -1."
              },
              {
                "type": "paragraph",
                "content": "Ahora, cualquier código que llame a <code>promptNumber</code> debe verificar si se leyó un número real y, de no ser así, debe recuperarse de alguna manera, quizás volviendo a preguntar o completando con un valor predeterminado. O podría retornar nuevamente un valor especial a su llamante para indicar que no pudo hacer lo que se le pidió."
              },
              {
                "type": "paragraph",
                "content": "En muchas situaciones, sobre todo cuando los errores son comunes y el llamante debería tomarlos explícitamente en cuenta, retornar un valor especial es una buena manera de indicar un error. Sin embargo, tiene sus inconvenientes. Primero, ¿qué pasa si la función ya puede devolver todos los tipos posibles de valores? En tal función, tendrás que hacer algo como envolver el resultado en un objeto para poder distinguir el éxito del fracaso, de la misma manera que lo hace el método <code>next</code> en la interfaz del iterador."
              }
            ]
          },
          {
            "id": "ch08-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El segundo problema con retornar valores especiales es que puede llevar a un código incómodo. Si un fragmento de código llama a <code>promptNumber</code> 10 veces, tendrá que verificar 10 veces si se devolvió <code>null</code>. Y si su respuesta al encontrar <code>null</code> es simplemente devolver <code>null</code> en sí mismo, los llamantes de la función a su vez tendrán que comprobarlo, y así sucesivamente."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch08-l7",
        "title": "Excepciones",
        "sections": [
          {
            "id": "ch08-l7-s0",
            "title": "Excepciones",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando una función no puede proceder normalmente, lo que a menudo <em>queremos</em> hacer es simplemente detener lo que estamos haciendo e ir directamente a un lugar que sepa cómo manejar el problema. Esto es lo que hace el <em>manejo de excepciones</em>."
              },
              {
                "type": "paragraph",
                "content": "Las excepciones son un mecanismo que hace posible que el código que se encuentra con un problema <em>lanze</em> (o <em>emita</em>) una excepción. Una excepción puede ser cualquier valor. Lanzar una se asemeja de alguna manera a un retorno super potenciado de una función: sale no solo de la función actual sino también de sus llamadores, hasta llegar a la primera llamada que inició la ejecución actual. Esto se llama <em>desenrollar la pila</em>. Puede recordar la pila de llamadas a funciones que se mencionó en el Capítulo 3. Una excepción recorre esta pila, descartando todos los contextos de llamada que encuentra."
              },
              {
                "type": "paragraph",
                "content": "Si las excepciones siempre fueran directamente hasta el final de la pila, no serían de mucha utilidad. Simplemente proporcionarían una forma novedosa de hacer que su programa falle. Su poder radica en el hecho de que puede colocar “obstáculos” a lo largo de la pila para <em>capturar</em> la excepción mientras viaja hacia abajo. Una vez que ha capturado una excepción, puede hacer algo con ella para resolver el problema y luego continuar ejecutando el programa."
              }
            ]
          },
          {
            "id": "ch08-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Aquí tienes un ejemplo:"
              },
              {
                "type": "paragraph",
                "content": "La palabra clave <code>throw</code> se utiliza para lanzar una excepción. La captura de una excepción se realiza envolviendo un trozo de código en un bloque <code>try</code>, seguido de la palabra clave <code>catch</code>. Cuando el código en el bloque <code>try</code> provoca que se lance una excepción, se evalúa el bloque <code>catch</code>, con el nombre entre paréntesis vinculado al valor de la excepción. Después de que el bloque <code>catch</code> finalice, o si el bloque <code>try</code> finaliza sin problemas, el programa continúa debajo de toda la instrucción <code>try/catch</code>."
              },
              {
                "type": "paragraph",
                "content": "En este caso, utilizamos el constructor <code>Error</code> para crear nuestro valor de excepción. Este es un constructor de JavaScript estándar que crea un objeto con una propiedad <code>message</code>. Las instancias de <code>Error</code> también recopilan información sobre la pila de llamadas que existía cuando se creó la excepción, una llamada <em>traza de pila</em>. Esta información se almacena en la propiedad <code>stack</code> y puede ser útil al intentar depurar un problema: nos indica la función donde ocurrió el problema y qué funciones realizaron la llamada fallida."
              }
            ]
          },
          {
            "id": "ch08-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ten en cuenta que la función <code>look</code> ignora por completo la posibilidad de que <code>promptDirection</code> pueda fallar. Esta es la gran ventaja de las excepciones: el código de manejo de errores solo es necesario en el punto donde ocurre el error y en el punto donde se maneja. Las funciones intermedias pueden olvidarse por completo de ello."
              },
              {
                "type": "paragraph",
                "content": "Bueno, casi..."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch08-l8",
        "title": "Limpiando después de excepciones",
        "sections": [
          {
            "id": "ch08-l8-s0",
            "title": "Limpiando después de excepciones",
            "content": [
              {
                "type": "paragraph",
                "content": "El efecto de una excepción es otro tipo de flujo de control. Cada acción que pueda causar una excepción, que es prácticamente cada llamada a función y acceso a propiedad, puede hacer que el control salga repentinamente de tu código."
              },
              {
                "type": "paragraph",
                "content": "Esto significa que cuando el código tiene varios efectos secundarios, incluso si su flujo de control “regular” parece que siempre ocurrirán todos, una excepción podría evitar que algunos de ellos sucedan."
              },
              {
                "type": "paragraph",
                "content": "Aquí tienes un código bancario realmente malo."
              }
            ]
          },
          {
            "id": "ch08-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>transfer</code> transfiere una suma de dinero desde una cuenta dada a otra, pidiendo el nombre de la otra cuenta en el proceso. Si se proporciona un nombre de cuenta inválido, <code>getAccount</code> lanza una excepción."
              },
              {
                "type": "paragraph",
                "content": "Pero <code>transfer</code> <em>primero</em> retira el dinero de la cuenta y <em>luego</em> llama a <code>getAccount</code> antes de agregarlo a otra cuenta. Si se interrumpe por una excepción en ese momento, simplemente hará desaparecer el dinero."
              },
              {
                "type": "paragraph",
                "content": "Ese código podría haber sido escrito de manera un poco más inteligente, por ejemplo, llamando a <code>getAccount</code> antes de comenzar a mover el dinero. Pero a menudo los problemas como este ocurren de formas más sutiles. Incluso las funciones que no parecen que lanzarán una excepción podrían hacerlo en circunstancias excepcionales o cuando contienen un error del programador."
              }
            ]
          },
          {
            "id": "ch08-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una manera de abordar esto es utilizar menos efectos secundarios. Nuevamente, un estilo de programación que calcule nuevos valores en lugar de cambiar datos existentes ayuda. Si un fragmento de código deja de ejecutarse en medio de la creación de un nuevo valor, no se dañaron estructuras de datos existentes, lo que facilita la recuperación."
              },
              {
                "type": "paragraph",
                "content": "Pero eso no siempre es práctico. Por eso existe otra característica que tienen las instrucciones <code>try</code>. Pueden estar seguidas de un bloque <code>finally</code> en lugar o además de un bloque <code>catch</code>. Un bloque <code>finally</code> dice “sin importar <em>qué</em> suceda, ejecuta este código después de intentar ejecutar el código en el bloque <code>try</code>.”"
              },
              {
                "type": "paragraph",
                "content": "Esta versión de la función rastrea su progreso y, si al salir nota que fue abortada en un punto donde había creado un estado del programa inconsistente, repara el daño causado."
              }
            ]
          },
          {
            "id": "ch08-l8-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cabe destacar que aunque el código <code>finally</code> se ejecuta cuando se lanza una excepción en el bloque <code>try</code>, no interfiere con la excepción. Después de que se ejecuta el bloque <code>finally</code>, la pila continúa desenrollándose."
              },
              {
                "type": "paragraph",
                "content": "Escribir programas que funcionen de manera confiable incluso cuando surgen excepciones en lugares inesperados es difícil. Muchas personas simplemente no se preocupan, y debido a que las excepciones suelen reservarse para circunstancias excepcionales, el problema puede ocurrir tan raramente que ni siquiera se note. Si eso es algo bueno o realmente malo depende de cuánto daño causará el software cuando falle."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch08-l9",
        "title": "Captura selectiva",
        "sections": [
          {
            "id": "ch08-l9-s0",
            "title": "Captura selectiva",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando una excepción llega hasta el final de la pila sin ser capturada, es manejada por el entorno. Lo que esto significa difiere según los entornos. En los navegadores, generalmente se escribe una descripción del error en la consola de JavaScript (accesible a través del menú Herramientas o Desarrollador del navegador). Node.js, el entorno de JavaScript sin navegador del que hablaremos en el Capítulo 20, es más cuidadoso con la corrupción de datos. Abortará todo el proceso cuando ocurra una excepción no manejada."
              },
              {
                "type": "paragraph",
                "content": "Para errores de programación, a menudo dejar que el error siga su curso es lo mejor que se puede hacer. Una excepción no manejada es una forma razonable de señalar un programa defectuoso, y la consola de JavaScript proporcionará, en navegadores modernos, información sobre qué llamadas a funciones estaban en la pila cuando ocurrió el problema."
              },
              {
                "type": "paragraph",
                "content": "Para problemas que se <em>espera</em> que ocurran durante el uso rutinario, fallar con una excepción no manejada es una estrategia terrible."
              }
            ]
          },
          {
            "id": "ch08-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Usos incorrectos del lenguaje, como hacer referencia a un enlace inexistente, buscar una propiedad en <code>null</code> o llamar a algo que no es una función, también provocarán que se lancen excepciones. Estas excepciones también pueden ser capturadas."
              },
              {
                "type": "paragraph",
                "content": "Cuando se entra en un cuerpo <code>catch</code>, todo lo que sabemos es que <em>algo</em> en nuestro cuerpo <code>try</code> causó una excepción. Pero no sabemos <em>qué</em> lo hizo ni <em>qué</em> excepción causó."
              },
              {
                "type": "paragraph",
                "content": "JavaScript (en una omisión bastante llamativa) no proporciona un soporte directo para capturar excepciones selectivamente: o las capturas todas o no capturas ninguna. Esto hace que sea tentador <em>asumir</em> que la excepción que obtienes es la que tenías en mente cuando escribiste el bloque <code>catch</code>."
              }
            ]
          },
          {
            "id": "ch08-l9-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero podría no serlo. Alguno otra asunción podría estar violada, o podrías haber introducido un error que está causando una excepción. Aquí tienes un ejemplo que <em>intenta</em> seguir llamando a <code>promptDirection</code> hasta obtener una respuesta válida:"
              },
              {
                "type": "paragraph",
                "content": "La construcción <code>for (;;)</code> es una forma de crear intencionalmente un bucle que no se termina por sí mismo. Salimos del bucle solo cuando se proporciona una dirección válida. <em>Pero</em> escribimos mal <code>promptDirection</code>, lo que resultará en un error de “variable no definida”. Debido a que el bloque <code>catch</code> ignora por completo el valor de la excepción (<code>e</code>), asumiendo que sabe cuál es el problema, trata erróneamente el error de enlace mal escrito como indicativo de una entrada incorrecta. Esto no solo causa un bucle infinito, sino que también “entorpece” el útil mensaje de error sobre el enlace mal escrito."
              },
              {
                "type": "paragraph",
                "content": "Como regla general, no captures excepciones de manera general a menos que sea con el propósito de “enviarlas” a algún lugar, por ejemplo, a través de la red para informar a otro sistema que nuestro programa se bloqueó. E incluso en ese caso, piensa cuidadosamente cómo podrías estar ocultando información."
              }
            ]
          },
          {
            "id": "ch08-l9-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por lo tanto, queremos capturar un tipo <em>específico</em> de excepción. Podemos hacer esto verificando en el bloque <code>catch</code> si la excepción que recibimos es la que nos interesa y relanzándola en caso contrario. Pero, ¿cómo reconocemos una excepción?"
              },
              {
                "type": "paragraph",
                "content": "Podríamos comparar su propiedad <code>message</code> con el mensaje que esperamos error. Pero esta es una forma poco confiable de escribir código, estaríamos utilizando información diseñada para consumo humano (el mensaje) para tomar una decisión programática. Tan pronto como alguien cambie (o traduzca) el mensaje, el código dejará de funcionar."
              },
              {
                "type": "paragraph",
                "content": "En lugar de eso, definamos un nuevo tipo de error y usemos <code>instanceof</code> para identificarlo."
              }
            ]
          },
          {
            "id": "ch08-l9-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La nueva clase de error extiende <code>Error</code>. No define su propio constructor, lo que significa que hereda el constructor de <code>Error</code>, que espera un mensaje de cadena como argumento. De hecho, no define nada en absoluto, la clase está vacía. Los objetos <code>InputError</code> se comportan como objetos <code>Error</code>, excepto que tienen una clase diferente mediante la cual podemos reconocerlos."
              },
              {
                "type": "paragraph",
                "content": "Ahora el bucle puede capturar esto con más cuidado."
              },
              {
                "type": "paragraph",
                "content": "Esto capturará solo instancias de <code>InputError</code> y permitirá que pasen excepciones no relacionadas. Si vuelves a introducir el error de tipeo, el error de enlace no definido se informará correctamente."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch08-l10",
        "title": "Afirmaciones",
        "sections": [
          {
            "id": "ch08-l10-s0",
            "title": "Afirmaciones",
            "content": [
              {
                "type": "paragraph",
                "content": "Las <em>afirmaciones</em> son verificaciones dentro de un programa que aseguran que algo es como se supone que debe ser. Se utilizan no para manejar situaciones que pueden surgir en la operación normal, sino para encontrar errores de programación."
              },
              {
                "type": "paragraph",
                "content": "Si, por ejemplo, se describe <code>primerElemento</code> como una función que nunca debería ser llamada en arrays vacíos, podríamos escribirla de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "Ahora, en lugar de devolver silenciosamente <code>undefined</code> (que es lo que obtienes al leer una propiedad de un array que no existe), esto hará que tu programa falle ruidosamente tan pronto como lo uses incorrectamente. Esto hace que sea menos probable que tales errores pasen desapercibidos y más fácil encontrar su causa cuando ocurran."
              }
            ]
          },
          {
            "id": "ch08-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "No recomiendo intentar escribir afirmaciones para cada tipo de entrada incorrecta posible. Eso sería mucho trabajo y llevaría a un código muy ruidoso. Querrás reservarlas para errores que son fáciles de cometer (o que te encuentres cometiendo)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch08-l11",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch08-l11-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Una parte importante de programar es encontrar, diagnosticar y corregir errores. Los problemas pueden ser más fáciles de notar si tienes un conjunto de pruebas automatizadas o agregas afirmaciones a tus programas."
              },
              {
                "type": "paragraph",
                "content": "Los problemas causados por factores fuera del control del programa generalmente deberían ser planificados activamente. A veces, cuando el problema puede ser manejado localmente, los valores de retorno especiales son una buena forma de rastrearlos. De lo contrario, las excepciones pueden ser preferibles."
              },
              {
                "type": "paragraph",
                "content": "Lanzar una excepción provoca que la pila de llamadas se desenrolle hasta el próximo bloque <code>try/catch</code> envolvente o hasta la base de la pila. El valor de la excepción será entregado al bloque <code>catch</code> que la captura, el cual debe verificar que sea realmente el tipo de excepción esperado y luego hacer algo con él. Para ayudar a abordar el flujo de control impredecible causado por las excepciones, se pueden utilizar bloques <code>finally</code> para asegurar que un trozo de código se ejecute <em>siempre</em> cuando un bloque termina."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch08-l12",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch08-l12-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Imagina que tienes una función <code>primitiveMultiply</code> que en el 20 por ciento de los casos multiplica dos números y en el otro 80 por ciento arroja una excepción del tipo <code>MultiplicatorUnitFailure</code>. Escribe una función que envuelva esta función problemática y siga intentando hasta que una llamada tenga éxito, momento en el que devuelva el resultado."
              },
              {
                "type": "paragraph",
                "content": "Asegúrate de manejar solo las excepciones que estás intentando manejar."
              },
              {
                "type": "paragraph",
                "content": "La llamada a <code>primitiveMultiply</code> definitivamente debería ocurrir en un bloque <code>try</code>. El bloque <code>catch</code> correspondiente debería relanzar la excepción cuando no sea una instancia de <code>MultiplicatorUnitFailure</code> y asegurarse de que la llamada se reintente cuando lo sea."
              }
            ]
          },
          {
            "id": "ch08-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para hacer el reintentamiento, puedes usar un bucle que se detenga solo cuando una llamada tiene éxito, como en el ejemplo de <code>look</code> anterior en este capítulo, o usar la recursión y esperar que no tengas una cadena tan larga de fallos que colapse la pila (lo cual es bastante improbable)."
              },
              {
                "type": "paragraph",
                "content": "Considera el siguiente objeto (bastante artificial):"
              },
              {
                "type": "paragraph",
                "content": "Es una caja con una cerradura. Hay un array en la caja, pero solo puedes acceder a él cuando la caja está desbloqueada."
              }
            ]
          },
          {
            "id": "ch08-l12-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe una función llamada <code>withBoxUnlocked</code> que reciba como argumento un valor de función, desbloquee la caja, ejecute la función y luego asegure que la caja esté cerrada de nuevo antes de devolverla, independientemente de si la función de argumento devolvió normalmente o lanzó una excepción."
              },
              {
                "type": "paragraph",
                "content": "Para puntos adicionales, asegúrate de que si llamas a <code>withBoxUnlocked</code> cuando la caja ya está desbloqueada, la caja permanezca desbloqueada."
              },
              {
                "type": "paragraph",
                "content": "En este ejercicio, es posible que desees usar <code>try</code> y <code>finally</code> juntos. Tu función debería desbloquear la caja y luego llamar a la función de argumento desde dentro de un bloque <code>try</code>. El bloque <code>finally</code> después de él debería volver a bloquear la caja."
              }
            ]
          },
          {
            "id": "ch08-l12-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para asegurarte de que no bloquees la caja cuando no estaba bloqueada, verifica su bloqueo al comienzo de la función y desbloquéala y bloquéala solo cuando comenzó bloqueada."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      }
    ]
  },
  {
    "id": "ch09",
    "number": 9,
    "title": "Expresiones regulares",
    "titleEs": "Expresiones regulares",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Algunas personas, cuando se enfrentan a un problema, piensan '¡Ya sé, usaré expresiones regulares!’ Ahora tienen dos problemas....",
    "isProject": false,
    "totalXP": 695,
    "lessons": [
      {
        "id": "ch09-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch09-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Algunas personas, cuando se enfrentan a un problema, piensan '¡Ya sé, usaré expresiones regulares!’ Ahora tienen dos problemas. Jamie Zawinski"
              },
              {
                "type": "blockquote",
                "content": "Cuando cortas en contra de la veta de la madera, se necesita mucha fuerza. Cuando programas en contra de la veta del problema, se necesita mucho código. Master Yuan-Ma, El Libro de la Programación"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Expresiones regulares __ Eloquent JavaScript_files/chapter_picture_9.jpg",
                "alt": "Ilustración de un sistema de ferrocarril que representa la estructura sintáctica de las expresiones regulares"
              },
              {
                "type": "paragraph",
                "content": "Las herramientas y técnicas de programación sobreviven y se propagan de manera caótica y evolutiva. No siempre ganan las mejores o brillantes, sino aquellas que funcionan lo suficientemente bien dentro del nicho correcto o que se integran con otra pieza exitosa de tecnología."
              }
            ]
          },
          {
            "id": "ch09-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En este capítulo, discutiré una de esas herramientas, <em>expresiones regulares</em>. Las expresiones regulares son una forma de describir patrónes en datos de cadena. Forman un pequeño lenguaje separado que es parte de JavaScript y muchos otros lenguajes y sistemas."
              },
              {
                "type": "paragraph",
                "content": "Las expresiones regulares son tanto terriblemente incómodas como extremadamente útiles. Su sintaxis es críptica y la interfaz de programación que JavaScript proporciona para ellas es torpe. Pero son una herramienta poderosa para inspeccionar y procesar cadenas. Comprender adecuadamente las expresiones regulares te hará un programador más efectivo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch09-l1",
        "title": "Creando una expresión regular",
        "sections": [
          {
            "id": "ch09-l1-s0",
            "title": "Creando una expresión regular",
            "content": [
              {
                "type": "paragraph",
                "content": "Una expresión regular es un tipo de objeto. Puede ser construido con el constructor <code>RegExp</code> o escrito como un valor literal al encerrar un patrón entre caracteres de barra diagonal (<code>/</code>)."
              },
              {
                "type": "paragraph",
                "content": "Ambos objetos de expresión regular representan el mismo patrón: un carácter <em>a</em> seguido de un <em>b</em> seguido de un <em>c</em>."
              },
              {
                "type": "paragraph",
                "content": "Cuando se utiliza el constructor <code>RegExp</code>, el patrón se escribe como una cadena normal, por lo que se aplican las reglas habituales para las barras invertidas."
              }
            ]
          },
          {
            "id": "ch09-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La segunda notación, donde el patrón aparece entre caracteres de barra diagonal, trata las barras invertidas de manera un poco diferente. Primero, dado que una barra diagonal termina el patrón, debemos poner una barra invertida antes de cualquier barra diagonal que queramos que sea <em>parte</em> del patrón. Además, las barras invertidas que no forman parte de códigos de caracteres especiales (como <code>\\n</code>) serán <em>preservadas</em>, en lugar de ser ignoradas como lo son en las cadenas, y cambian el significado del patrón. Algunos caracteres, como signos de interrogación y signos de más, tienen significados especiales en las expresiones regulares y deben ser precedidos por una barra invertida si se desea representar el propio carácter."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch09-l2",
        "title": "Pruebas de coincidencias",
        "sections": [
          {
            "id": "ch09-l2-s0",
            "title": "Pruebas de coincidencias",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos de expresiones regulares tienen varios métodos. El más simple es <code>test</code>. Si le pasas una cadena, devolverá un Booleano indicándote si la cadena contiene una coincidencia con el patrón de la expresión."
              },
              {
                "type": "paragraph",
                "content": "Una expresión regular que consiste solo en caracteres no especiales simplemente representa esa secuencia de caracteres. Si <em>abc</em> aparece en cualquier parte de la cadena contra la cual estamos probando (no solo al principio), <code>test</code> devolverá <code>true</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch09-l3",
        "title": "Conjuntos de caracteres",
        "sections": [
          {
            "id": "ch09-l3-s0",
            "title": "Conjuntos de caracteres",
            "content": [
              {
                "type": "paragraph",
                "content": "Descubrir si una cadena contiene <em>abc</em> también se podría hacer con una llamada a <code>indexOf</code>. Las expresiones regulares son útiles porque nos permiten describir patrones más complicados."
              },
              {
                "type": "paragraph",
                "content": "Digamos que queremos hacer coincidir cualquier número. En una expresión regular, poner un conjunto de caracteres entre corchetes hace que esa parte de la expresión coincida con cualquiera de los caracteres entre los corchetes."
              },
              {
                "type": "paragraph",
                "content": "Ambas expresiones siguientes hacen coincidir todas las cadenas que contienen un dígito:"
              }
            ]
          },
          {
            "id": "ch09-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dentro de corchetes, un guion (<code>-</code>) entre dos caracteres se puede usar para indicar un rango de caracteres, donde el orden es determinado por el número del carácter en el Unicode. Los caracteres del 0 al 9 están uno al lado del otro en este orden (códigos 48 a 57), por lo que <code>[0-9]</code> abarca todos ellos y coincide con cualquier dígito."
              },
              {
                "type": "paragraph",
                "content": "Varios grupos comunes de caracteres tienen sus propias abreviaturas incorporadas. Los dígitos son uno de ellos: <code>\\d</code> significa lo mismo que <code>[0-9]</code>."
              },
              {
                "type": "paragraph",
                "content": "Así que podrías hacer coincidir un formato de fecha y hora como 01-30-2003 15:20 con la siguiente expresión:"
              }
            ]
          },
          {
            "id": "ch09-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¡Eso se ve completamente horrible, ¿verdad? La mitad son barras invertidas, produciendo un ruido de fondo que dificulta identificar el patrón expresado. Veremos una versión ligeramente mejorada de esta expresión más adelante."
              },
              {
                "type": "paragraph",
                "content": "Estos códigos de barra invertida también se pueden usar dentro de corchetes. Por ejemplo, <code>[\\d.]</code> significa cualquier dígito o un carácter de punto. Pero el punto en sí, entre corchetes, pierde su significado especial. Lo mismo ocurre con otros caracteres especiales, como <code>+</code>."
              },
              {
                "type": "paragraph",
                "content": "Para <em>invertir</em> un conjunto de caracteres, es decir, expresar que deseas hacer coincidir cualquier carácter <em>excepto</em> los que están en el conjunto, puedes escribir un carácter circunflejo (<code>^</code>) después del corchete de apertura."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l4",
        "title": "Caracteres internacionales",
        "sections": [
          {
            "id": "ch09-l4-s0",
            "title": "Caracteres internacionales",
            "content": [
              {
                "type": "paragraph",
                "content": "Debido a la implementación simplista inicial de JavaScript y al hecho de que este enfoque simplista luego se estableció como comportamiento estándar, las expresiones regulares de JavaScript son bastante simples en lo que respecta a los caracteres que no aparecen en el idioma inglés. Por ejemplo, según las expresiones regulares de JavaScript, un “carácter de palabra” es solo uno de los 26 caracteres del alfabeto latino (mayúsculas o minúsculas), dígitos decimales y, por alguna razón, el guion bajo. Cosas como <em>é</em> o <em>β</em>, que definitivamente son caracteres de palabra, no coincidirán con <code>\\w</code> (y <em>sí</em> coincidirán con <code>\\W</code> en mayúsculas, la categoría de no palabras)."
              },
              {
                "type": "paragraph",
                "content": "Por un extraño accidente histórico, <code>\\s</code> (espacio en blanco) no tiene este problema y coincide con todos los caracteres que el estándar Unicode considera espacios en blanco, incluidos elementos como el espacio sin ruptura y el separador de vocal mongol."
              },
              {
                "type": "paragraph",
                "content": "Es posible usar <code>\\p</code> en una expresión regular para hacer coincidir todos los caracteres a los que el estándar Unicode asigna una propiedad dada. Esto nos permite hacer coincidir cosas como letras de una manera más cosmopolita. Sin embargo, nuevamente debido a la compatibilidad con los estándares originales del lenguaje, estos solo se reconocen cuando se coloca un carácter <code>u</code> (por Unicode) después de la expresión regular."
              }
            ]
          },
          {
            "id": "ch09-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Usar <code>\\w</code> para el procesamiento de texto que puede necesitar manejar texto no inglés (o incluso texto en inglés con palabras prestadas como “cliché\") es una desventaja, ya que no tratará caracteres como \"é\" como letras. Aunque tienden a ser un poco más verbosos, los grupos de propiedades <code>\\p</code> son más robustos."
              },
              {
                "type": "paragraph",
                "content": "Por otro lado, si estás haciendo coincidir números para hacer algo con ellos, a menudo querrás usar <code>\\d</code> para dígitos, ya que convertir caracteres numéricos arbitrarios en un número de JavaScript no es algo que una función como <code>Number</code> pueda hacer por ti."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch09-l5",
        "title": "Repetir partes de un patrón",
        "sections": [
          {
            "id": "ch09-l5-s0",
            "title": "Repetir partes de un patrón",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora sabemos cómo hacer coincidir un solo dígito. ¿Qué tal si queremos hacer coincidir un número entero, una secuencia de uno o más dígitos?"
              },
              {
                "type": "paragraph",
                "content": "Cuando colocas un signo más (<code>+</code>) después de algo en una expresión regular, indica que el elemento puede repetirse más de una vez. Así, <code>/\\d+/</code> hace coincidir uno o más caracteres de dígitos."
              },
              {
                "type": "paragraph",
                "content": "El asterisco (<code>*</code>) tiene un significado similar pero también permite que el patrón coincida cero veces. Algo con un asterisco después nunca impide que un patrón coincida, simplemente coincidirá cero veces si no puede encontrar ningún texto adecuado para hacer coincidir."
              }
            ]
          },
          {
            "id": "ch09-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un signo de interrogación hace que una parte de un patrón sea <em>opcional</em>, lo que significa que puede ocurrir cero veces o una vez. En el siguiente ejemplo, se permite que el carácter <em>u</em> ocurra, pero el patrón también coincide cuando falta."
              },
              {
                "type": "paragraph",
                "content": "Para indicar que un patrón debe ocurrir un número preciso de veces, utiliza llaves. Colocar <code>{4}</code> después de un elemento, por ejemplo, requiere que ocurra exactamente cuatro veces. También es posible especificar un rango de esta manera: <code>{2,4}</code> significa que el elemento debe ocurrir al menos dos veces y como máximo cuatro veces."
              },
              {
                "type": "paragraph",
                "content": "Aquí tienes otra versión del patrón de fecha y hora que permite días, meses y horas de uno o dos dígitos. También es un poco más fácil de entender."
              }
            ]
          },
          {
            "id": "ch09-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "También puedes especificar rangos abiertos al utilizar llaves omitiendo el número después de la coma. Así, <code>{5,}</code> significa cinco o más veces."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l6",
        "title": "Agrupación de subexpresiones",
        "sections": [
          {
            "id": "ch09-l6-s0",
            "title": "Agrupación de subexpresiones",
            "content": [
              {
                "type": "paragraph",
                "content": "Para usar un operador como <code>*</code> o <code>+</code> en más de un elemento a la vez, debes utilizar paréntesis. Una parte de una expresión regular que está encerrada entre paréntesis cuenta como un solo elemento en lo que respecta a los operadores que le siguen."
              },
              {
                "type": "paragraph",
                "content": "Los primeros y segundos caracteres <code>+</code> aplican solo al segundo <em>o</em> en <em>boo</em> y <em>hoo</em>, respectivamente. El tercer <code>+</code> se aplica a todo el grupo <code>(hoo+)</code>, haciendo coincidir una o más secuencias como esa."
              },
              {
                "type": "paragraph",
                "content": "La <code>i</code> al final de la expresión en el ejemplo hace que esta expresión regular ignore mayúsculas y minúsculas, lo que le permite hacer coincidir la <em>B</em> mayúscula en la cadena de entrada, aunque el patrón en sí está completamente en minúsculas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch09-l7",
        "title": "Coincidencias y grupos",
        "sections": [
          {
            "id": "ch09-l7-s0",
            "title": "Coincidencias y grupos",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>test</code> es la forma más simple de hacer coincidir una expresión regular. Solo te indica si hubo coincidencia y nada más. Las expresiones regulares también tienen un método <code>exec</code> (ejecutar) que devolverá <code>null</code> si no se encontró ninguna coincidencia y devolverá un objeto con información sobre la coincidencia en caso contrario."
              },
              {
                "type": "paragraph",
                "content": "Un objeto devuelto por <code>exec</code> tiene una propiedad de <code>index</code> que nos dice <em>dónde</em> en la cadena comienza la coincidencia exitosa. Aparte de eso, el objeto parece (y de hecho es) un array de strings, cuyo primer elemento es la cadena que coincidió. En el ejemplo anterior, esta es la secuencia de dígitos que estábamos buscando."
              },
              {
                "type": "paragraph",
                "content": "Los valores de tipo string tienen un método <code>match</code> que se comporta de manera similar."
              }
            ]
          },
          {
            "id": "ch09-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando la expresión regular contiene subexpresiones agrupadas con paréntesis, el texto que coincidió con esos grupos también aparecerá en el array. La coincidencia completa es siempre el primer elemento. El siguiente elemento es la parte coincidente con el primer grupo (el que tiene el paréntesis de apertura primero en la expresión), luego el segundo grupo, y así sucesivamente."
              },
              {
                "type": "paragraph",
                "content": "Cuando un grupo no termina coincidiendo en absoluto (por ejemplo, cuando está seguido por un signo de pregunta), su posición en el array de salida contendrá <code>undefined</code>. Y cuando un grupo coincide múltiples veces (por ejemplo, cuando está seguido por un <code>+</code>), solo la última coincidencia termina en el array."
              },
              {
                "type": "paragraph",
                "content": "Si quieres utilizar paréntesis puramente para agrupar, sin que aparezcan en el array de coincidencias, puedes colocar <code>?:</code> después del paréntesis de apertura."
              }
            ]
          },
          {
            "id": "ch09-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los grupos pueden ser útiles para extraer partes de una cadena. Si no solo queremos verificar si una cadena contiene una fecha sino también extraerla y construir un objeto que la represente, podemos envolver paréntesis alrededor de los patrones de dígitos y seleccionar directamente la fecha del resultado de <code>exec</code>."
              },
              {
                "type": "paragraph",
                "content": "Pero primero haremos un breve desvío, en el que discutiremos la forma incorporada de representar fechas y horas en JavaScript."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l8",
        "title": "La clase Date",
        "sections": [
          {
            "id": "ch09-l8-s0",
            "title": "La clase Date",
            "content": [
              {
                "type": "paragraph",
                "content": "JavaScript tiene una clase estándar para representar fechas—o, más bien, puntos en tiempo. Se llama <code>Date</code>. Si simplemente creas un objeto de fecha usando <code>new</code>, obtendrás la fecha y hora actuales."
              },
              {
                "type": "paragraph",
                "content": "También puedes crear un objeto para un momento específico."
              },
              {
                "type": "paragraph",
                "content": "JavaScript utiliza una convención donde los números de mes empiezan en cero (por lo que diciembre es 11), pero los números de día comienzan en uno. Esto es confuso y tonto. Ten cuidado."
              }
            ]
          },
          {
            "id": "ch09-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los últimos cuatro argumentos (horas, minutos, segundos y milisegundos) son opcionales y se consideran cero cuando no se proporcionan."
              },
              {
                "type": "paragraph",
                "content": "Las marcas de tiempo se almacenan como el número de milisegundos desde el comienzo de 1970, en UTC (zona horaria). Esto sigue una convención establecida por “tiempo de Unix”, que fue inventado alrededor de esa época. Puedes usar números negativos para tiempos antes de 1970. El método <code>getTime</code> en un objeto de fecha retorna este número. Es grande, como te puedes imaginar."
              },
              {
                "type": "paragraph",
                "content": "Si le proporcionas un único argumento al constructor <code>Date</code>, ese argumento se tratará como un recuento de milisegundos. Puedes obtener el recuento actual de milisegundos creando un nuevo objeto <code>Date</code> y llamando a <code>getTime</code> en él o llamando a la función <code>Date.now</code>."
              }
            ]
          },
          {
            "id": "ch09-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos de fecha proporcionan métodos como <code>getFullYear</code>, <code>getMonth</code>, <code>getDate</code>, <code>getHours</code>, <code>getMinutes</code> y <code>getSeconds</code> para extraer sus componentes. Además de <code>getFullYear</code>, también existe <code>getYear</code>, que te da el año menos 1900 (<code>98</code> o <code>119</code>) y es en su mayoría inútil."
              },
              {
                "type": "paragraph",
                "content": "Poniendo paréntesis alrededor de las partes de la expresión que nos interesan, podemos crear un objeto de fecha a partir de una cadena."
              },
              {
                "type": "paragraph",
                "content": "La vinculación <code>_</code> (guion bajo) se ignora y se utiliza solo para omitir el elemento de coincidencia completa en el array devuelto por <code>exec</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l9",
        "title": "Límites y anticipación",
        "sections": [
          {
            "id": "ch09-l9-s0",
            "title": "Límites y anticipación",
            "content": [
              {
                "type": "paragraph",
                "content": "Desafortunadamente, <code>getDate</code> también extraerá felizmente una fecha de la cadena <code>\"100-1-30000\"</code>. Una coincidencia puede ocurrir en cualquier parte de la cadena, por lo que en este caso, simplemente empezará en el segundo carácter y terminará en el antepenúltimo carácter."
              },
              {
                "type": "paragraph",
                "content": "Si queremos asegurar que la coincidencia abarque toda la cadena, podemos agregar los marcadores <code>^</code> y <code>$</code>. El circunflejo coincide con el inicio de la cadena de entrada, mientras que el signo de dólar coincide con el final. Por lo tanto, <code>/^\\d+$/</code> coincide con una cadena que consiste completamente de uno o más dígitos, <code>/^!/</code> coincide con cualquier cadena que comience con un signo de exclamación y <code>/x^/</code> no coincide con ninguna cadena (no puede haber una <em>x</em> antes del inicio de la cadena)."
              },
              {
                "type": "paragraph",
                "content": "También existe un marcador <code>\\b</code>, que coincide con los “límites de palabra”, posiciones que tienen un carácter de palabra a un lado y un carácter que no es de palabra al otro. Desafortunadamente, estos utilizan el mismo concepto simplista de caracteres de palabra que <code>\\w</code>, por lo que no son muy confiables."
              }
            ]
          },
          {
            "id": "ch09-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ten en cuenta que estos marcadores no coinciden con ningún carácter real. Simplemente aseguran que se cumpla una condición determinada en el lugar donde aparecen en el patrón."
              },
              {
                "type": "paragraph",
                "content": "Las pruebas de <em>mirar adelante</em> hacen algo similar. Proporcionan un patrón y harán que la coincidencia falle si la entrada no coincide con ese patrón, pero en realidad no mueven la posición de la coincidencia hacia adelante. Se escriben entre <code>(?=</code> y <code>)</code>."
              },
              {
                "type": "paragraph",
                "content": "Observa cómo la <code>e</code> en el primer ejemplo es necesaria para coincidir, pero no forma parte de la cadena coincidente. La notación <code>(?! )</code> expresa un mirar adelante <em>negativo</em>. Esto solo coincide si el patrón entre paréntesis <em>no</em> coincide, lo que hace que el segundo ejemplo solo coincida con caracteres “a” que no tienen un espacio después de ellos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch09-l10",
        "title": "Patrones de elección",
        "sections": [
          {
            "id": "ch09-l10-s0",
            "title": "Patrones de elección",
            "content": [
              {
                "type": "paragraph",
                "content": "Digamos que queremos saber si un texto contiene no solo un número, sino un número seguido de una de las palabras <em>pig</em>, <em>cow</em> o <em>chicken</em>, o cualquiera de sus formas en plural."
              },
              {
                "type": "paragraph",
                "content": "Podríamos escribir tres expresiones regulares y probarlas sucesivamente, pero hay una forma más sencilla. El carácter de barra vertical (<code>|</code>) denota una elección entre el patrón a su izquierda y el patrón a su derecha. Así que puedo decir esto:"
              },
              {
                "type": "paragraph",
                "content": "Los paréntesis se pueden utilizar para limitar la parte del patrón a la que se aplica el operador de barra, y puedes colocar varios de estos operadores uno al lado del otro para expresar una elección entre más de dos alternativas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch09-l11",
        "title": "La mecánica de la coincidencia",
        "sections": [
          {
            "id": "ch09-l11-s0",
            "title": "La mecánica de la coincidencia",
            "content": [
              {
                "type": "paragraph",
                "content": "Conceptualmente, cuando utilizas <code>exec</code> o <code>test</code>, el motor de expresiones regulares busca una coincidencia en tu cadena tratando de ajustar primero la expresión desde el comienzo de la cadena, luego desde el segundo carácter, y así sucesivamente, hasta que encuentra una coincidencia o llega al final de la cadena. Devolverá la primera coincidencia que encuentre o fracasará en encontrar cualquier coincidencia."
              },
              {
                "type": "paragraph",
                "content": "Para hacer la coincidencia real, el motor trata a una expresión regular algo así como un diagrama de flujo. Este es el diagrama para la expresión de ganado en el ejemplo anterior:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Expresiones regulares __ Eloquent JavaScript_files/re_pigchickens.svg",
                "alt": "Diagrama de ferrocarril que primero pasa por un recuadro etiquetado &#39;dígito&#39;, que tiene un bucle que regresa desde después de él a antes de él, y luego un recuadro para un carácter de espacio. Después de eso, el ferrocarril se divide en tres, pasando por cuadros para &#39;pig&#39;, &#39;cow&#39; y &#39;chicken&#39;. Después de estos, se reúne de nuevo y pasa por un cuadro etiquetado &#39;s&#39;, que, al ser opcional, también tiene un ferrocarril que lo pasa por alto. Finalmente, la línea llega al estado de aceptación."
              },
              {
                "type": "paragraph",
                "content": "Nuestra expresión coincide si podemos encontrar un camino desde el lado izquierdo del diagrama hasta el lado derecho. Mantenemos una posición actual en la cadena, y cada vez que avanzamos a través de un recuadro, verificamos que la parte de la cadena después de nuestra posición actual coincida con ese recuadro."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch09-l12",
        "title": "Retroceso",
        "sections": [
          {
            "id": "ch09-l12-s0",
            "title": "Retroceso",
            "content": [
              {
                "type": "paragraph",
                "content": "La expresión regular <code>/<wbr>^([01]+b|[\\da-f]+h|\\d+)$/<wbr></code> coincide ya sea con un número binario seguido de una <em>b</em>, un número hexadecimal (es decir, base 16, con las letras <em>a</em> a <em>f</em> representando los dígitos del 10 al 15) seguido de un <em>h</em>, o un número decimal regular sin un carácter de sufijo. Este es el diagrama correspondiente:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Expresiones regulares __ Eloquent JavaScript_files/re_number.svg",
                "alt": "Diagrama de ferrocarril para la expresión regular &#39;^([01]+b|\\d+|[\\da-f]+h)$&#39;"
              },
              {
                "type": "paragraph",
                "content": "Al coincidir con esta expresión, a menudo sucede que se ingresa por la rama superior (binaria) aunque la entrada en realidad no contenga un número binario. Al coincidir con la cadena <code>\"103\"</code>, por ejemplo, solo se aclara en el 3 que estamos en la rama incorrecta. La cadena <em>coincide</em> con la expresión, simplemente no con la rama en la que nos encontramos actualmente."
              }
            ]
          },
          {
            "id": "ch09-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Entonces, el coincidente <em>retrocede</em>. Al ingresar a una rama, recuerda su posición actual (en este caso, al principio de la cadena, justo después del primer cuadro de límite en el diagrama) para poder retroceder y probar otra rama si la actual no funciona. Para la cadena <code>\"103\"</code>, después de encontrar el carácter 3, intentará la rama para los números hexadecimales, lo cual también falla porque no hay un <em>h</em> después del número. Entonces intenta la rama para los números decimales. Esta encaja, y se informa una coincidencia después de todo."
              },
              {
                "type": "paragraph",
                "content": "El coincidente se detiene tan pronto como encuentra una coincidencia completa. Esto significa que si varias ramas podrían coincidir potencialmente con una cadena, solo se usa la primera (ordenada por dónde aparecen las ramas en la expresión regular)."
              },
              {
                "type": "paragraph",
                "content": "El retroceso también ocurre para los operadores de repetición como + y <code>*</code>. Si coincide con <code>/^.*x/</code> contra <code>\"abcxe\"</code>, la parte <code>.*</code> intentará primero consumir toda la cadena. Luego el motor se dará cuenta de que necesita una <em>x</em> para que coincida con el patrón. Dado que no hay una <em>x</em> más allá del final de la cadena, el operador estrella intentará coincidir con un carácter menos. Pero el coincidente no encuentra una <em>x</em> después de <code>abcx</code> tampoco, por lo que retrocede nuevamente, coincidiendo con el operador estrella solo con <code>abc</code>. <em>Ahora</em> encuentra una <em>x</em> donde la necesita y reporta una coincidencia exitosa desde las posiciones 0 a 4."
              }
            ]
          },
          {
            "id": "ch09-l12-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Es posible escribir expresiones regulares que realizarán <em>mucho</em> retroceso. Este problema ocurre cuando un patrón puede coincidir con una parte de la entrada de muchas formas diferentes. Por ejemplo, si nos confundimos al escribir una expresión regular para los números binarios, podríamos escribir accidentalmente algo como <code>/([01]+)+b/</code>."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Expresiones regulares __ Eloquent JavaScript_files/re_slow.svg",
                "alt": "Diagrama de ferrocarril para la expresión regular &#39;([01]+)+b&#39;"
              },
              {
                "type": "paragraph",
                "content": "Si intenta hacer coincidir una serie larga de ceros y unos sin un caracter <em>b</em> al final, el analizador primero pasa por el bucle interno hasta que se queda sin dígitos. Luego se da cuenta de que no hay <em>b</em>, por lo que retrocede una posición, pasa por el bucle externo una vez y vuelve a darse por vencido, intentando retroceder nuevamente fuera del bucle interno. Continuará intentando todas las rutas posibles a través de estos dos bucles. Esto significa que la cantidad de trabajo se <em>duplica</em> con cada carácter adicional. Incluso con apenas unas pocas docenas de caracteres, la coincidencia resultante tomará prácticamente para siempre."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l13",
        "title": "El método replace",
        "sections": [
          {
            "id": "ch09-l13-s0",
            "title": "El método replace",
            "content": [
              {
                "type": "paragraph",
                "content": "Los valores de cadena tienen un método <code>replace</code> que se puede utilizar para reemplazar parte de la cadena con otra cadena."
              },
              {
                "type": "paragraph",
                "content": "El primer argumento también puede ser una expresión regular, en cuyo caso se reemplaza la primera coincidencia de la expresión regular. Cuando se agrega una opción <code>g</code> (para <em>global</em>) después de la expresión regular, <em>todas</em> las coincidencias en la cadena serán reemplazadas, no solo la primera."
              },
              {
                "type": "paragraph",
                "content": "El verdadero poder de usar expresiones regulares con <code>replace</code> proviene del hecho de que podemos hacer referencia a grupos coincidentes en la cadena de reemplazo. Por ejemplo, digamos que tenemos una cadena larga que contiene los nombres de personas, un nombre por línea, en el formato <code>Apellido, Nombre</code>. Si queremos intercambiar estos nombres y eliminar la coma para obtener un formato <code>Nombre Apellido</code>, podemos usar el siguiente código:"
              }
            ]
          },
          {
            "id": "ch09-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los <code>$1</code> y <code>$2</code> en la cadena de reemplazo se refieren a los grupos entre paréntesis en el patrón. <code>$1</code> es reemplazado por el texto que coincidió con el primer grupo, <code>$2</code> por el segundo, y así sucesivamente, hasta <code>$9</code>. Toda la coincidencia se puede referenciar con <code>$&amp;</code>."
              },
              {
                "type": "paragraph",
                "content": "Es posible pasar una función, en lugar de una cadena, como segundo argumento a <code>replace</code>. Para cada reemplazo, la función se llamará con los grupos coincidentes (así como la coincidencia completa) como argumentos, y su valor de retorno se insertará en la nueva cadena."
              },
              {
                "type": "paragraph",
                "content": "Aquí tienes un ejemplo:"
              }
            ]
          },
          {
            "id": "ch09-l13-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esta función toma una cadena, encuentra todas las ocurrencias de un número seguido de una palabra alfanumérica, y devuelve una cadena que tiene una cantidad menos de cada una de esas ocurrencias."
              },
              {
                "type": "paragraph",
                "content": "El grupo <code>(\\d+)</code> termina siendo el argumento <code>amount</code> de la función, y el grupo <code>(\\p{L}+)</code> se asigna a <code>unit</code>. La función convierte <code>amount</code> a un número, lo cual siempre funciona ya que coincide con <code>\\d+</code>, y realiza algunos ajustes en caso de que solo quede uno o ninguno."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l14",
        "title": "Avaricia",
        "sections": [
          {
            "id": "ch09-l14-s0",
            "title": "Avaricia",
            "content": [
              {
                "type": "paragraph",
                "content": "Es posible usar <code>replace</code> para escribir una función que elimine todos los comentarios de un fragmento de código JavaScript. Aquí tienes un primer intento:"
              },
              {
                "type": "paragraph",
                "content": "La parte antes del operador <em>or</em> coincide con dos caracteres de barra seguidos por cualquier cantidad de caracteres que no sean de nueva línea. La parte de comentarios de varias líneas es más compleja. Utilizamos <code>[^]</code> (cualquier carácter que no esté en el conjunto vacío de caracteres) como una forma de coincidir con cualquier carácter. No podemos usar simplemente un punto aquí porque los comentarios de bloque pueden continuar en una nueva línea, y el carácter de punto no coincide con caracteres de nueva línea."
              },
              {
                "type": "paragraph",
                "content": "Pero la salida para la última línea parece haber salido mal. ¿Por qué?"
              }
            ]
          },
          {
            "id": "ch09-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La parte <code>[^]*</code> de la expresión, como describí en la sección sobre retroceso, primero intentará coincidir con todo lo que pueda. Si esto hace que la siguiente parte del patrón falle, el coincidente retrocede un carácter y vuelve a intentar desde ahí. En el ejemplo, el coincidente intenta primero coincidir con el resto completo de la cadena y luego retrocede desde allí. Encontrará una ocurrencia de <code>*/</code> después de retroceder cuatro caracteres y coincidirá con eso. Esto no es lo que queríamos, la intención era coincidir con un único comentario, no llegar hasta el final del código y encontrar el final del último comentario de bloque."
              },
              {
                "type": "paragraph",
                "content": "Debido a este comportamiento, decimos que los operadores de repetición (<code>+</code>, <code>*</code>, <code>?</code>, y <code>{}</code>) son <em>avariciosos</em>, lo que significa que coinciden con todo lo que pueden y retroceden desde allí. Si colocas un signo de interrogación después de ellos (<code>+?</code>, <code>*?</code>, <code>??</code>, <code>{}?</code>), se vuelven no avariciosos y comienzan coincidiendo con la menor cantidad posible, coincidiendo más solo cuando el patrón restante no encaja con la coincidencia más pequeña."
              },
              {
                "type": "paragraph",
                "content": "Y eso es exactamente lo que queremos en este caso. Al hacer que el asterisco coincida con la menor cantidad de caracteres que nos lleva a <code>*/</code>, consumimos un comentario de bloque y nada más."
              }
            ]
          },
          {
            "id": "ch09-l14-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos errors en programas de expresión regular pueden rastrearse hasta el uso no intencionado de un operador avaricioso donde uno no avaricioso funcionaría mejor. Cuando uses un operador de repetición, prefiere la variante no avariciosa."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l15",
        "title": "Creación dinámica de objetos RegExp",
        "sections": [
          {
            "id": "ch09-l15-s0",
            "title": "Creación dinámica de objetos RegExp",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay casos en los que es posible que no sepas el patrón exacto que necesitas para hacer coincidir cuando estás escribiendo tu código. Digamos que quieres probar el nombre de usuario en un fragmento de texto. Puedes construir una cadena y usar el <code>constructor</code> <code>RegExp</code> en ello. Aquí tienes un ejemplo:"
              },
              {
                "type": "paragraph",
                "content": "Al crear la parte <code>\\s</code> de la cadena, tenemos que usar dos barras invertidas porque las estamos escribiendo en una cadena normal, no en una expresión regular entre barras. El segundo argumento del constructor <code>RegExp</code> contiene las opciones para la expresión regular, en este caso, <code>\"gi\"</code> para global e insensible a mayúsculas y minúsculas."
              },
              {
                "type": "paragraph",
                "content": "Pero ¿qué pasa si el nombre es <code>\"dea+hl[]rd\"</code> porque nuestro usuario es un adolescente nerd? Eso resultaría en una expresión regular absurda que en realidad no coincidiría con el nombre del usuario."
              }
            ]
          },
          {
            "id": "ch09-l15-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para solucionar esto, podemos agregar barras invertidas antes de cualquier carácter que tenga un significado especial."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch09-l16",
        "title": "El método search",
        "sections": [
          {
            "id": "ch09-l16-s0",
            "title": "El método search",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>indexOf</code> en las cadenas no puede ser llamado con una expresión regular. Pero hay otro método, <code>search</code>, que espera una expresión regular. Al igual que <code>indexOf</code>, devuelve el primer índice en el que se encontró la expresión, o -1 cuando no se encontró."
              },
              {
                "type": "paragraph",
                "content": "Desafortunadamente, no hay una forma de indicar que la coincidencia debería comenzar en un offset dado (como se puede hacer con el segundo argumento de <code>indexOf</code>), lo cual a menudo sería útil."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch09-l17",
        "title": "La propiedad lastIndex",
        "sections": [
          {
            "id": "ch09-l17-s0",
            "title": "La propiedad lastIndex",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>exec</code> de manera similar no proporciona una forma conveniente de comenzar a buscar desde una posición dada en la cadena. Pero sí proporciona una forma <em>in</em>conveniente."
              },
              {
                "type": "paragraph",
                "content": "Los objetos de expresión regular tienen propiedades. Una de esas propiedades es <code>source</code>, que contiene la cadena de la que se creó la expresión. Otra propiedad es <code>lastIndex</code>, que controla, en algunas circunstancias limitadas, desde dónde comenzará la siguiente coincidencia."
              },
              {
                "type": "paragraph",
                "content": "Estas circunstancias implican que la expresión regular debe tener la opción global (<code>g</code>) o pegajosa (<code>y</code>) activada, y la coincidencia debe ocurrir a través del método <code>exec</code>. Nuevamente, una solución menos confusa habría sido simplemente permitir que se pase un argumento adicional a <code>exec</code>, pero la confusión es una característica esencial de la interfaz de expresiones regulares de JavaScript."
              }
            ]
          },
          {
            "id": "ch09-l17-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si la coincidencia tuvo éxito, la llamada a <code>exec</code> actualiza automáticamente la propiedad <code>lastIndex</code> para que apunte después de la coincidencia. Si no se encontró ninguna coincidencia, <code>lastIndex</code> se restablece a cero, que es también el valor que tiene en un objeto de expresión regular recién construido."
              },
              {
                "type": "paragraph",
                "content": "La diferencia entre las opciones global y sticky es que, cuando se habilita sticky, la coincidencia solo se producirá si comienza directamente en <code>lastIndex</code>, mientras que con global se buscará una posición donde pueda comenzar una coincidencia."
              },
              {
                "type": "paragraph",
                "content": "Al usar un valor de expresión regular compartido para múltiples llamadas a <code>exec</code>, estas actualizaciones automáticas a la propiedad <code>lastIndex</code> pueden causar problemas. Es posible que tu expresión regular comience accidentalmente en un índice que quedó de una llamada previa."
              }
            ]
          },
          {
            "id": "ch09-l17-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Otro efecto interesante de la opción global es que cambia la forma en que funciona el método <code>match</code> en las cadenas. Cuando se llama con una expresión global, en lugar de devolver una matriz similar a la devuelta por <code>exec</code>, <code>match</code> encontrará <em>todas</em> las coincidencias del patrón en la cadena y devolverá una matriz que contiene las cadenas coincidentes."
              },
              {
                "type": "paragraph",
                "content": "Así que ten cuidado con las expresiones regulares globales. Los casos en los que son necesarias, como las llamadas a <code>replace</code> y los lugares donde quieres usar explícitamente <code>lastIndex</code>, son típicamente los únicos lugares donde las deseas utilizar."
              },
              {
                "type": "paragraph",
                "content": "Algo común que se hace es encontrar todas las coincidencias de una expresión regular en una cadena. Podemos hacer esto usando el método <code>matchAll</code>."
              }
            ]
          },
          {
            "id": "ch09-l17-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este método devuelve una matriz de matrices de coincidencias. La expresión regular que se le proporciona <em>debe</em> tener <code>g</code> habilitado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch09-l18",
        "title": "Analizando un archivo INI",
        "sections": [
          {
            "id": "ch09-l18-s0",
            "title": "Analizando un archivo INI",
            "content": [
              {
                "type": "paragraph",
                "content": "Para concluir el capítulo, analizaremos un problema que requiere expresiones regulares. Imagina que estamos escribiendo un programa para recopilar automáticamente información sobre nuestros enemigos desde Internet. (En realidad, no escribiremos ese programa aquí, solo la parte que lee el archivo de configuración. Lo siento.) El archivo de configuración se ve así:"
              },
              {
                "type": "paragraph",
                "content": "Las reglas exactas para este formato (que es un formato ampliamente utilizado, generalmente llamado un archivo <em>INI</em>) son las siguientes:"
              },
              {
                "type": "list",
                "content": [
                  "Las líneas en blanco y las líneas que comienzan con punto y coma son ignoradas.",
                  "Las líneas envueltas en [ y ] inician una nueva sección.",
                  "Las líneas que contienen un identificador alfanumérico seguido de un caracter = agregan una configuración a la sección actual.",
                  "Cualquier otra cosa es inválida."
                ]
              },
              {
                "type": "paragraph",
                "content": "Nuestra tarea es convertir una cadena como esta en un objeto cuyas propiedades contienen cadenas para las configuraciones escritas antes del primer encabezado de sección y subobjetos para las secciones, con esos subobjetos conteniendo las configuraciones de la sección."
              }
            ]
          },
          {
            "id": "ch09-l18-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dado que el formato debe procesarse línea por línea, dividir el archivo en líneas separadas es un buen comienzo. Vimos el método <code>split</code> en el Capítulo 4. Sin embargo, algunos sistemas operativos utilizan no solo un carácter de nueva línea para separar líneas sino un carácter de retorno de carro seguido de una nueva línea (<code>\"\\r\\n\"</code>). Dado que el método <code>split</code> también permite una expresión regular como argumento, podemos usar una expresión regular como <code>/\\r?\\n/</code> para dividir de una manera que permita tanto <code>\"\\n\"</code> como <code>\"\\r\\n\"</code> entre líneas."
              },
              {
                "type": "paragraph",
                "content": "El código recorre las líneas del archivo y construye un objeto. Las propiedades en la parte superior se almacenan directamente en ese objeto, mientras que las propiedades encontradas en secciones se almacenan en un objeto de sección separado. El enlace <code>section</code> apunta al objeto para la sección actual."
              },
              {
                "type": "paragraph",
                "content": "Hay dos tipos de líneas significativas: encabezados de sección o líneas de propiedades. Cuando una línea es una propiedad regular, se almacena en la sección actual. Cuando es un encabezado de sección, se crea un nuevo objeto de sección y <code>section</code> se establece para apuntar a él."
              }
            ]
          },
          {
            "id": "ch09-l18-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Observa el uso recurrente de <code>^</code> y <code>$</code> para asegurarse de que la expresión coincida con toda la línea, no solo parte de ella. Dejarlos fuera resulta en un código que funciona en su mayor parte pero se comporta de manera extraña para algunas entradas, lo que puede ser un error difícil de rastrear."
              },
              {
                "type": "paragraph",
                "content": "```El patrón <code>if (match = string.<wbr>match(.<wbr>.<wbr>.<wbr>))</code> hace uso del hecho de que el valor de una expresión de asignación (<code>=</code>) es el valor asignado. A menudo no estás seguro de que tu llamada a <code>match</code> tendrá éxito, por lo que solo puedes acceder al objeto resultante dentro de una declaración <code>if</code> que comprueba esto. Para no romper la agradable cadena de formas de <code>else if</code>, asignamos el resultado de la coincidencia a un enlace y usamos inmediatamente esa asignación como la prueba para la declaración <code>if</code>."
              },
              {
                "type": "paragraph",
                "content": "Si una línea no es un encabezado de sección o una propiedad, la función verifica si es un comentario o una línea vacía usando la expresión <code>/^\\s*(;|$)/</code> para hacer coincidir líneas que solo contienen espacio o espacio seguido de un punto y coma (haciendo que el resto de la línea sea un comentario). Cuando una línea no coincide con ninguna de las formas esperadas, la función lanza una excepción."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch09-l19",
        "title": "Unidades de código y caracteres",
        "sections": [
          {
            "id": "ch09-l19-s0",
            "title": "Unidades de código y caracteres",
            "content": [
              {
                "type": "paragraph",
                "content": "Otro error de diseño que se ha estandarizado en las expresiones regulares de JavaScript es que, por defecto, operadores como <code>.</code> o <code>?</code> trabajan en unidades de código, como se discute en el Capítulo 5, no en caracteres reales. Esto significa que los caracteres que están compuestos por dos unidades de código se comportan de manera extraña."
              },
              {
                "type": "paragraph",
                "content": "El problema es que el 🍎 en la primera línea se trata como dos unidades de código, y la parte <code>{3}</code> se aplica solo al segundo. Del mismo modo, el punto coincidirá con una sola unidad de código, no con las dos que componen la rosa emoji."
              },
              {
                "type": "paragraph",
                "content": "Debes agregar la opción <code>u</code> (Unicode) a tu expresión regular para que trate correctamente este tipo de caracteres."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch09-l20",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch09-l20-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Las expresiones regulares son objetos que representan patrones en cadenas. Utilizan su propio lenguaje para expresar estos patrones."
              },
              {
                "type": "paragraph",
                "content": "Una expresión regular tiene un método <code>test</code> para comprobar si una cadena dada coincide con ella. También tiene un método <code>exec</code> que, cuando se encuentra una coincidencia, devuelve un array que contiene todos los grupos coincidentes. Dicho array tiene una propiedad <code>index</code> que indica dónde empezó la coincidencia.Las cadenas tienen un método <code>match</code> para compararlas con una expresión regular y un método <code>search</code> para buscar una, devolviendo solo la posición de inicio de la coincidencia. Su método <code>replace</code> puede reemplazar coincidencias de un patrón con una cadena o función de reemplazo."
              },
              {
                "type": "paragraph",
                "content": "Las expresiones regulares pueden tener opciones, que se escriben después de la barra de cierre. La opción <code>i</code> hace que la coincidencia no distinga entre mayúsculas y minúsculas. La opción <code>g</code> hace que la expresión sea <em>global</em>, lo que, entre otras cosas, hace que el método <code>replace</code> reemplace todas las instancias en lugar de solo la primera. La opción <code>y</code> la hace persistente, lo que significa que no buscará por delante ni omitirá parte de la cadena al buscar una coincidencia. La opción <code>u</code> activa el modo Unicode, que habilita la sintaxis <code>\\p</code> y soluciona varios problemas en torno al manejo de caracteres que ocupan dos unidades de código."
              }
            ]
          },
          {
            "id": "ch09-l20-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las expresiones regulares son una herramienta afilada con un mango incómodo. Simplifican enormemente algunas tareas, pero pueden volverse rápidamente ingobernables cuando se aplican a problemas complejos. Parte de saber cómo usarlas es resistir la tentación de intentar forzar cosas que no pueden expresarse de forma clara en ellas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch09-l21",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch09-l21-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Es casi inevitable que, al trabajar en estos ejercicios, te sientas confundido y frustrado por el comportamiento inexplicable de algunas expresiones regulares. A veces ayuda introducir tu expresión en una herramienta en línea como <em>debuggex.com</em> para ver si su visualización corresponde a lo que pretendías y para experimentar con la forma en que responde a diferentes cadenas de entrada."
              },
              {
                "type": "paragraph",
                "content": "<em>Code golf</em> es un término utilizado para el juego de intentar expresar un programa en particular con la menor cantidad de caracteres posible. De manera similar, <em>regexp golf</em> es la práctica de escribir una expresión regular lo más pequeña posible para que coincida con un patrón dado, y <em>solo</em> ese patrón."
              },
              {
                "type": "paragraph",
                "content": "Para cada uno de los siguientes elementos, escribe una expresión regular para comprobar si el patrón dado ocurre en una cadena. La expresión regular debe coincidir solo con cadenas que contengan el patrón. Cuando tu expresión funcione, verifica si puedes hacerla más pequeña."
              }
            ]
          },
          {
            "id": "ch09-l21-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "list",
                "content": [
                  "car y cat",
                  "pop y prop",
                  "ferret, ferry y ferrari",
                  "Cualquier palabra que termine en ious",
                  "Un carácter de espacio en blanco seguido de un punto, coma, dos puntos o punto y coma",
                  "Una palabra con más de seis letras",
                  "Una palabra sin la letra e (o E)"
                ]
              },
              {
                "type": "paragraph",
                "content": "Consulta la tabla en el resumen del capítulo para obtener ayuda. Prueba cada solución con algunas cadenas de prueba."
              },
              {
                "type": "paragraph",
                "content": "Imagina que has escrito una historia y usaste comillas simples single-quote character para marcar piezas de diálogo. Ahora quieres reemplazar todas las comillas de diálogo con comillas dobles, manteniendo las comillas simples utilizadas en contracciones como <em>aren’t</em>."
              }
            ]
          },
          {
            "id": "ch09-l21-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Piensa en un patrón que distinga estos dos tipos de uso de comillas y crea una llamada al método <code>replace</code> que realice el reemplazo adecuado."
              },
              {
                "type": "paragraph",
                "content": "La solución más obvia es reemplazar solo las comillas que tienen un carácter que no sea una letra en al menos un lado, algo como <code>/\\P{L}'|'\\P{L}/</code>. Pero también debes tener en cuenta el inicio y el final de la línea."
              },
              {
                "type": "paragraph",
                "content": "Además, debes asegurarte de que la sustitución también incluya los caracteres que coincidieron con el patrón <code>\\P{L}</code> para que no se eliminen. Esto se puede hacer envolviéndolos entre paréntesis e incluyendo sus grupos en la cadena de reemplazo (<code>$1</code>, <code>$2</code>). Los grupos que no se emparejen se reemplazarán por nada."
              }
            ]
          },
          {
            "id": "ch09-l21-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe una expresión que coincida solo con los números al estilo de JavaScript. Debe admitir un signo menos <em>o</em> más opcional delante del número, el punto decimal y la notación de exponente—<code>5e-3</code> o <code>1E10</code>—de nuevo con un signo opcional delante del exponente. También ten en cuenta que no es necesario que haya dígitos delante o después del punto, pero el número no puede ser solo un punto. Es decir, <code>.5</code> y <code>5.</code> son números de JavaScript válidos, pero un punto solitario <em>no</em> lo es."
              },
              {
                "type": "paragraph",
                "content": "Primero, no olvides la barra invertida delante del punto."
              },
              {
                "type": "paragraph",
                "content": "Para hacer coincidir el signo opcional delante del número, así como delante del exponente, se puede hacer con <code>[+\\-]?</code> o <code>(\\+|-|)</code> (más, menos, o nada)."
              }
            ]
          },
          {
            "id": "ch09-l21-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La parte más complicada del ejercicio es el problema de hacer coincidir tanto <code>\"5.\"</code> como <code>\".5\"</code> sin hacer coincidir también <code>\".\"</code>. Para esto, una buena solución es usar el operador <code>|</code> para separar los dos casos: uno o más dígitos seguidos opcionalmente por un punto y cero o más dígitos <em>o</em> un punto seguido por uno o más dígitos."
              },
              {
                "type": "paragraph",
                "content": "Finalmente, para hacer que el caso de la <em>e</em> sea insensible a mayúsculas y minúsculas, añade una opción <code>i</code> a la expresión regular o usa <code>[eE]</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      }
    ]
  },
  {
    "id": "ch10",
    "number": 10,
    "title": "Módulos",
    "titleEs": "Módulos",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "Escribe código que sea fácil de borrar, no fácil de extender...",
    "isProject": false,
    "totalXP": 345,
    "lessons": [
      {
        "id": "ch10-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch10-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Escribe código que sea fácil de borrar, no fácil de extender Tef, La programación es terrible"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Módulos __ Eloquent JavaScript_files/chapter_picture_10.jpg",
                "alt": "Ilustración de un edificio complicado construido a partir de piezas modulares"
              },
              {
                "type": "paragraph",
                "content": "Idealmente, un programa tiene una estructura clara y directa. La forma en que funciona es fácil de explicar, y cada parte desempeña un papel bien definido."
              }
            ]
          },
          {
            "id": "ch10-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En la práctica, los programas crecen de forma orgánica. Se añaden piezas de funcionalidad a medida que el programador identifica nuevas necesidades. Mantener un programa de esta manera bien estructurado requiere atención y trabajo constantes. Este es un trabajo que solo dará sus frutos en el futuro, la próxima vez que alguien trabaje en el programa. Por lo tanto, es tentador descuidarlo y permitir que las diversas partes del programa se enreden profundamente."
              },
              {
                "type": "paragraph",
                "content": "Esto causa dos problemas prácticos. Primero, entender un sistema enredado es difícil. Si todo puede afectar a todo lo demás, es difícil ver cualquier pieza en aislamiento. Te ves obligado a construir una comprensión holística de todo el conjunto. Segundo, si deseas utilizar alguna funcionalidad de dicho programa en otra situación, puede ser más fácil reescribirla que intentar desenredarla de su contexto."
              },
              {
                "type": "paragraph",
                "content": "La frase “gran bola de barro” se usa a menudo para tales programas grandes y sin estructura. Todo se une, y al intentar sacar una pieza, todo el conjunto se desintegra y solo logras hacer un desastre."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch10-l1",
        "title": "Programas modulares",
        "sections": [
          {
            "id": "ch10-l1-s0",
            "title": "Programas modulares",
            "content": [
              {
                "type": "paragraph",
                "content": "Los <em>módulos</em> son un intento de evitar estos problemas. Un módulo es una parte de un programa que especifica en qué otras piezas se basa y qué funcionalidad proporciona para que otros módulos la utilicen (su <em>interfaz</em>)."
              },
              {
                "type": "paragraph",
                "content": "Las interfaces de los módulos tienen mucho en común con las interfaces de objetos, como las vimos en el Capítulo 6. Permiten que una parte del módulo esté disponible para el mundo exterior y mantienen el resto privado."
              },
              {
                "type": "paragraph",
                "content": "Pero la interfaz que un módulo proporciona para que otros la utilicen es solo la mitad de la historia. Un buen sistema de módulos también requiere que los módulos especifiquen qué código <em>ellos</em> utilizan de otros módulos. Estas relaciones se llaman <em>dependencias</em>. Si el módulo A utiliza funcionalidad del módulo B, se dice que <em>depende</em> de él. Cuando estas dependencias se especifican claramente en el propio módulo, se pueden utilizar para averiguar qué otros módulos deben estar presentes para poder utilizar un módulo dado y cargar las dependencias automáticamente."
              }
            ]
          },
          {
            "id": "ch10-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando las formas en que los módulos interactúan entre sí son explícitas, un sistema se vuelve más como LEGO, donde las piezas interactúan a través de conectores bien definidos, y menos como barro, donde todo se mezcla con todo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch10-l2",
        "title": "Módulos ES",
        "sections": [
          {
            "id": "ch10-l2-s0",
            "title": "Módulos ES",
            "content": [
              {
                "type": "paragraph",
                "content": "El lenguaje original JavaScript no tenía ningún concepto de un módulo. Todos los scripts se ejecutaban en el mismo ámbito, y acceder a una función definida en otro script se hacía mediante la referencia a las vinculaciones globales creadas por ese script. Esto fomentaba activamente el enredo accidental y difícil de detectar del código e invitaba a problemas como scripts no relacionados que intentaban usar el mismo nombre de vinculación."
              },
              {
                "type": "paragraph",
                "content": "Desde ECMAScript 2015, JavaScript admite dos tipos diferentes de programas. Los <em>scripts</em> se comportan de la manera antigua: sus vinculaciones se definen en el ámbito global y no tienen forma de referenciar directamente otros scripts. Los <em>módulos</em> obtienen su propio ámbito separado y admiten las palabras clave <code>import</code> y <code>export</code>, que no están disponibles en los scripts, para declarar sus dependencias e interfaz. Este sistema de módulos se suele llamar <em>módulos de ES</em> (donde “ES” significa “ECMAScript”)."
              },
              {
                "type": "paragraph",
                "content": "Un programa modular está compuesto por varios de estos módulos, conectados a través de sus importaciones y exportaciones."
              }
            ]
          },
          {
            "id": "ch10-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este ejemplo de módulo convierte entre nombres de días y números (como los devueltos por el método <code>getDay</code> de <code>Date</code>). Define una constante que no forma parte de su interfaz y dos funciones que sí lo son. No tiene dependencias."
              },
              {
                "type": "paragraph",
                "content": "La palabra clave <code>export</code> se puede colocar delante de una función, clase o definición de vinculación para indicar que esa vinculación es parte de la interfaz del módulo. Esto permite que otros módulos utilicen esa vinculación importándola."
              },
              {
                "type": "paragraph",
                "content": "La palabra clave <code>import</code>, seguida de una lista de nombres de vinculación entre llaves, hace que las vinculaciones de otro módulo estén disponibles en el módulo actual. Los módulos se identifican por cadenas entre comillas."
              }
            ]
          },
          {
            "id": "ch10-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cómo se resuelve un nombre de módulo a un programa real difiere según la plataforma. El navegador los trata como direcciones web, mientras que Node.js los resuelve a archivos. Para ejecutar un módulo, se cargan todos los demás módulos en los que depende, y las vinculaciones exportadas se ponen a disposición de los módulos que las importan."
              },
              {
                "type": "paragraph",
                "content": "Las declaraciones de importación y exportación no pueden aparecer dentro de funciones, bucles u otros bloques. Se resuelven de inmediato cuando se carga el módulo, independientemente de cómo se ejecute el código en el módulo, y para reflejar esto, deben aparecer solo en el cuerpo del módulo externo."
              },
              {
                "type": "paragraph",
                "content": "Así que la interfaz de un módulo consiste en una colección de vinculaciones con nombres, a las cuales tienen acceso otros módulos que dependen de ellas. Las vinculaciones importadas se pueden renombrar para darles un nuevo nombre local utilizando <code>as</code> después de su nombre."
              }
            ]
          },
          {
            "id": "ch10-l2-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "También es posible que un módulo tenga una exportación especial llamada <code>default</code>, que a menudo se usa para módulos que solo exportan un único enlace. Para definir una exportación predeterminada, se escribe <code>export default</code> antes de una expresión, una declaración de función o una declaración de clase."
              },
              {
                "type": "paragraph",
                "content": "Este enlace se importa omitiendo las llaves alrededor del nombre de la importación."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch10-l3",
        "title": "Paquetes",
        "sections": [
          {
            "id": "ch10-l3-s0",
            "title": "Paquetes",
            "content": [
              {
                "type": "paragraph",
                "content": "Una de las ventajas de construir un programa a partir de piezas separadas y poder ejecutar algunas de esas piezas por separado, es que puedes aplicar la misma pieza en diferentes programas."
              },
              {
                "type": "paragraph",
                "content": "Pero, ¿cómo se configura esto? Digamos que quiero usar la función <code>parseINI</code> de Capítulo 9 en otro programa. Si está claro de qué depende la función (en este caso, nada), puedo simplemente copiar ese módulo en mi nuevo proyecto y usarlo. Pero luego, si encuentro un error en el código, probablemente lo corrija en el programa con el que estoy trabajando en ese momento y olvide corregirlo también en el otro programa."
              },
              {
                "type": "paragraph",
                "content": "Una vez que empieces a duplicar código, rápidamente te darás cuenta de que estás perdiendo tiempo y energía moviendo copias y manteniéndolas actualizadas."
              }
            ]
          },
          {
            "id": "ch10-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahí es donde entran los <em>paquetes</em>. Un paquete es un fragmento de código que se puede distribuir (copiar e instalar). Puede contener uno o más módulos y tiene información sobre en qué otros paquetes depende. Un paquete también suele venir con documentación que explica qué hace para que las personas que no lo escribieron aún puedan usarlo."
              },
              {
                "type": "paragraph",
                "content": "Cuando se encuentra un problema en un paquete o se añade una nueva característica, se actualiza el paquete. Ahora los programas que dependen de él (que también pueden ser paquetes) pueden copiar la nueva versión para obtener las mejoras que se hicieron en el código."
              },
              {
                "type": "paragraph",
                "content": "Trabajar de esta manera requiere infraestructura. Necesitamos un lugar para almacenar y encontrar paquetes y una forma conveniente de instalar y actualizarlos. En el mundo de JavaScript, esta infraestructura es provista por NPM (<em>https://npmjs.org</em>)."
              }
            ]
          },
          {
            "id": "ch10-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "NPM es dos cosas: un servicio en línea donde puedes descargar (y subir) paquetes y un programa (incluido con Node.js) que te ayuda a instalar y gestionarlos."
              },
              {
                "type": "paragraph",
                "content": "En el momento de la escritura, hay más de tres millones de paquetes diferentes disponibles en NPM. Una gran parte de ellos son basura, para ser honesto. Pero casi cada paquete de JavaScript útil y disponible públicamente se puede encontrar en NPM. Por ejemplo, un analizador de archivos INI, similar al que construimos en el Capítulo 9, está disponible bajo el nombre del paquete <code>ini</code>."
              },
              {
                "type": "paragraph",
                "content": "Capítulo 20 mostrará cómo instalar tales paquetes localmente usando el programa de línea de comandos <code>npm</code>."
              }
            ]
          },
          {
            "id": "ch10-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tener paquetes de calidad disponibles para descargar es extremadamente valioso. Significa que a menudo podemos evitar reinventar un programa que 100 personas han escrito antes y obtener una implementación sólida y bien probada con solo presionar algunas teclas."
              },
              {
                "type": "paragraph",
                "content": "El software es barato de copiar, por lo que una vez que alguien lo ha escrito, distribuirlo a otras personas es un proceso eficiente. Pero escribirlo en primer lugar <em>es</em> trabajo, y responder a las personas que han encontrado problemas en el código, o que desean proponer nuevas características, es incluso más trabajo."
              },
              {
                "type": "paragraph",
                "content": "Por defecto, eres el propietario de los derechos de autor del código que escribes, y otras personas solo pueden usarlo con tu permiso. Pero porque algunas personas son amables y porque publicar buen software puede ayudarte a volverte un poco famoso entre los programadores, muchos paquetes se publican bajo una licencia que permite explícitamente a otras personas usarlo."
              }
            ]
          },
          {
            "id": "ch10-l3-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría del código en NPM tiene esta licencia. Algunas licencias requieren que también publiques el código que construyes sobre el paquete bajo la misma licencia. Otros son menos exigentes, simplemente requiriendo que mantengas la licencia con el código al distribuirlo. La comunidad de JavaScript mayormente utiliza este último tipo de licencia. Al usar paquetes de otras personas, asegúrate de estar al tanto de su licencia."
              },
              {
                "type": "paragraph",
                "content": "Ahora, en lugar de escribir nuestro propio analizador de archivos INI, podemos usar uno de NPM."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch10-l4",
        "title": "Módulos CommonJS",
        "sections": [
          {
            "id": "ch10-l4-s0",
            "title": "Módulos CommonJS",
            "content": [
              {
                "type": "paragraph",
                "content": "Antes de 2015, cuando el lenguaje de JavaScript no tenía un sistema de módulos integrado real, las personas ya estaban construyendo sistemas grandes en JavaScript. Para que funcionara, ellos <em>necesitaban</em> módulos."
              },
              {
                "type": "paragraph",
                "content": "La comunidad diseñó sus propios sistemas de módulos improvisados sobre el lenguaje. Estos utilizan funciones para crear un alcance local para los módulos y objetos regulares para representar interfaces de módulos."
              },
              {
                "type": "paragraph",
                "content": "Inicialmente, las personas simplemente envolvían manualmente todo su módulo en una “expresión de función invocada inmediatamente” para crear el alcance del módulo, y asignaban sus objetos de interfaz a una única variable global."
              }
            ]
          },
          {
            "id": "ch10-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este estilo de módulos proporciona aislamiento, hasta cierto punto, pero no declara dependencias. En cambio, simplemente coloca su interfaz en el ámbito global y espera que sus dependencias, si las tiene, hagan lo mismo. Esto no es ideal."
              },
              {
                "type": "paragraph",
                "content": "Si implementamos nuestro propio cargador de módulos, podemos hacerlo mejor. El enfoque más ampliamente utilizado para los módulos de JavaScript agregados se llama <em>Módulos CommonJS</em>. Node.js lo utilizaba desde el principio (aunque ahora también sabe cómo cargar módulos ES) y es el sistema de módulos utilizado por muchos paquetes en NPM."
              },
              {
                "type": "paragraph",
                "content": "Un módulo CommonJS se ve como un script regular, pero tiene acceso a dos enlaces que utiliza para interactuar con otros módulos. El primero es una función llamada <code>require</code>. Cuando llamas a esto con el nombre del módulo de tu dependencia, se asegura de que el módulo esté cargado y devuelve su interfaz. El segundo es un objeto llamado <code>exports</code>, que es el objeto de interfaz para el módulo. Comienza vacío y agregas propiedades para definir los valores exportados."
              }
            ]
          },
          {
            "id": "ch10-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este módulo de ejemplo CommonJS proporciona una función de formateo de fechas. Utiliza dos packages de NPM: <code>ordinal</code> para convertir números en strings como <code>\"1st\"</code> y <code>\"2nd\"</code>, y <code>date-names</code> para obtener los nombres en inglés de los días de la semana y los meses. Exporta una única función, <code>formatDate</code>, que recibe un objeto <code>Date</code> y una cadena template."
              },
              {
                "type": "paragraph",
                "content": "La cadena de template puede contener códigos que indican el formato, como <code>YYYY</code> para el año completo y <code>Do</code> para el día ordinal del mes. Puede pasársele una cadena como <code>\"MMMM Do YYYY\"</code> para obtener una salida como “22 de noviembre de 2017”."
              },
              {
                "type": "paragraph",
                "content": "La interfaz de <code>ordinal</code> es una única función, mientras que <code>date-names</code> exporta un objeto que contiene múltiples cosas: <code>days</code> y <code>months</code> son arrays de nombres. La técnica de desestructuración es muy conveniente al crear enlaces para las interfaces importadas."
              }
            ]
          },
          {
            "id": "ch10-l4-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El módulo añade su función de interfaz a <code>exports</code> para que los módulos que dependen de él tengan acceso a ella. Podemos usar el módulo de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "CommonJS se implementa con un cargador de módulos que, al cargar un módulo, envuelve su código en una función (dándole su propio ámbito local) y pasa los enlaces <code>require</code> y <code>exports</code> a esa función como argumentos."
              },
              {
                "type": "paragraph",
                "content": "Si asumimos que tenemos acceso a una función <code>readFile</code> que lee un archivo por su nombre y nos da su contenido, podemos definir una forma simplificada de <code>require</code> de la siguiente manera:"
              }
            ]
          },
          {
            "id": "ch10-l4-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "<code>Function</code> es una función interna de JavaScript que recibe una lista de argumentos (como una cadena separada por comas) y una cadena que contiene el cuerpo de la función, devolviendo un valor de función con esos argumentos y ese cuerpo. Este es un concepto interesante, ya que permite que un programa cree nuevas partes del programa a partir de datos de cadena, pero también es peligroso, ya que si alguien logra engañar a tu programa para que introduzca una cadena que ellos proporcionan en <code>Function</code>, pueden hacer que el programa haga cualquier cosa que quieran."
              },
              {
                "type": "paragraph",
                "content": "JavaScript estándar no proporciona una función como <code>readFile</code>, pero diferentes entornos de JavaScript, como el navegador y Node.js, proporcionan sus propias formas de acceder a los archivos. El ejemplo simplemente simula que <code>readFile</code> existe."
              },
              {
                "type": "paragraph",
                "content": "Para evitar cargar el mismo módulo múltiples veces, <code>require</code> mantiene una tienda (caché) de módulos ya cargados. Cuando se llama, primero comprueba si el módulo solicitado ha sido cargado y, si no, lo carga. Esto implica leer el código del módulo, envolverlo en una función y llamarlo."
              }
            ]
          },
          {
            "id": "ch10-l4-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al definir <code>require</code>, <code>exports</code> como parámetros para la función de envoltura generada (y pasar los valores apropiados al llamarla), el cargador se asegura de que estos enlaces estén disponibles en el ámbito del módulo."
              },
              {
                "type": "paragraph",
                "content": "Una diferencia importante entre este sistema y los módulos ES es que las importaciones de módulos ES suceden antes de que comience a ejecutarse el script de un módulo, mientras que <code>require</code> es una función normal, invocada cuando el módulo ya está en ejecución. A diferencia de las declaraciones <code>import</code>, las llamadas a <code>require</code> <em>pueden</em> aparecer dentro de funciones, y el nombre de la dependencia puede ser cualquier expresión que se evalúe a una cadena, mientras que <code>import</code> solo permite cadenas simples entre comillas."
              },
              {
                "type": "paragraph",
                "content": "La transición de la comunidad de JavaScript desde el estilo CommonJS a los módulos ES ha sido lenta y algo complicada. Pero afortunadamente, ahora estamos en un punto en el que la mayoría de los paquetes populares en NPM proporcionan su código como módulos ES, y Node.js permite que los módulos ES importen desde módulos CommonJS. Por lo tanto, si bien el código CommonJS es algo con lo que te encontrarás, ya no hay una razón real para escribir nuevos programas en este estilo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      },
      {
        "id": "ch10-l5",
        "title": "Compilación y empaquetado",
        "sections": [
          {
            "id": "ch10-l5-s0",
            "title": "Compilación y empaquetado",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos paquetes de JavaScript no están, técnicamente, escritos en JavaScript. Hay extensiones, como TypeScript, el dialecto de verificación de tipos mencionado en el Capítulo 8, que se utilizan ampliamente. A menudo, las personas también comienzan a usar extensiones planeadas para el lenguaje mucho antes de que se agreguen a las plataformas que realmente ejecutan JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Para hacer esto posible, <em>compilan</em> su código, traduciéndolo desde su dialecto de JavaScript elegido a JavaScript antiguo, e incluso a una versión anterior de JavaScript, para que los navegadores puedan ejecutarlo."
              },
              {
                "type": "paragraph",
                "content": "Incluir un programa modular que consta de 200 archivos diferentes en una página web produce sus propios problemas. Si recuperar un solo archivo a través de la red lleva 50 milisegundos, cargar todo el programa lleva 10 segundos, o quizás la mitad de eso si puedes cargar varios archivos simultáneamente. Eso es mucho tiempo desperdiciado. Como recuperar un solo archivo grande tiende a ser más rápido que recuperar muchos archivos pequeños, los programadores web han comenzado a usar herramientas que combinan sus programas (que dividieron minuciosamente en módulos) en un solo archivo grande antes de publicarlo en la Web. Estas herramientas se llaman <em>bundlers</em>."
              }
            ]
          },
          {
            "id": "ch10-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Y podemos ir más allá. Aparte del número de archivos, el <em>tamaño</em> de los archivos también determina qué tan rápido pueden ser transferidos a través de la red. Por lo tanto, la comunidad de JavaScript ha inventado <em>minificadores</em>. Estas son herramientas que toman un programa de JavaScript y lo hacen más pequeño al eliminar automáticamente comentarios y espacios en blanco, renombrar enlaces y reemplazar fragmentos de código con código equivalente que ocupa menos espacio."
              },
              {
                "type": "paragraph",
                "content": "Por lo tanto, no es raro que el código que encuentres en un paquete de NPM o que se ejecute en una página web haya pasado por <em>múltiples</em> etapas de transformación, convirtiéndose desde JavaScript moderno a JavaScript histórico, luego combinando los módulos en un solo archivo, y minimizando el código. No entraremos en detalles sobre estas herramientas en este libro ya que hay muchas de ellas, y cuál es popular cambia regularmente. Simplemente ten en cuenta que tales cosas existen, y búscalas cuando las necesites."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch10-l6",
        "title": "Diseño de módulos",
        "sections": [
          {
            "id": "ch10-l6-s0",
            "title": "Diseño de módulos",
            "content": [
              {
                "type": "paragraph",
                "content": "Estructurar programas es uno de los aspectos más sutiles de la programación. Cualquier funcionalidad no trivial puede ser organizada de diversas formas."
              },
              {
                "type": "paragraph",
                "content": "Un buen diseño de programa es subjetivo—hay compensaciones implicadas y cuestiones de gusto. La mejor manera de aprender el valor de un diseño bien estructurado es leer o trabajar en muchos programas y notar qué funciona y qué no. No asumas que un desorden doloroso es “simplemente así”. Puedes mejorar la estructura de casi todo pensando más detenidamente en ello."
              },
              {
                "type": "paragraph",
                "content": "Un aspecto del diseño de módulos es la facilidad de uso. Si estás diseñando algo que se supone será utilizado por varias personas—o incluso por ti mismo, dentro de tres meses cuando ya no recuerdes los detalles de lo que hiciste—es útil que tu interfaz sea simple y predecible."
              }
            ]
          },
          {
            "id": "ch10-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Eso puede significar seguir convenciones existentes. Un buen ejemplo es el paquete <code>ini</code>. Este módulo imita el objeto estándar <code>JSON</code> al proporcionar funciones <code>parse</code> y <code>stringify</code> (para escribir un archivo INI), y, como <code>JSON</code>, convierte entre cadenas y objetos simples. Por lo tanto, la interfaz es pequeña y familiar, y después de haber trabajado con ella una vez, es probable que recuerdes cómo usarla."
              },
              {
                "type": "paragraph",
                "content": "Incluso si no hay una función estándar o paquete ampliamente utilizado para imitar, puedes mantener tus módulos predecibles utilizando estructuras de datos simples y haciendo una sola cosa enfocada. Muchos de los módulos de análisis de archivos INI en NPM proporcionan una función que lee directamente dicho archivo desde el disco duro y lo analiza, por ejemplo. Esto hace imposible usar dichos módulos en el navegador, donde no tenemos acceso directo al sistema de archivos, y añade complejidad que hubiera sido mejor abordada <em>componiendo</em> el módulo con alguna función de lectura de archivos."
              },
              {
                "type": "paragraph",
                "content": "Esto señala otro aspecto útil del diseño de módulos—la facilidad con la que algo puede ser compuesto con otro código. Los módulos enfocados en calcular valores son aplicables en una gama más amplia de programas que los módulos más grandes que realizan acciones complicadas con efectos secundarios. Un lector de archivos INI que insiste en leer el archivo desde el disco es inútil en un escenario donde el contenido del archivo proviene de otra fuente."
              }
            ]
          },
          {
            "id": "ch10-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Relacionado con esto, a veces los objetos con estado son útiles o incluso necesarios, pero si algo se puede hacer con una función, utiliza una función. Varios de los lectores de archivos INI en NPM proporcionan un estilo de interfaz que requiere que primero crees un objeto, luego cargues el archivo en tu objeto, y finalmente uses métodos especializados para acceder a los resultados. Este tipo de enfoque es común en la tradición orientada a objetos, y es terrible. En lugar de hacer una sola llamada a función y continuar, debes realizar el ritual de mover tu objeto a través de sus diversos estados. Y debido a que los datos están envueltos en un tipo de objeto especializado, todo el código que interactúa con él debe conocer ese tipo, creando interdependencias innecesarias."
              },
              {
                "type": "paragraph",
                "content": "A menudo, no se puede evitar definir nuevas estructuras de datos, ya que el estándar del lenguaje proporciona solo algunas básicas, y muchos tipos de datos deben ser más complejos que un array o un mapa. Pero cuando un array es suficiente, utiliza un array."
              },
              {
                "type": "paragraph",
                "content": "Un ejemplo de una estructura de datos ligeramente más compleja es el grafo de Capítulo 7. No hay una forma única obvia de representar un grafo en JavaScript. En ese capítulo, utilizamos un objeto cuyas propiedades contienen arrays de strings: los otros nodos alcanzables desde ese nodo."
              }
            ]
          },
          {
            "id": "ch10-l6-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Existen varios paquetes de búsqueda de rutas en NPM, pero ninguno de ellos utiliza este formato de grafo. Por lo general, permiten que las aristas del grafo tengan un peso, que es el costo o la distancia asociada a ellas. Eso no es posible en nuestra representación."
              },
              {
                "type": "paragraph",
                "content": "Por ejemplo, está el paquete <code>dijkstrajs</code>. Un enfoque conocido para la búsqueda de rutas, bastante similar a nuestra función <code>findRoute</code>, se llama <em>algoritmo de Dijkstra</em>, en honor a Edsger Dijkstra, quien lo escribió por primera vez. A menudo se agrega el sufijo <code>js</code> a los nombres de los paquetes para indicar que están escritos en JavaScript. Este paquete <code>dijkstrajs</code> utiliza un formato de grafo similar al nuestro, pero en lugar de arrays, utiliza objetos cuyos valores de propiedad son números, los pesos de las aristas."
              },
              {
                "type": "paragraph",
                "content": "Por lo tanto, si quisiéramos usar ese paquete, deberíamos asegurarnos de que nuestro grafo esté almacenado en el formato que espera. Todas las aristas tienen el mismo peso, ya que nuestro modelo simplificado trata cada camino como teniendo el mismo coste (una vuelta)."
              }
            ]
          },
          {
            "id": "ch10-l6-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto puede ser una barrera para la composición: cuando varios paquetes están utilizando diferentes estructuras de datos para describir cosas similares, combinarlos es difícil. Por lo tanto, si deseas diseñar para la composabilidad, averigua qué estructuras de datos están utilizando otras personas y, cuando sea posible, sigue su ejemplo."
              },
              {
                "type": "paragraph",
                "content": "Diseñar una estructura de módulo adecuada para un programa puede ser difícil. En la fase en la que aún estás explorando el problema, probando diferentes cosas para ver qué funciona, es posible que no quieras preocuparte demasiado por esto, ya que mantener todo organizado puede ser una gran distracción. Una vez que tengas algo que se sienta sólido, es un buen momento para dar un paso atrás y organizarlo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch10-l7",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch10-l7-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Los módulos proporcionan estructura a programas más grandes al separar el código en piezas con interfaces claras y dependencias. La interfaz es la parte del módulo que es visible para otros módulos, y las dependencias son los otros módulos que se utilizan."
              },
              {
                "type": "paragraph",
                "content": "Dado que JavaScript históricamente no proporcionaba un sistema de módulos, se construyó el sistema CommonJS sobre él. Luego, en algún momento <em>obtuvo</em> un sistema incorporado, que ahora coexiste incómodamente con el sistema CommonJS."
              },
              {
                "type": "paragraph",
                "content": "Un paquete es un fragmento de código que se puede distribuir por sí solo. NPM es un repositorio de paquetes de JavaScript. Puedes descargar todo tipo de paquetes útiles (y inútiles) desde aquí."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch10-l8",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch10-l8-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Estos son los enlaces que crea el proyecto del Capítulo 7:"
              },
              {
                "type": "paragraph",
                "content": "Si tuvieras que escribir ese proyecto como un programa modular, ¿qué módulos crearías? ¿Qué módulo dependería de qué otro módulo y cómo serían sus interfaces?"
              },
              {
                "type": "paragraph",
                "content": "¿Qué piezas es probable que estén disponibles preescritas en NPM? ¿Preferirías usar un paquete de NPM o escribirlos tú mismo?"
              }
            ]
          },
          {
            "id": "ch10-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto es lo que habría hecho (pero de nuevo, no hay una única forma <em>correcta</em> de diseñar un módulo dado):"
              },
              {
                "type": "paragraph",
                "content": "El código utilizado para construir el gráfico de carreteras se encuentra en el módulo <code>graph</code>. Como preferiría usar <code>dijkstrajs</code> de NPM en lugar de nuestro propio código de búsqueda de caminos, haremos que este construya el tipo de datos de gráfico que espera <code>dijkstrajs</code>. Este módulo exporta una única función, <code>buildGraph</code>. Haría que <code>buildGraph</code> aceptara un arreglo de arreglos de dos elementos, en lugar de cuerdas que contienen guiones, para hacer que el módulo dependa menos del formato de entrada."
              },
              {
                "type": "paragraph",
                "content": "El módulo <code>roads</code> contiene los datos crudos de las carreteras (el arreglo <code>roads</code>) y el enlace <code>roadGraph</code>. Este módulo depende de <code>./graph.js</code> y exporta el grafo de carreteras."
              }
            ]
          },
          {
            "id": "ch10-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La clase <code>VillageState</code> se encuentra en el módulo <code>state</code>. Depende del módulo <code>./roads</code> porque necesita poder verificar que una carretera dada exista. También necesita <code>randomPick</code>. Dado que es una función de tres líneas, podríamos simplemente ponerla en el módulo <code>state</code> como una función auxiliar interna. Pero <code>randomRobot</code> también la necesita. Entonces tendríamos que duplicarla o ponerla en su propio módulo. Dado que esta función existe en NPM en el paquete <code>random-item</code>, una solución razonable es hacer que ambos módulos dependan de eso. También podemos agregar la función <code>runRobot</code> a este módulo, ya que es pequeña y está relacionada con la gestión del estado. El módulo exporta tanto la clase <code>VillageState</code> como la función <code>runRobot</code>."
              },
              {
                "type": "paragraph",
                "content": "Finalmente, los robots, junto con los valores en los que dependen, como <code>mailRoute</code>, podrían ir en un módulo <code>example-robots</code>, que depende de <code>./roads</code> y exporta las funciones del robot. Para que <code>goalOrientedRobot</code> pueda realizar la búsqueda de rutas, este módulo también depende de <code>dijkstrajs</code>.Al externalizar cierto trabajo a módulos NPM, el código se volvió un poco más pequeño. Cada módulo individual hace algo bastante simple y se puede leer por sí solo. Dividir el código en módulos a menudo sugiere mejoras adicionales en el diseño del programa. En este caso, parece un poco extraño que el <code>VillageState</code> y los robots dependan de un gráfico de caminos específico. Podría ser una mejor idea hacer que el gráfico sea un argumento del constructor de estado y hacer que los robots lo lean desde el objeto de estado, esto reduce las dependencias (lo cual siempre es bueno) y hace posible ejecutar simulaciones en mapas diferentes (lo cual es aun mejor)."
              },
              {
                "type": "paragraph",
                "content": "¿Es una buena idea utilizar módulos de NPM para cosas que podríamos haber escrito nosotros mismos? En principio, sí, para cosas no triviales como la función de búsqueda de caminos es probable que cometas errores y pierdas tiempo escribiéndolas tú mismo. Para funciones pequeñas como <code>random-item</code>, escribirlas por ti mismo es bastante fácil. Pero añadirlas donde las necesitas tiende a saturar tus módulos."
              }
            ]
          },
          {
            "id": "ch10-l8-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Sin embargo, tampoco debes subestimar el trabajo involucrado en <em>encontrar</em> un paquete de NPM apropiado. Y aunque encuentres uno, podría no funcionar bien o le podrían faltar alguna característica que necesitas. Además, depender de paquetes de NPM significa que debes asegurarte de que estén instalados, debes distribuirlos con tu programa y es posible que debas actualizarlos periódicamente."
              },
              {
                "type": "paragraph",
                "content": "Así que de nuevo, esto es un compromiso, y puedes decidir de cualquier manera dependiendo de cuánto te ayude realmente un paquete dado."
              },
              {
                "type": "paragraph",
                "content": "Escribe un módulo ES, basado en el ejemplo del Capítulo 7, que contenga el array de caminos y exporte la estructura de datos de gráfico que los representa como <code>roadGraph</code>. Debería depender de un módulo <code>./graph.js</code>, que exporta una función <code>buildGraph</code> que se utiliza para construir el gráfico. Esta función espera un array de arrays de dos elementos (los puntos de inicio y fin de los caminos)."
              }
            ]
          },
          {
            "id": "ch10-l8-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dado que este es un módulo ES, debes usar <code>import</code> para acceder al módulo de gráfico. Esto se describió como exportando una función de <code>buildGraph</code>, la cual puedes seleccionar de su objeto de interfaz con una declaración de desestructuración <code>const</code>."
              },
              {
                "type": "paragraph",
                "content": "Para exportar <code>roadGraph</code>, colocas la palabra clave <code>export</code> antes de su definición. Debido a que <code>buildGraph</code> toma una estructura de datos que no coincide exactamente con <code>roads</code>, la división de las cadenas de carretera debe ocurrir en tu módulo."
              },
              {
                "type": "paragraph",
                "content": "Una dependencia circular es una situación en la que el módulo A depende de B, y B también, directa o indirectamente, depende de A. Muchos sistemas de módulos simplemente prohíben esto porque, sin importar el orden que elijas para cargar dichos módulos, no puedes asegurarte de que las dependencias de cada módulo se hayan cargado antes de que se ejecute."
              }
            ]
          },
          {
            "id": "ch10-l8-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los módulos CommonJS permiten una forma limitada de dependencias cíclicas. Siempre y cuando los módulos no accedan a la interfaz de cada uno hasta después de que terminen de cargarse, las dependencias cíclicas están bien."
              },
              {
                "type": "paragraph",
                "content": "La función <code>require</code> proporcionada anteriormente en este capítulo admite este tipo de ciclo de dependencia. ¿Puedes ver cómo maneja los ciclos?"
              },
              {
                "type": "paragraph",
                "content": "El truco es que <code>require</code> añade el objeto de interfaz de un módulo a su caché <em>antes</em> de comenzar a cargar el módulo. De esta manera, si se hace alguna llamada a <code>require</code> mientras se está ejecutando tratando de cargarlo, ya se conoce, y se devolverá la interfaz actual, en lugar de comenzar a cargar el módulo nuevamente (lo que eventualmente desbordaría la pila)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      }
    ]
  },
  {
    "id": "ch11",
    "number": 11,
    "title": "Programación Asíncrona",
    "titleEs": "Programación Asíncrona",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "¿Quién puede esperar en silencio mientras el barro se asienta?¿Quién puede permanecer quieto hasta el momento de la acción?...",
    "isProject": false,
    "totalXP": 535,
    "lessons": [
      {
        "id": "ch11-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch11-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "¿Quién puede esperar en silencio mientras el barro se asienta?¿Quién puede permanecer quieto hasta el momento de la acción? Laozi, Tao Te Ching"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Programación Asíncrona __ Eloquent JavaScript_files/chapter_picture_11.jpg",
                "alt": "Ilustración que muestra dos cuervos en una rama de árbol"
              },
              {
                "type": "paragraph",
                "content": "La parte central de una computadora, la parte que lleva a cabo los pasos individuales que componen nuestros programas, se llama el <em>procesador</em>. Los programas que hemos visto hasta ahora mantendrán ocupado al procesador hasta que hayan terminado su trabajo. La velocidad a la cual algo como un bucle que manipula números puede ser ejecutado depende casi enteramente de la velocidad del procesador y la memoria de la computadora."
              }
            ]
          },
          {
            "id": "ch11-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero muchos programas interactúan con cosas fuera del procesador. Por ejemplo, pueden comunicarse a través de una red de computadoras o solicitar datos desde el disco duro, lo cual es mucho más lento que obtenerlo de la memoria."
              },
              {
                "type": "paragraph",
                "content": "Cuando esto está sucediendo, sería una lástima dejar el procesador inactivo, ya que podría haber otro trabajo que podría hacer en ese tiempo. En parte, esto es manejado por tu sistema operativo, el cual cambiará el procesador entre múltiples programas en ejecución. Pero eso no ayuda cuando queremos que un <em>único</em> programa pueda avanzar mientras espera una solicitud de red."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch11-l1",
        "title": "Asincronía",
        "sections": [
          {
            "id": "ch11-l1-s0",
            "title": "Asincronía",
            "content": [
              {
                "type": "paragraph",
                "content": "En un modelo de programación <em>sincrónico</em>, las cosas suceden una a la vez. Cuando llamas a una función que realiza una acción de larga duración, solo devuelve cuando la acción ha terminado y puede devolver el resultado. Esto detiene tu programa durante el tiempo que tome la acción."
              },
              {
                "type": "paragraph",
                "content": "Un modelo <em>asincrónico</em> permite que múltiples cosas sucedan al mismo tiempo. Cuando inicias una acción, tu programa continúa ejecutándose. Cuando la acción termina, el programa es informado y obtiene acceso al resultado (por ejemplo, los datos leídos desde el disco)."
              },
              {
                "type": "paragraph",
                "content": "Podemos comparar la programación sincrónica y asincrónica usando un pequeño ejemplo: un programa que realiza dos solicitudes a través de la red y luego combina los resultados."
              }
            ]
          },
          {
            "id": "ch11-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En un entorno sincrónico, donde la función de solicitud devuelve solo después de haber hecho su trabajo, la forma más fácil de realizar esta tarea es hacer las solicitudes una después de la otra. Esto tiene la desventaja de que la segunda solicitud se iniciará solo cuando la primera haya terminado. El tiempo total tomado será al menos la suma de los dos tiempos de respuesta."
              },
              {
                "type": "paragraph",
                "content": "La solución a este problema, en un sistema sincrónico, es iniciar hebras de control adicionales. Una <em>hebra</em> es otro programa en ejecución cuya ejecución puede ser intercalada con otros programas por el sistema operativo, ya que la mayoría de las computadoras modernas contienen múltiples procesadores, múltiples hebras incluso podrían ejecutarse al mismo tiempo, en diferentes procesadores. Una segunda hebra podría iniciar la segunda solicitud, y luego ambas hebras esperan que sus resultados regresen, después de lo cual se resincronizan para combinar sus resultados."
              },
              {
                "type": "paragraph",
                "content": "En el siguiente diagrama, las líneas gruesas representan el tiempo que el programa pasa funcionando normalmente, y las líneas delgadas representan el tiempo gastado esperando a la red. En el modelo síncrono, el tiempo tomado por la red es <em>parte</em> de la línea de tiempo para un hilo de control dado. En el modelo asíncrono, iniciar una acción en la red permite que el programa continúe ejecutándose mientras la comunicación en la red sucede junto a él, notificando al programa cuando haya terminado."
              }
            ]
          },
          {
            "id": "ch11-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/Programación Asíncrona __ Eloquent JavaScript_files/control-io.svg",
                "alt": "Diagrama que muestra el flujo de control en programas síncronos y asíncronos. La primera parte muestra un programa síncrono, donde las fases activas y de espera del programa ocurren en una única línea secuencial. La segunda parte muestra un programa síncrono multi-hilo, con dos líneas paralelas en las cuales las partes de espera suceden una al lado de la otra, haciendo que el programa termine más rápido. La última parte muestra un programa asíncrono, donde las múltiples acciones asíncronas se ramifican desde el programa principal, el cual se detiene en algún momento y luego continúa cuando la primera cosa por la que estaba esperando finaliza."
              },
              {
                "type": "paragraph",
                "content": "Otra forma de describir la diferencia es que esperar a que las acciones terminen es <em>implícito</em> en el modelo síncrono, mientras que es <em>explícito</em>, bajo nuestro control, en el modelo asíncrono."
              },
              {
                "type": "paragraph",
                "content": "La asincronía tiene sus pros y sus contras. Facilita la expresión de programas que no encajan en el modelo de control de línea recta, pero también puede hacer que expresar programas que siguen una línea recta sea más complicado. Veremos algunas formas de reducir esta dificultad más adelante en el capítulo."
              }
            ]
          },
          {
            "id": "ch11-l1-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tanto las plataformas de programación de JavaScript prominentes —navegadores como Node.js— hacen operaciones que podrían tardar un tiempo de forma asíncrona, en lugar de depender de hilos. Dado que programar con hilos es notoriamente difícil (entender lo que hace un programa es mucho más difícil cuando está haciendo múltiples cosas a la vez), esto generalmente se considera algo bueno."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch11-l2",
        "title": "Retrollamadas",
        "sections": [
          {
            "id": "ch11-l2-s0",
            "title": "Retrollamadas",
            "content": [
              {
                "type": "paragraph",
                "content": "Un enfoque para la programación asíncrona es hacer que las funciones que necesitan esperar por algo tomen un argumento adicional, una <em>función de devolución de llamada</em>. La función asíncrona inicia algún proceso, configura las cosas para que se llame a la función de devolución de llamada cuando el proceso termine, y luego retorna."
              },
              {
                "type": "paragraph",
                "content": "Como ejemplo, la función <code>setTimeout</code>, disponible tanto en Node.js como en los navegadores, espera un número dado de milisegundos (un segundo equivale a mil milisegundos) y luego llama a una función."
              },
              {
                "type": "paragraph",
                "content": "Esperar no suele ser un tipo de trabajo muy importante, pero puede ser muy útil cuando necesitas organizar que algo suceda en un momento determinado o verificar si alguna otra acción está tomando más tiempo del esperado."
              }
            ]
          },
          {
            "id": "ch11-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Otro ejemplo de una operación asincrónica común es leer un archivo desde el almacenamiento de un dispositivo. Imagina que tienes una función <code>readTextFile</code>, la cual lee el contenido de un archivo como una cadena y lo pasa a una función de devolución de llamada."
              },
              {
                "type": "paragraph",
                "content": "La función <code>readTextFile</code> no es parte del estándar de JavaScript. Veremos cómo leer archivos en el navegador y en Node.js en capítulos posteriores."
              },
              {
                "type": "paragraph",
                "content": "Realizar múltiples acciones asincrónicas en fila usando devoluciones de llamada significa que tienes que seguir pasando nuevas funciones para manejar la continuación de la computación después de las acciones. Así es como podría verse una función asincrónica que compara dos archivos y produce un booleano que indica si su contenido es el mismo."
              }
            ]
          },
          {
            "id": "ch11-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este estilo de programación es funcional, pero el nivel de indentación aumenta con cada acción asincrónica porque terminas en otra función. Hacer cosas más complicadas, como envolver acciones asincrónicas en un bucle, puede ser incómodo."
              },
              {
                "type": "paragraph",
                "content": "De alguna manera, la asincronía es contagiosa. Cualquier función que llame a una función que trabaja de forma asincrónica debe ser asincrónica en sí misma, utilizando una devolución de llamada u otro mecanismo similar para entregar su resultado. Llamar a una devolución de llamada es algo más complicado y propenso a errores que simplemente devolver un valor, por lo que necesitar estructurar grandes partes de tu programa de esa manera no es ideal."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch11-l3",
        "title": "Promesas",
        "sections": [
          {
            "id": "ch11-l3-s0",
            "title": "Promesas",
            "content": [
              {
                "type": "paragraph",
                "content": "Una forma ligeramente diferente de construir un programa asincrónico es hacer que las funciones asincrónicas devuelvan un objeto que represente su resultado (futuro) en lugar de pasar devoluciones de llamada por todas partes. De esta manera, tales funciones realmente devuelven algo significativo, y la estructura del programa se asemeja más a la de los programas síncronos."
              },
              {
                "type": "paragraph",
                "content": "Para esto sirve la clase estándar <code>Promise</code>. Una <em>promesa</em> es un recibo que representa un valor que aún puede no estar disponible. Proporciona un método <code>then</code> que te permite registrar una función que debe ser llamada cuando la acción por la que está esperando finalice. Cuando la promesa se <em>resuelve</em>, es decir, su valor se vuelve disponible, esas funciones (puede haber varias) son llamadas con el valor del resultado. Es posible llamar a <code>then</code> en una promesa que ya ha sido resuelta; tu función seguirá siendo llamada."
              },
              {
                "type": "paragraph",
                "content": "La forma más sencilla de crear una promesa es llamando a <code>Promise.resolve</code>. Esta función se asegura de que el valor que le proporcionas esté envuelto en una promesa. Si ya es una promesa, simplemente se devuelve; de lo contrario, obtienes una nueva promesa que se resuelve de inmediato con tu valor como resultado."
              }
            ]
          },
          {
            "id": "ch11-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para crear una promesa que no se resuelva inmediatamente, puedes utilizar <code>Promise</code> como constructor. Tiene una interfaz un tanto extraña: el constructor espera una función como argumento, la cual llama inmediatamente, pasándole una función que puede utilizar para resolver la promesa."
              },
              {
                "type": "paragraph",
                "content": "Así es como podrías crear una interfaz basada en promesas para la función <code>readTextFile</code>:"
              },
              {
                "type": "paragraph",
                "content": "Observa cómo esta función asíncrona devuelve un valor significativo: una promesa para proporcionarte el contenido del archivo en algún momento futuro."
              }
            ]
          },
          {
            "id": "ch11-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una característica útil del método <code>then</code> es que él mismo devuelve otra promesa que se resuelve al valor retornado por la función de devolución de llamada o, si esa función devuelve una promesa, al valor al que esa promesa se resuelve. De esta forma, puedes “encadenar” varias llamadas a <code>then</code> para configurar una secuencia de acciones asíncronas."
              },
              {
                "type": "paragraph",
                "content": "Esta función, la cual lee un archivo lleno de nombres de archivos y devuelve el contenido de un archivo aleatorio de esa lista, muestra este tipo de cadena asíncrona de promesas."
              },
              {
                "type": "paragraph",
                "content": "La función devuelve el resultado de esta cadena de llamadas a <code>then</code>. La promesa inicial obtiene la lista de archivos como una cadena. La primera llamada a <code>then</code> transforma esa cadena en un array de líneas, produciendo una nueva promesa. La segunda llamada a <code>then</code> elige una línea aleatoria de eso, produciendo una tercera promesa que arroja un único nombre de archivo. La llamada final a <code>then</code> lee este archivo, de modo que el resultado de la función en su totalidad es una promesa que devuelve el contenido de un archivo aleatorio."
              }
            ]
          },
          {
            "id": "ch11-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En este código, las funciones utilizadas en las primeras dos llamadas a <code>then</code> devuelven un valor regular, que se pasará inmediatamente a la promesa devuelta por <code>then</code> cuando la función regrese. La última devuelve una promesa (<code>textFile(nombreArchivo)</code>), convirtiéndola en un paso asincrónico real."
              },
              {
                "type": "paragraph",
                "content": "También habría sido posible realizar todos estos pasos dentro de un solo callback de <code>then</code>, ya que solo el último paso es realmente asíncrono. Pero los tipos de envolturas <code>then</code> que solo realizan alguna transformación de datos síncrona son a menudo útiles, por ejemplo, cuando deseas devolver una promesa que produzca una versión procesada de algún resultado asíncrono."
              },
              {
                "type": "paragraph",
                "content": "En general, es útil pensar en las promesas como un mecanismo que permite al código ignorar la pregunta de cuándo va a llegar un valor. Un valor normal tiene que existir realmente antes de que podamos hacer referencia a él. Un valor prometido es un valor que <em>puede</em> estar allí o podría aparecer en algún momento en el futuro. Las operaciones definidas en términos de promesas, al conectarlas con llamadas <code>then</code>, se ejecutan de forma asíncrona a medida que sus entradas están disponibles."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch11-l4",
        "title": "Falla",
        "sections": [
          {
            "id": "ch11-l4-s0",
            "title": "Falla",
            "content": [
              {
                "type": "paragraph",
                "content": "Las computaciones regulares de JavaScript pueden fallar al lanzar una excepción. Las computaciones asíncronas a menudo necesitan algo así. Una solicitud de red puede fallar, un archivo puede no existir, o algún código que forma parte de la computación asíncrona puede lanzar una excepción."
              },
              {
                "type": "paragraph",
                "content": "Uno de los problemas más apremiantes con el estilo de programación asíncrona basado en devoluciones de llamada es que hace extremadamente difícil asegurarse de que las fallas se informen adecuadamente a las devoluciones de llamada."
              },
              {
                "type": "paragraph",
                "content": "Una convención ampliamente utilizada es que el primer argumento de la devolución de llamada se utiliza para indicar que la acción falló, y el segundo contiene el valor producido por la acción cuando fue exitosa."
              }
            ]
          },
          {
            "id": "ch11-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tales funciones de devolución de llamada siempre deben verificar si recibieron una excepción y asegurarse de que cualquier problema que causen, incluidas las excepciones lanzadas por las funciones que llaman, se capturen y se den a la función correcta."
              },
              {
                "type": "paragraph",
                "content": "Las promesas facilitan esto. Pueden ser o bien resueltas (la acción se completó con éxito) o rechazadas (falló). Los manejadores de resolución (como se registran con <code>then</code>) se llaman solo cuando la acción es exitosa, y los rechazos se propagan a la nueva promesa que es devuelta por <code>then</code>. Cuando un manejador lanza una excepción, esto causa automáticamente que la promesa producida por la llamada a su <code>then</code> sea rechazada. Entonces, si algún elemento en una cadena de acciones asíncronas falla, el resultado de toda la cadena se marca como rechazado, y no se llaman manejadores de éxito más allá del punto donde falló."
              },
              {
                "type": "paragraph",
                "content": "Al igual que resolver una promesa proporciona un valor, rechazar una también lo hace, generalmente llamado el <em>motivo</em> del rechazo. Cuando una excepción en una función manejadora causa el rechazo, el valor de la excepción se usa como el motivo. De manera similar, cuando una función manejadora devuelve una promesa que es rechazada, ese rechazo fluye hacia la siguiente promesa. Existe una función <code>Promise.reject</code> que crea una nueva promesa inmediatamente rechazada."
              }
            ]
          },
          {
            "id": "ch11-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para manejar explícitamente tales rechazos, las promesas tienen un método <code>catch</code> que registra un manejador para ser llamado cuando la promesa es rechazada, similar a cómo los manejadores de <code>then</code> manejan la resolución normal. También es muy similar a <code>then</code> en que devuelve una nueva promesa, que se resuelve con el valor de la promesa original cuando se resuelve normalmente y con el resultado del manejador <code>catch</code> en caso contrario. Si un manejador de <code>catch</code> lanza un error, la nueva promesa también se rechaza."
              },
              {
                "type": "paragraph",
                "content": "Como un atajo, <code>then</code> también acepta un manejador de rechazo como segundo argumento, para poder instalar ambos tipos de manejadores en una sola llamada de método."
              },
              {
                "type": "paragraph",
                "content": "Una función pasada al constructor <code>Promise</code> recibe un segundo argumento, junto con la función de resolución, que puede usar para rechazar la nueva promesa.Cuando nuestra función <code>readTextFile</code> encuentra un problema, pasa el error a su función de devolución de llamada como segundo argumento. Nuestro envoltorio <code>textFile</code> debería realmente examinar ese argumento, de manera que un fallo cause que la promesa que devuelve sea rechazada."
              }
            ]
          },
          {
            "id": "ch11-l4-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las cadenas de valores de promesa creadas por llamadas a <code>then</code> y <code>catch</code> forman así un pipeline a través del cual se mueven los valores asíncronos o fallos. Dado que dichas cadenas se crean registrando manejadores, cada eslabón tiene asociado un manejador de éxito o un manejador de rechazo (o ambos). Los manejadores que no coinciden con el tipo de resultado (éxito o fallo) son ignorados. Pero aquellos que coinciden son llamados, y su resultado determina qué tipo de valor viene a continuación: éxito cuando devuelve un valor que no es una promesa, rechazo cuando genera una excepción, y el resultado de la promesa cuando devuelve una promesa."
              },
              {
                "type": "paragraph",
                "content": "La primera función de manejador regular no es llamada, porque en ese punto del pipeline la promesa contiene un rechazo. El manejador <code>catch</code> maneja ese rechazo y devuelve un valor, que se le da a la segunda función de manejador."
              },
              {
                "type": "paragraph",
                "content": "Cuando una excepción no controlada es manejada por el entorno, los entornos de JavaScript pueden detectar cuándo un rechazo de promesa no es manejado y lo reportarán como un error."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch11-l5",
        "title": "Carla",
        "sections": [
          {
            "id": "ch11-l5-s0",
            "title": "Carla",
            "content": [
              {
                "type": "paragraph",
                "content": "Es un día soleado en Berlín. La pista del antiguo aeropuerto desmantelado rebosa de ciclistas y patinadores en línea. En el césped cerca de un contenedor de basura un grupo de cuervos se agita ruidosamente, intentando convencer a un grupo de turistas de que les den sus sándwiches."
              },
              {
                "type": "paragraph",
                "content": "Uno de los cuervos destaca: una hembra grande andrajosa con algunas plumas blancas en su ala derecha. Está atrayendo a la gente con habilidad y confianza que sugieren que ha estado haciendo esto durante mucho tiempo. Cuando un anciano se distrae con las travesuras de otro cuervo, ella se abalanza casualmente, arrebata su bollo a medio comer de su mano y se aleja planeando."
              },
              {
                "type": "paragraph",
                "content": "A diferencia del resto del grupo, que parece estar feliz de pasar el día holgazaneando aquí, el cuervo grande parece tener un propósito. Llevando su botín, vuela directamente hacia el techo del edificio del hangar, desapareciendo en una rejilla de ventilación."
              }
            ]
          },
          {
            "id": "ch11-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dentro del edificio, se puede escuchar un sonido peculiar: suave, pero persistente. Viene de un espacio estrecho bajo el techo de una escalera sin terminar. El cuervo está sentado allí, rodeado de sus botines robados, media docena de teléfonos inteligentes (varios de los cuales están encendidos) y un enredo de cables. Golpea rápidamente la pantalla de uno de los teléfonos con su pico. Aparecen palabras en él. Si no supieras mejor, pensarías que estaba escribiendo.Este cuervo es conocido por sus pares como “cāāw-krö\". Pero dado que esos sonidos no son adecuados para las cuerdas vocales humanas, la llamaremos Carla."
              },
              {
                "type": "paragraph",
                "content": "Carla es un cuervo algo peculiar. En su juventud, estaba fascinada por el lenguaje humano, escuchando a la gente hasta que tuvo un buen entendimiento de lo que decían. Más tarde, su interés se trasladó a la tecnología humana, y comenzó a robar teléfonos para estudiarlos. Su proyecto actual es aprender a programar. El texto que está escribiendo en su laboratorio secreto, de hecho, es un fragmento de código JavaScript."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch11-l6",
        "title": "Infiltración",
        "sections": [
          {
            "id": "ch11-l6-s0",
            "title": "Infiltración",
            "content": [
              {
                "type": "paragraph",
                "content": "A Carla le encanta Internet. Fastidiosamente, el teléfono en el que está trabajando está a punto de quedarse sin datos prepagos. El edificio tiene una red inalámbrica, pero se requiere un código para acceder a ella."
              },
              {
                "type": "paragraph",
                "content": "Afortunadamente, los enrutadores inalámbricos en el edificio tienen 20 años y están mal protegidos. Tras investigar un poco, Carla descubre que el mecanismo de autenticación de la red tiene una falla que puede aprovechar. Al unirse a la red, un dispositivo debe enviar el código correcto de 6 dígitos. El punto de acceso responderá con un mensaje de éxito o fracaso dependiendo de si se proporciona el código correcto. Sin embargo, al enviar solo un código parcial (digamos, solo 3 dígitos), la respuesta es diferente según si esos dígitos son el inicio correcto del código o no. Cuando se envía un número incorrecto, se recibe inmediatamente un mensaje de fracaso. Cuando se envían los correctos, el punto de acceso espera más dígitos."
              },
              {
                "type": "paragraph",
                "content": "Esto hace posible acelerar enormemente la adivinación del número. Carla puede encontrar el primer dígito probando cada número a su vez, hasta que encuentre uno que no devuelva inmediatamente un fracaso. Teniendo un dígito, puede encontrar el segundo de la misma manera, y así sucesivamente, hasta que conozca todo el código de acceso."
              }
            ]
          },
          {
            "id": "ch11-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Supongamos que tenemos una función <code>joinWifi</code>. Dado el nombre de la red y el código de acceso (como una cadena), intenta unirse a la red, devolviendo una promesa que se resuelve si tiene éxito, y se rechaza si la autenticación falla. Lo primero que necesitamos es una forma de envolver una promesa para que se rechace automáticamente después de transcurrir demasiado tiempo, de manera que podamos avanzar rápidamente si el punto de acceso no responde."
              },
              {
                "type": "paragraph",
                "content": "Esto aprovecha el hecho de que una promesa solo puede resolverse o rechazarse una vez: si la promesa dada como argumento se resuelve o se rechaza primero, ese será el resultado de la promesa devuelta por <code>withTimeout</code>. Si, por otro lado, el <code>setTimeout</code> se ejecuta primero, rechazando la promesa, se ignoran cualquier llamada posterior a resolve o reject."
              },
              {
                "type": "paragraph",
                "content": "Para encontrar todo el código de acceso, necesitamos buscar repetidamente el siguiente dígito probando cada dígito. Si la autenticación tiene éxito, sabremos que hemos encontrado lo que buscamos. Si falla inmediatamente, sabremos que ese dígito era incorrecto y debemos probar con el siguiente. Si la solicitud se agota, hemos encontrado otro dígito correcto y debemos continuar agregando otro dígito.Debido a que no puedes esperar una promesa dentro de un bucle <code>for</code>, Carla utiliza una función recursiva para llevar a cabo este proceso. En cada llamada, obtiene el código tal como lo conocemos hasta ahora, así como el siguiente dígito a probar. Dependiendo de lo que suceda, puede devolver un código terminado, o llamar de nuevo a sí misma, ya sea para comenzar a descifrar la siguiente posición en el código, o para intentarlo de nuevo con otro dígito."
              }
            ]
          },
          {
            "id": "ch11-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El punto de acceso suele responder a solicitudes de autenticación incorrectas en aproximadamente 20 milisegundos, por lo que, para estar seguros, esta función espera 50 milisegundos antes de hacer expirar una solicitud."
              },
              {
                "type": "paragraph",
                "content": "Carla inclina la cabeza y suspira. Esto habría sido más satisfactorio si el código hubiera sido un poco más difícil de adivinar."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch11-l7",
        "title": "Funciones asíncronas",
        "sections": [
          {
            "id": "ch11-l7-s0",
            "title": "Funciones asíncronas",
            "content": [
              {
                "type": "paragraph",
                "content": "Incluso con promesas, este tipo de código asíncrono es molesto de escribir. Las promesas a menudo necesitan ser encadenadas de manera verbosa y arbitraria. Y nos vimos obligados a introducir una función recursiva solo para crear un bucle."
              },
              {
                "type": "paragraph",
                "content": "Lo que la función de descifrado realmente hace es completamente lineal: siempre espera a que la acción anterior se complete antes de comenzar la siguiente. En un modelo de programación síncrona, sería más sencillo de expresar."
              },
              {
                "type": "paragraph",
                "content": "La buena noticia es que JavaScript te permite escribir código pseudo-sincrónico para describir la computación asíncrona. Una función <code>async</code> es una función que implícitamente devuelve una promesa y que puede, en su cuerpo, <code>await</code> otras promesas de una manera que <em>parece</em> sincrónica."
              }
            ]
          },
          {
            "id": "ch11-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Podemos reescribir <code>crackPasscode</code> de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "Esta versión muestra de manera más clara la estructura de doble bucle de la función (el bucle interno prueba el dígito 0 al 9, el bucle externo añade dígitos al código de acceso)."
              },
              {
                "type": "paragraph",
                "content": "Una función <code>async</code> está marcada con la palabra <code>async</code> antes de la palabra clave <code>function</code>. Los métodos también pueden ser marcados como <code>async</code> escribiendo <code>async</code> antes de su nombre. Cuando se llama a una función o método de esta manera, devuelve una promesa. Tan pronto como la función devuelve algo, esa promesa se resuelve. Si el cuerpo genera una excepción, la promesa es rechazada."
              }
            ]
          },
          {
            "id": "ch11-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dentro de una función <code>async</code>, la palabra <code>await</code> puede colocarse delante de una expresión para esperar a que una promesa se resuelva y luego continuar con la ejecución de la función. Si la promesa es rechazada, se genera una excepción en el punto del <code>await</code>."
              },
              {
                "type": "paragraph",
                "content": "Una función así ya no se ejecuta, como una función regular de JavaScript, de principio a fin de una sola vez. En su lugar, puede estar <em>congelada</em> en cualquier punto que tenga un <code>await</code>, y puede continuar más tarde."
              },
              {
                "type": "paragraph",
                "content": "Para la mayoría del código asíncrono, esta notación es más conveniente que usar directamente promesas. Aún necesitas comprender las promesas, ya que en muchos casos todavía interactúas con ellas directamente. Pero al encadenarlas, las funciones <code>async</code> suelen ser más agradables de escribir que encadenar llamadas <code>then</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch11-l8",
        "title": "Generadores",
        "sections": [
          {
            "id": "ch11-l8-s0",
            "title": "Generadores",
            "content": [
              {
                "type": "paragraph",
                "content": "Esta capacidad de pausar y luego reanudar funciones no es exclusiva de las funciones <code>async</code>. JavaScript también tiene una característica llamada <em>generador</em> functions. Son similares, pero sin las promesas."
              },
              {
                "type": "paragraph",
                "content": "Cuando defines una función con <code>function*</code> (colocando un asterisco después de la palabra <code>function</code>), se convierte en un generador. Al llamar a un generador, devuelve un iterador, que ya vimos en el Capítulo 6."
              },
              {
                "type": "paragraph",
                "content": "Inicialmente, al llamar a <code>powers</code>, la función se congela desde el principio. Cada vez que llamas a <code>next</code> en el iterador, la función se ejecuta hasta que encuentra una expresión <code>yield</code>, que la pausa y hace que el valor generado se convierta en el próximo valor producido por el iterador. Cuando la función retorna (la del ejemplo nunca lo hace), el iterador ha terminado."
              }
            ]
          },
          {
            "id": "ch11-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribir iteradores a menudo es mucho más fácil cuando usas funciones generadoras. El iterador para la clase <code>Group</code> (del ejercicio en el Capítulo 6) se puede escribir con este generador:"
              },
              {
                "type": "paragraph",
                "content": "Ya no es necesario crear un objeto para mantener el estado de la iteración: los generadores guardan automáticamente su estado local cada vez que hacen un <code>yield</code>."
              },
              {
                "type": "paragraph",
                "content": "Tales expresiones <code>yield</code> solo pueden ocurrir directamente en la función generadora misma y no en una función interna que definas dentro de ella. El estado que un generador guarda, al hacer yield, es solo su entorno <em>local</em> y la posición donde hizo el yield."
              }
            ]
          },
          {
            "id": "ch11-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una función <code>async</code> es un tipo especial de generador. Produce una promesa al llamarla, la cual se resuelve cuando retorna (termina) y se rechaza cuando arroja una excepción. Cada vez que hace un yield (awaits) una promesa, el resultado de esa promesa (valor o excepción generada) es el resultado de la expresión <code>await</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch11-l9",
        "title": "Un Proyecto de Arte de Corvidos",
        "sections": [
          {
            "id": "ch11-l9-s0",
            "title": "Un Proyecto de Arte de Corvidos",
            "content": [
              {
                "type": "paragraph",
                "content": "Esta mañana, Carla se despertó con un ruido desconocido en la pista de aterrizaje fuera de su hangar. Saltando al borde del techo, ve que los humanos están preparando algo. Hay muchos cables eléctricos, un escenario y una especie de gran pared negra que están construyendo."
              },
              {
                "type": "paragraph",
                "content": "Siendo una cuerva curiosa, Carla echa un vistazo más de cerca a la pared. Parece estar compuesta por varios dispositivos grandes con frente de vidrio conectados a cables. En la parte trasera, los dispositivos dicen “LedTec SIG-5030”."
              },
              {
                "type": "paragraph",
                "content": "Una rápida búsqueda en Internet saca a relucir un manual de usuario para estos dispositivos. Parecen ser señales de tráfico, con una matriz programable de luces LED ambarinas. La intención de los humanos probablemente sea mostrar algún tipo de información en ellas durante su evento. Curiosamente, las pantallas pueden ser programadas a través de una red inalámbrica. ¿Podría ser que estén conectadas a la red local del edificio?"
              }
            ]
          },
          {
            "id": "ch11-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada dispositivo en una red recibe una <em>dirección IP</em>, que otros dispositivos pueden usar para enviarle mensajes. Hablamos más sobre eso en el Capítulo 13. Carla nota que sus propios teléfonos reciben direcciones como <code>10.0.0.20</code> o <code>10.0.0.33</code>. Podría valer la pena intentar enviar mensajes a todas esas direcciones y ver si alguna responde a la interfaz descrita en el manual de las señales."
              },
              {
                "type": "paragraph",
                "content": "El Capítulo 18 muestra cómo hacer solicitudes reales en redes reales. En este capítulo, usaremos una función ficticia simplificada llamada <code>request</code> para la comunicación en red. Esta función toma dos argumentos: una dirección de red y un mensaje, que puede ser cualquier cosa que se pueda enviar como JSON, y devuelve una promesa que se resuelve con una respuesta de la máquina en la dirección dada, o se rechaza si hubo un problema."
              },
              {
                "type": "paragraph",
                "content": "Según el manual, puedes cambiar lo que se muestra en una señal SIG-5030 enviándole un mensaje con contenido como <code>{\"command\": \"display\", \"data\": [0, 0, 3, …]}</code>, donde <code>data</code> contiene un número por cada punto de LED, indicando su brillo; 0 significa apagado, 3 significa brillo máximo. Cada señal tiene 50 luces de ancho y 30 luces de alto, por lo que un comando de actualización debe enviar 1500 números."
              }
            ]
          },
          {
            "id": "ch11-l9-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este código envía un mensaje de actualización de pantalla a todas las direcciones en la red local para ver cuál se queda. Cada uno de los números en una dirección IP puede ir de 0 a 255. En los datos que envía, activa un número de luces correspondiente al último número de la dirección de red."
              },
              {
                "type": "paragraph",
                "content": "Dado que la mayoría de estas direcciones no existirán o no aceptarán tales mensajes, la llamada a <code>catch</code> se asegura de que los errores de red no hagan que el programa falle. Las solicitudes se envían todas inmediatamente, sin esperar a que otras solicitudes terminen, para no perder tiempo cuando algunas de las máquinas no respondan."
              },
              {
                "type": "paragraph",
                "content": "Después de haber iniciado su exploración de red, Carla regresa afuera para ver el resultado. Para su deleite, todas las pantallas ahora muestran una franja de luz en sus esquinas superiores izquierdas. Están en la red local y sí aceptan comandos. Rápidamente toma nota de los números mostrados en cada pantalla. Hay 9 pantallas, dispuestas tres en alto y tres en ancho. Tienen las siguientes direcciones de red:"
              }
            ]
          },
          {
            "id": "ch11-l9-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora esto abre posibilidades para todo tipo de travesuras. Podría mostrar “los cuervos mandan, los humanos babean” en la pared en letras gigantes. Pero eso se siente un poco grosero. En su lugar, planea mostrar un video de un cuervo volando que cubre todas las pantallas por la noche."
              },
              {
                "type": "paragraph",
                "content": "Carla encuentra un clip de video adecuado, en el cual un segundo y medio de metraje se puede repetir para crear un video en bucle mostrando el aleteo de un cuervo. Para ajustarse a las nueve pantallas (cada una de las cuales puede mostrar 50 por 30 píxeles), Carla corta y redimensiona los videos para obtener una serie de imágenes de 150 por 90, diez por segundo. Estas luego se cortan en nueve rectángulos cada una, y se procesan para que los puntos oscuros en el video (donde está el cuervo) muestren una luz brillante, y los puntos claros (sin cuervo) permanezcan oscuros, lo que debería crear el efecto de un cuervo ámbar volando contra un fondo negro."
              },
              {
                "type": "paragraph",
                "content": "Ella ha configurado la variable <code>clipImages</code> para contener un array de fotogramas, donde cada fotograma se representa con un array de nueve conjuntos de píxeles, uno para cada pantalla, en el formato que los letreros esperan."
              }
            ]
          },
          {
            "id": "ch11-l9-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para mostrar un único fotograma del video, Carla necesita enviar una solicitud a todas las pantallas a la vez. Pero también necesita esperar el resultado de estas solicitudes, tanto para no comenzar a enviar el siguiente fotograma antes de que el actual se haya enviado correctamente, como para notar cuando las solicitudes están fallando."
              },
              {
                "type": "paragraph",
                "content": "<code>Promise</code> tiene un método estático <code>all</code> que se puede usar para convertir un array de promesas en una sola promesa que se resuelve en un array de resultados. Esto proporciona una forma conveniente de que algunas acciones asíncronas sucedan al lado unas de otras, esperar a que todas terminen y luego hacer algo con sus resultados (o al menos esperar a que terminen para asegurarse de que no fallen)."
              },
              {
                "type": "paragraph",
                "content": "Esto recorre las imágenes en <code>frame</code> (que es un array de arrays de datos de visualización) para crear un array de promesas de solicitud. Luego devuelve una promesa que combina todas esas promesas."
              }
            ]
          },
          {
            "id": "ch11-l9-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para poder detener un video en reproducción, el proceso está envuelto en una clase. Esta clase tiene un método asíncrono <code>play</code> que devuelve una promesa que solo se resuelve cuando la reproducción se detiene de nuevo a través del método <code>stop</code>."
              },
              {
                "type": "paragraph",
                "content": "La función <code>wait</code> envuelve <code>setTimeout</code> en una promesa que se resuelve después del número de milisegundos especificado. Esto es útil para controlar la velocidad de reproducción."
              },
              {
                "type": "paragraph",
                "content": "Durante toda la semana que dura el muro de pantalla, todas las noches, cuando está oscuro, aparece misteriosamente un enorme pájaro naranja brillante en él."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      },
      {
        "id": "ch11-l10",
        "title": "El bucle de eventos",
        "sections": [
          {
            "id": "ch11-l10-s0",
            "title": "El bucle de eventos",
            "content": [
              {
                "type": "paragraph",
                "content": "Un programa asincrónico comienza ejecutando su script principal, que a menudo configurará devoluciones de llamada para ser llamadas más tarde. Ese script principal, así como las devoluciones de llamada, se ejecutan por completo de una vez, sin interrupciones. Pero entre ellos, el programa puede estar inactivo, esperando a que ocurra algo."
              },
              {
                "type": "paragraph",
                "content": "Por lo tanto, las devoluciones de llamada no son llamadas directamente por el código que las programó. Si llamo a <code>setTimeout</code> desde dentro de una función, esa función ya habrá retornado en el momento en que se llame a la función de devolución de llamada. Y cuando la devolución de llamada regresa, el control no vuelve a la función que lo programó."
              },
              {
                "type": "paragraph",
                "content": "El comportamiento asincrónico ocurre en su propia función vacía pila de llamadas. Esta es una de las razones por las que, sin promesas, gestionar excepciones en código asincrónico es tan difícil. Dado que cada devolución de llamada comienza con una pila de llamadas en su mayoría vacía, sus manejadores de <code>catch</code> no estarán en la pila cuando lancen una excepción."
              }
            ]
          },
          {
            "id": "ch11-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "No importa cuán cerca ocurran eventos, como tiempos de espera o solicitudes entrantes, un entorno JavaScript ejecutará solo un programa a la vez. Puedes pensar en esto como ejecutar un gran bucle <em>alrededor</em> de tu programa, llamado el <em>bucle de eventos</em>. Cuando no hay nada que hacer, ese bucle se pausa. Pero a medida que llegan eventos, se agregan a una cola y su código se ejecuta uno tras otro. Debido a que no se ejecutan dos cosas al mismo tiempo, un código lento puede retrasar el manejo de otros eventos."
              },
              {
                "type": "paragraph",
                "content": "Este ejemplo establece un tiempo de espera pero luego se demora hasta después del momento previsto para el tiempo de espera, provocando que el tiempo de espera sea tardío."
              },
              {
                "type": "paragraph",
                "content": "Las promesas siempre se resuelven o se rechazan como un nuevo evento. Incluso si una promesa ya está resuelta, esperarla hará que su devolución de llamada se ejecute después de que termine el script actual, en lugar de inmediatamente."
              }
            ]
          },
          {
            "id": "ch11-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En capítulos posteriores veremos varios tipos de eventos que se ejecutan en el bucle de eventos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch11-l11",
        "title": "Errores asincrónicos",
        "sections": [
          {
            "id": "ch11-l11-s0",
            "title": "Errores asincrónicos",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando tu programa se ejecuta de forma síncrona, de una sola vez, no hay cambios de estado ocurriendo excepto aquellos que el programa mismo realiza. Para programas asíncronos esto es diferente, pueden tener <em>brechas</em> en su ejecución durante las cuales otro código puede correr."
              },
              {
                "type": "paragraph",
                "content": "Veamos un ejemplo. Esta es una función que intenta reportar el tamaño de cada archivo en un arreglo de archivos, asegurándose de leerlos todos al mismo tiempo en lugar de en secuencia."
              },
              {
                "type": "paragraph",
                "content": "La parte <code>async fileName =&gt;</code> muestra cómo también se pueden hacer arrow functions <code>async</code> colocando la palabra <code>async</code> delante de ellas."
              }
            ]
          },
          {
            "id": "ch11-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El código no parece ser sospechoso de inmediato... mapea la función flecha <code>async</code> sobre el arreglo de nombres, creando un arreglo de promesas, y luego usa <code>Promise.all</code> para esperar a todas ellas antes de devolver la lista que construyen."
              },
              {
                "type": "paragraph",
                "content": "Pero está totalmente roto. Siempre devolverá solo una línea de salida, enumerando el archivo que tardó más en leer."
              },
              {
                "type": "paragraph",
                "content": "¿Puedes descubrir por qué?"
              }
            ]
          },
          {
            "id": "ch11-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El problema radica en el operador <code>+=</code>, que toma el valor <em>actual</em> de <code>lista</code> en el momento en que comienza a ejecutarse la instrucción y luego, cuando el <code>await</code> termina, establece el enlace <code>lista</code> como ese valor más la cadena agregada."
              },
              {
                "type": "paragraph",
                "content": "Pero entre el momento en que comienza a ejecutarse la instrucción y el momento en que termina, hay una brecha asincrónica. La expresión <code>map</code> se ejecuta antes de que se agregue cualquier cosa a la lista, por lo que cada uno de los operadores <code>+=</code> comienza desde una cadena vacía y termina, cuando termina su recuperación de almacenamiento, estableciendo <code>lista</code> en el resultado de agregar su línea a la cadena vacía."
              },
              {
                "type": "paragraph",
                "content": "Esto podría haberse evitado fácilmente devolviendo las líneas de las promesas mapeadas y llamando a <code>join</code> en el resultado de <code>Promise.all</code>, en lugar de construir la lista cambiando un enlace. Como suele ser, calcular nuevos valores es menos propenso a errores que cambiar valores existentes."
              }
            ]
          },
          {
            "id": "ch11-l11-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Errores como este son fáciles de cometer, especialmente al usar <code>await</code>, y debes ser consciente de dónde ocurren las brechas en tu código. Una ventaja de la asincronía <em>explícita</em> de JavaScript (ya sea a través de devoluciones de llamada, promesas o <code>await</code>) es que identificar estas brechas es relativamente fácil."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch11-l12",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch11-l12-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "La programación asincrónica hace posible expresar la espera de acciones de larga duración sin congelar todo el programa. Los entornos de JavaScript típicamente implementan este estilo de programación utilizando devoluciones de llamada, funciones que se llaman cuando las acciones se completan. Un bucle de eventos programa estas devoluciones de llamada para que se llamen cuando sea apropiado, una tras otra, de modo que su ejecución no se superponga.La programación de forma asíncrona se facilita gracias a las promesas, que son objetos que representan acciones que podrían completarse en el futuro, y las funciones <code>async</code>, que te permiten escribir un programa asíncrono como si fuera sincrónico."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch11-l13",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch11-l13-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay una cámara de seguridad cerca del laboratorio de Carla que se activa con un sensor de movimiento. Está conectada a la red y comienza a enviar un flujo de video cuando está activa. Como prefiere no ser descubierta, Carla ha configurado un sistema que detecta este tipo de tráfico de red inalámbrico y enciende una luz en su guarida cada vez que hay actividad afuera, para que ella sepa cuándo mantenerse en silencio."
              },
              {
                "type": "paragraph",
                "content": "También ha estado registrando los momentos en que la cámara se activa desde hace un tiempo, y quiere utilizar esta información para visualizar qué momentos, en una semana promedio, tienden a ser tranquilos y cuáles tienden a ser ocupados. El registro se almacena en archivos que contienen un número de marca de tiempo por línea (como devuelto por <code>Date.now()</code>)."
              },
              {
                "type": "paragraph",
                "content": "El archivo <code>\"camera_logs.<wbr>txt\"</code> contiene una lista de archivos de registro. Escribe una función asíncrona <code>activityTable(día)</code> que, para un día de la semana dado, devuelva un array de 24 números, uno para cada hora del día, que contenga la cantidad de observaciones de tráfico de red de la cámara vista en esa hora del día. Los días se identifican por número utilizando el sistema utilizado por <code>Date.getDay</code>, donde el domingo es 0 y el sábado es 6."
              }
            ]
          },
          {
            "id": "ch11-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>activityGraph</code>, proporcionada por el sandbox, resume dicha tabla en una cadena."
              },
              {
                "type": "paragraph",
                "content": "Utiliza la función <code>textFile</code> definida anteriormente, que al recibir un nombre de archivo devuelve una promesa que se resuelve en el contenido del archivo. Recuerda que <code>new Date(marcaDeTiempo)</code> crea un objeto <code>Date</code> para ese momento, que tiene métodos <code>getDay</code> y <code>getHours</code> que devuelven el día de la semana y la hora del día."
              },
              {
                "type": "paragraph",
                "content": "Ambos tipos de archivos, la lista de archivos de registro y los propios archivos de registro, tienen cada dato en su propia línea, separados por caracteres de nueva línea (<code>\"\\n\"</code>)."
              }
            ]
          },
          {
            "id": "ch11-l13-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Necesitarás convertir el contenido de estos archivos en un array. La forma más fácil de hacerlo es utilizando el método <code>split</code> en la cadena producida por <code>textFile</code>. Ten en cuenta que para los archivos de registro, eso seguirá dándote un array de cadenas, que debes convertir a números antes de pasarlos a <code>new Date</code>."
              },
              {
                "type": "paragraph",
                "content": "Resumir todos los puntos temporales en una tabla de horas se puede hacer creando una tabla (array) que contenga un número para cada hora del día. Luego puedes recorrer todos los marca de tiempos (sobre los archivos de registro y los números en cada archivo de registro) y, para cada uno, si sucedió en el día correcto, toma la hora en que ocurrió y suma uno al número correspondiente en la tabla."
              },
              {
                "type": "paragraph",
                "content": "Asegúrate de usar <code>await</code> en el resultado de las funciones asíncronas antes de hacer cualquier cosa con él, o terminarás con una <code>Promise</code> donde esperabas un string."
              }
            ]
          },
          {
            "id": "ch11-l13-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "hinting}}"
              },
              {
                "type": "paragraph",
                "content": "Reescribe la función del ejercicio anterior sin <code>async</code>/<code>await</code>, utilizando métodos simples de <code>Promise</code>."
              },
              {
                "type": "paragraph",
                "content": "En este estilo, usar <code>Promise.all</code> será más conveniente que intentar modelar un bucle sobre los archivos de registro. En la función <code>async</code>, simplemente usar <code>await</code> en un bucle es más simple. Si leer un archivo toma un tiempo, ¿cuál de estos dos enfoques tomará menos tiempo para ejecutarse?"
              }
            ]
          },
          {
            "id": "ch11-l13-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si uno de los archivos listados en la lista de archivos tiene un error tipográfico, y falla al leerlo, ¿cómo termina ese fallo en el objeto <code>Promise</code> que retorna tu función?"
              },
              {
                "type": "paragraph",
                "content": "El enfoque más directo para escribir esta función es usar una cadena de llamadas <code>then</code>. La primera promesa se produce al leer la lista de archivos de registro. El primer callback puede dividir esta lista y mapear <code>textFile</code> sobre ella para obtener una matriz de promesas para pasar a <code>Promise.all</code>. Puede devolver el objeto devuelto por <code>Promise.all</code>, para que lo que sea que eso devuelva se convierta en el resultado del valor de retorno de este primer <code>then</code>."
              },
              {
                "type": "paragraph",
                "content": "Ahora tenemos una promesa que devuelve un array de archivos de registro. Podemos llamar a <code>then</code> nuevamente en eso, y poner la lógica de conteo de marcas de tiempo allí. Algo así:"
              }
            ]
          },
          {
            "id": "ch11-l13-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "O podrías, para una programación aún mejor, poner el análisis de cada archivo dentro de <code>Promise.all</code>, para que ese trabajo pueda comenzar para el primer archivo que regresa del disco, incluso antes de que los otros archivos regresen."
              },
              {
                "type": "paragraph",
                "content": "Lo que muestra que la forma en que estructuras tus promesas puede tener un efecto real en la forma en que se programa el trabajo. Un simple bucle con <code>await</code> hará que el proceso sea completamente lineal: espera a que se cargue cada archivo antes de continuar. <code>Promise.all</code> hace posible que varias tareas sean trabajadas conceptualmente al mismo tiempo, permitiéndoles progresar mientras los archivos aún se están cargando. Esto puede ser más rápido, pero también hace que el orden en que sucederán las cosas sea menos predecible. En este caso, donde solo vamos a estar incrementando números en una tabla, eso no es difícil de hacer de manera segura. Para otros tipos de problemas, puede ser mucho más difícil."
              },
              {
                "type": "paragraph",
                "content": "Cuando un archivo en la lista no existe, la promesa devuelta por <code>textFile</code> será rechazada. Debido a que <code>Promise.all</code> se rechaza si alguna de las promesas que se le pasan falla, el valor de retorno de la devolución de llamada dada al primer <code>then</code> también será una promesa rechazada. Esto hace que la promesa devuelta por <code>then</code> falle, por lo que la devolución de llamada dada al segundo <code>then</code> ni siquiera se llama, y se devuelve una promesa rechazada desde la función."
              }
            ]
          },
          {
            "id": "ch11-l13-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Como vimos, dado un array de promesas, <code>Promise.all</code> devuelve una promesa que espera a que todas las promesas en el array finalicen. Luego tiene éxito, devolviendo un array de valores de resultado. Si una promesa en el array falla, la promesa devuelta por <code>all</code> también falla, con la razón de fallo de la promesa que falló."
              },
              {
                "type": "paragraph",
                "content": "Implementa algo similar tú mismo como una función regular llamada <code>Promise_all</code>."
              },
              {
                "type": "paragraph",
                "content": "Recuerda que después de que una promesa tiene éxito o falla, no puede volver a tener éxito o fallar, y las llamadas posteriores a las funciones que la resuelven se ignoran. Esto puede simplificar la forma en que manejas el fallo de tu promesa."
              }
            ]
          },
          {
            "id": "ch11-l13-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función pasada al constructor <code>Promise</code> tendrá que llamar a <code>then</code> en cada una de las promesas en el array dado. Cuando una de ellas tiene éxito, dos cosas deben suceder. El valor resultante debe ser almacenado en la posición correcta de un array de resultados, y debemos verificar si esta era la última promesa pendiente y finalizar nuestra propia promesa si lo era."
              },
              {
                "type": "paragraph",
                "content": "Esto último se puede hacer con un contador que se inicializa con la longitud del array de entrada y del cual restamos 1 cada vez que una promesa tiene éxito. Cuando llegue a 0, hemos terminado. Asegúrate de tener en cuenta la situación en la que el array de entrada está vacío (y por lo tanto ninguna promesa se resolverá nunca)."
              },
              {
                "type": "paragraph",
                "content": "Manejar el fallo requiere un poco de pensamiento pero resulta ser extremadamente simple. Simplemente pasa la función <code>reject</code> de la promesa contenedora a cada una de las promesas en el array como un controlador <code>catch</code> o como un segundo argumento para <code>then</code> para que un fallo en una de ellas desencadene el rechazo de toda la promesa contenedora."
              }
            ]
          },
          {
            "id": "ch11-l13-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "pista"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 65
      }
    ]
  },
  {
    "id": "ch12",
    "number": 12,
    "title": "Proyecto: Un Lenguaje de Programación",
    "titleEs": "Proyecto: Un Lenguaje de Programación",
    "part": "part1",
    "partLabel": "Parte 1: Lenguaje",
    "icon": "BookOpen",
    "description": "El evaluador, que determina el significado de expresiones en un lenguaje de programación, es solo otro programa....",
    "isProject": true,
    "totalXP": 325,
    "lessons": [
      {
        "id": "ch12-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch12-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "El evaluador, que determina el significado de expresiones en un lenguaje de programación, es solo otro programa. Hal Abelson y Gerald Sussman, Estructura e Interpretación de Programas de Computadora"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un Lenguaje de Programación __ Eloquent JavaScript_files/chapter_picture_12.jpg",
                "alt": "Ilustración que muestra un huevo con agujeros, mostrando huevos más pequeños dentro, que a su vez tienen huevos aún más pequeños dentro de ellos, y así sucesivamente"
              },
              {
                "type": "paragraph",
                "content": "Crear tu propio lenguaje de programación es sorprendentemente fácil (si no apuntas muy alto) y muy esclarecedor."
              }
            ]
          },
          {
            "id": "ch12-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Lo principal que quiero mostrar en este capítulo es que no hay magia involucrada en la construcción de un lenguaje de programación. A menudo he sentido que algunas invenciones humanas eran tan inmensamente inteligentes y complicadas que nunca las entendería. Pero con un poco de lectura y experimentación, a menudo resultan ser bastante mundanas."
              },
              {
                "type": "paragraph",
                "content": "Construiremos un lenguaje de programación llamado Egg. Será un lenguaje simple y diminuto, pero lo suficientemente poderoso como para expresar cualquier cálculo que puedas imaginar. Permitirá una simple abstracción basada en funciones."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch12-l1",
        "title": "Análisis Sintáctico",
        "sections": [
          {
            "id": "ch12-l1-s0",
            "title": "Análisis Sintáctico",
            "content": [
              {
                "type": "paragraph",
                "content": "La parte más inmediatamente visible de un lenguaje de programación es su <em>sintaxis</em>, o notación. Un <em>analizador sintáctico</em> es un programa que lee un fragmento de texto y produce una estructura de datos que refleja la estructura del programa contenido en ese texto. Si el texto no forma un programa válido, el analizador sintáctico debería señalar el error."
              },
              {
                "type": "paragraph",
                "content": "Nuestro lenguaje tendrá una sintaxis simple y uniforme. Todo en Egg es una expresión. Una expresión puede ser el nombre de una asignación, un número, una cadena o una <em>aplicación</em>. Las aplicaciones se utilizan para llamadas de funciones pero también para estructuras como <code>if</code> o <code>while</code>."
              },
              {
                "type": "paragraph",
                "content": "Para mantener el analizador sintáctico simple, las cadenas en Egg no admiten nada parecido a los escapes con barra invertida. Una cadena es simplemente una secuencia de caracteres que no son comillas dobles, envueltos entre comillas dobles. Un número es una secuencia de dígitos. Los nombres de las asignaciones pueden consistir en cualquier carácter que no sea espacio en blanco y que no tenga un significado especial en la sintaxis."
              }
            ]
          },
          {
            "id": "ch12-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las aplicaciones se escriben de la misma manera que en JavaScript, colocando paréntesis después de una expresión y teniendo cualquier número de argumentos entre esos paréntesis, separados por comas."
              },
              {
                "type": "paragraph",
                "content": "La uniformidad del lenguaje Egg significa que las cosas que son operadores en JavaScript (como <code>&gt;</code>) son asignaciones normales en este lenguaje, aplicadas de la misma manera que otras funciones. Y dado que la sintaxis no tiene concepto de bloque, necesitamos un constructo <code>do</code> para representar la realización de múltiples tareas en secuencia."
              },
              {
                "type": "paragraph",
                "content": "La estructura de datos que el analizador sintáctico utilizará para describir un programa consiste en objetos expresión, cada uno de los cuales tiene una propiedad <code>type</code> que indica el tipo de expresión que es y otras propiedades para describir su contenido."
              }
            ]
          },
          {
            "id": "ch12-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las expresiones de tipo <code>\"value\"</code> representan cadenas literales o números. Su propiedad <code>value</code> contiene el valor de cadena o número que representan. Las expresiones de tipo <code>\"word\"</code> se utilizan para identificadores (nombres). Estos objetos tienen una propiedad <code>name</code> que contiene el nombre del identificador como cadena. Finalmente, las expresiones <code>\"apply\"</code> representan aplicaciones. Tienen una propiedad <code>operator</code> que se refiere a la expresión que se está aplicando, así como una propiedad <code>args</code> que contiene una serie de expresiones de argumento."
              },
              {
                "type": "paragraph",
                "content": "La parte <code>&gt;(x, 5)</code> del programa anterior se representaría de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "Esta estructura de datos se llama un <em>árbol de sintaxis</em>. Si te imaginas los objetos como puntos y los enlaces entre ellos como líneas entre esos puntos, tiene una forma similar a un árbol. El hecho de que las expresiones contienen otras expresiones, que a su vez pueden contener más expresiones, es similar a la forma en que las ramas de un árbol se dividen y vuelven a dividir."
              }
            ]
          },
          {
            "id": "ch12-l1-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un Lenguaje de Programación __ Eloquent JavaScript_files/syntax_tree.svg",
                "alt": "Un diagrama que muestra la estructura del árbol de sintaxis del programa de ejemplo. La raíz está etiquetada como &#39;do&#39; y tiene dos hijos, uno etiquetado como &#39;define&#39; y otro como &#39;if&#39;. A su vez, estos tienen más hijos que describen su contenido."
              },
              {
                "type": "paragraph",
                "content": "Contrasta esto con el analizador que escribimos para el formato de archivo de configuración en el Capítulo 9, que tenía una estructura simple: dividía la entrada en líneas y manejaba esas líneas una a la vez. Solo había algunas formas simples que una línea podía tener."
              },
              {
                "type": "paragraph",
                "content": "Aquí debemos encontrar un enfoque diferente. Las expresiones no están separadas en líneas, y tienen una estructura recursiva. Las expresiones de aplicación <em>contienen</em> otras expresiones."
              }
            ]
          },
          {
            "id": "ch12-l1-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Afortunadamente, este problema puede resolverse muy bien escribiendo una función de análisis sintáctico que sea recursiva de una manera que refleje la naturaleza recursiva del lenguaje."
              },
              {
                "type": "paragraph",
                "content": "Definimos una función <code>parseExpression</code>, que recibe una cadena como entrada y devuelve un objeto que contiene la estructura de datos de la expresión al inicio de la cadena, junto con la parte de la cadena que queda después de analizar esta expresión. Al analizar subexpresiones (el argumento de una aplicación, por ejemplo), esta función puede ser llamada nuevamente, obteniendo la expresión de argumento así como el texto que queda. Este texto a su vez puede contener más argumentos o puede ser el paréntesis de cierre que finaliza la lista de argumentos.Esta es la primera parte del analizador sintáctico:"
              },
              {
                "type": "paragraph",
                "content": "Debido a que Egg, al igual que JavaScript, permite cualquier cantidad de espacios en blanco entre sus elementos, debemos cortar repetidamente el espacio en blanco del inicio de la cadena del programa. Eso es para lo que sirve la función <code>skipSpace</code>."
              }
            ]
          },
          {
            "id": "ch12-l1-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Después de omitir cualquier espacio inicial, <code>parseExpression</code> utiliza tres expresiones regulares para detectar los tres elementos atómicos que admite Egg: cadenas, números y palabras. El analizador construye un tipo diferente de estructura de datos dependiendo de cuál de ellos coincida. Si la entrada no coincide con ninguna de estas tres formas, no es una expresión válida y el analizador genera un error. Utilizamos el constructor <code>SyntaxError</code> aquí. Esta es una clase de excepción definida por el estándar, al igual que <code>Error</code>, pero más específica."
              },
              {
                "type": "paragraph",
                "content": "Luego cortamos la parte que coincidió de la cadena del programa y la pasamos, junto con el objeto de la expresión, a <code>parseApply</code>, que verifica si la expresión es una aplicación. Si lo es, analiza una lista de argumentos entre paréntesis."
              },
              {
                "type": "paragraph",
                "content": "Si el próximo carácter en el programa no es un paréntesis de apertura, esto no es una aplicación y <code>parseApply</code> devuelve la expresión que se le dio."
              }
            ]
          },
          {
            "id": "ch12-l1-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "De lo contrario, se salta el paréntesis de apertura y crea el objeto árbol sintáctico para esta expresión de aplicación. Luego llama recursivamente a <code>parseExpression</code> para analizar cada argumento hasta encontrar un paréntesis de cierre. La recursión es indirecta, a través de <code>parseApply</code> y <code>parseExpression</code> llamándose mutuamente."
              },
              {
                "type": "paragraph",
                "content": "Dado que una expresión de aplicación puede a su vez ser aplicada (como en <code>multiplicador(2)(1)</code>), <code>parseApply</code> debe, después de analizar una aplicación, llamarse a sí misma nuevamente para verificar si sigue otro par de paréntesis."
              },
              {
                "type": "paragraph",
                "content": "Esto es todo lo que necesitamos para analizar Egg. Lo envolvemos en una conveniente <code>parse</code> función que verifica que ha llegado al final de la cadena de entrada después de analizar la expresión (un programa Egg es una sola expresión), y que nos da la estructura de datos del programa."
              }
            ]
          },
          {
            "id": "ch12-l1-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "¡Funciona! No nos da información muy útil cuando falla y no almacena la línea y la columna en las que comienza cada expresión, lo cual podría ser útil al informar errores más tarde, pero es suficiente para nuestros propósitos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 60
      },
      {
        "id": "ch12-l2",
        "title": "El evaluador",
        "sections": [
          {
            "id": "ch12-l2-s0",
            "title": "El evaluador",
            "content": [
              {
                "type": "paragraph",
                "content": "¿Qué podemos hacer con el árbol de sintaxis de un programa? ¡Ejecutarlo, por supuesto! Y eso es lo que hace el evaluador. Le das un árbol de sintaxis y un objeto de ámbito que asocia nombres con valores, y evaluará la expresión que representa el árbol y devolverá el valor que esto produce."
              },
              {
                "type": "paragraph",
                "content": "El evaluador tiene código para cada uno de los tipos de expresión. Una expresión de valor literal produce su valor. (Por ejemplo, la expresión <code>100</code> simplemente se evalúa como el número 100.) Para un enlace, debemos verificar si está realmente definido en el ámbito y, si lo está, obtener el valor del enlace."
              },
              {
                "type": "paragraph",
                "content": "Las aplicaciones son más complicadas. Si son una forma especial, como <code>if</code>, no evaluamos nada y pasamos las expresiones de argumento, junto con el ámbito, a la función que maneja esta forma. Si es una llamada normal, evaluamos el operador, verificamos que sea una función, y la llamamos con los argumentos evaluados."
              }
            ]
          },
          {
            "id": "ch12-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Usamos valores de función JavaScript simples para representar los valores de función de Egg. Volveremos a esto más tarde, cuando se defina la forma especial llamada <code>fun</code>."
              },
              {
                "type": "paragraph",
                "content": "La estructura recursiva de <code>evaluate</code> se asemeja a la estructura similar del analizador sintáctico, y ambos reflejan la estructura del lenguaje en sí. También sería posible combinar el analizador sintáctico y el evaluador en una sola función, y evaluar durante el análisis sintáctico. Pero dividirlos de esta manera hace que el programa sea más claro y flexible."
              },
              {
                "type": "paragraph",
                "content": "Esto es realmente todo lo que se necesita para interpretar Egg. Es así de simple. Pero sin definir algunas formas especiales y agregar algunos valores útiles al entorno, todavía no puedes hacer mucho con este lenguaje."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch12-l3",
        "title": "Formas especiales",
        "sections": [
          {
            "id": "ch12-l3-s0",
            "title": "Formas especiales",
            "content": [
              {
                "type": "paragraph",
                "content": "El objeto <code>specialForms</code> se utiliza para definir sintaxis especial en Egg. Asocia palabras con funciones que evalúan dichas formas. Actualmente está vacío. Añadamos <code>if</code>."
              },
              {
                "type": "paragraph",
                "content": "La construcción <code>if</code> de Egg espera exactamente tres argumentos. Evaluará el primero, y si el resultado no es el valor <code>false</code>, evaluará el segundo. De lo contrario, se evaluará el tercero. Esta forma <code>if</code> se asemeja más al operador ternario <code>?:</code> de JavaScript que al <code>if</code> de JavaScript. Es una expresión, no una declaración, y produce un valor, concretamente, el resultado del segundo o tercer argumento."
              },
              {
                "type": "paragraph",
                "content": "Egg también difiere de JavaScript en cómo maneja el valor de condición para <code>if</code>. No tratará cosas como cero o la cadena vacía como falso, solo el valor preciso <code>false</code>."
              }
            ]
          },
          {
            "id": "ch12-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La razón por la que necesitamos representar <code>if</code> como una forma especial, en lugar de una función regular, es que todos los argumentos de las funciones se evalúan antes de llamar a la función, mientras que <code>if</code> debe evaluar solo <em>uno</em> de sus segundos o terceros argumentos, dependiendo del valor del primero."
              },
              {
                "type": "paragraph",
                "content": "La forma <code>while</code> es similar."
              },
              {
                "type": "paragraph",
                "content": "Otro bloque básico es <code>do</code>, que ejecuta todos sus argumentos de arriba abajo. Su valor es el valor producido por el último argumento."
              }
            ]
          },
          {
            "id": "ch12-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para poder crear vinculaciones y darles nuevos valores, también creamos una forma llamada <code>define</code>. Espera una palabra como su primer argumento y una expresión que produzca el valor a asignar a esa palabra como su segundo argumento. Dado que <code>define</code>, al igual que todo, es una expresión, debe devolver un valor. Haremos que devuelva el valor que se asignó (como el operador <code>=</code> de JavaScript)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch12-l4",
        "title": "El entorno",
        "sections": [
          {
            "id": "ch12-l4-s0",
            "title": "El entorno",
            "content": [
              {
                "type": "paragraph",
                "content": "El scope aceptado por <code>evaluate</code> es un objeto con propiedades cuyos nombres corresponden a los nombres de los bindings y cuyos valores corresponden a los valores a los que esos bindings están ligados. Definamos un objeto para representar el scope global."
              },
              {
                "type": "paragraph",
                "content": "Para poder usar la construcción <code>if</code> que acabamos de definir, necesitamos tener acceso a valores Booleanos. Dado que solo hay dos valores Booleanos, no necesitamos una sintaxis especial para ellos. Simplemente asignamos dos nombres a los valores <code>true</code> y <code>false</code> y los usamos."
              },
              {
                "type": "paragraph",
                "content": "Ahora podemos evaluar una expresión simple que niega un valor Booleano."
              }
            ]
          },
          {
            "id": "ch12-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para suministrar operadores básicos de aritmética y comparación, también agregaremos algunas funciones al scope. En aras de mantener el código corto, usaremos <code>Function</code> para sintetizar un conjunto de funciones de operadores en un bucle, en lugar de definirlas individualmente."
              },
              {
                "type": "paragraph",
                "content": "También es útil tener una forma de imprimir valores, por lo que envolveremos <code>console.log</code> en una función y la llamaremos <code>print</code>."
              },
              {
                "type": "paragraph",
                "content": "Esto nos proporciona suficientes herramientas elementales para escribir programas simples. La siguiente función proporciona una forma conveniente de analizar un programa y ejecutarlo en un nuevo ámbito:"
              }
            ]
          },
          {
            "id": "ch12-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Utilizaremos las cadenas de prototipos de objetos para representar ámbitos anidados para que el programa pueda agregar bindings a su ámbito local sin modificar el ámbito de nivel superior."
              },
              {
                "type": "paragraph",
                "content": "Este es el programa que hemos visto varias veces antes, que calcula la suma de los números del 1 al 10, expresado en Egg. Es claramente más feo que el equivalente programa en JavaScript, pero no está mal para un lenguaje implementado en menos de 150 líneas de código."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch12-l5",
        "title": "Funciones",
        "sections": [
          {
            "id": "ch12-l5-s0",
            "title": "Funciones",
            "content": [
              {
                "type": "paragraph",
                "content": "Un lenguaje de programación sin funciones es un pobre lenguaje de programación."
              },
              {
                "type": "paragraph",
                "content": "Afortunadamente, no es difícil agregar una construcción <code>fun</code>, que trata su último argumento como el cuerpo de la función y utiliza todos los argumentos anteriores como los nombres de los parámetros de la función."
              },
              {
                "type": "paragraph",
                "content": "Las funciones en Egg tienen su propio ámbito local. La función producida por la forma <code>fun</code> crea este ámbito local y añade los enlaces de los argumentos a él. Luego evalúa el cuerpo de la función en este ámbito y devuelve el resultado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch12-l6",
        "title": "Compilación",
        "sections": [
          {
            "id": "ch12-l6-s0",
            "title": "Compilación",
            "content": [
              {
                "type": "paragraph",
                "content": "Lo que hemos construido es un intérprete. Durante la evaluación, actúa directamente sobre la representación del programa producido por el analizador sintáctico."
              },
              {
                "type": "paragraph",
                "content": "<em>La compilación</em> es el proceso de agregar otro paso entre el análisis sintáctico y la ejecución de un programa, que transforma el programa en algo que puede ser evaluado de manera más eficiente al hacer la mayor cantidad de trabajo posible por adelantado. Por ejemplo, en lenguajes bien diseñados, es obvio, para cada uso de un enlace, a qué enlace se hace referencia, sin ejecutar realmente el programa. Esto se puede utilizar para evitar buscar el enlace por nombre cada vez que se accede, en su lugar, recuperándolo directamente desde una ubicación de memoria predeterminada."
              },
              {
                "type": "paragraph",
                "content": "Tradicionalmente, compilar implica convertir el programa a código máquina, el formato en bruto que un procesador de computadora puede ejecutar. Pero cualquier proceso que convierta un programa a una representación diferente se puede considerar como compilación."
              }
            ]
          },
          {
            "id": "ch12-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Sería posible escribir una estrategia de evaluación alternativa para Egg, una que primero convierte el programa a un programa JavaScript, usa <code>Function</code> para invocar el compilador de JavaScript en él, y luego ejecuta el resultado. Cuando se hace correctamente, esto haría que Egg se ejecutara muy rápido y aún así fuera bastante simple de implementar."
              },
              {
                "type": "paragraph",
                "content": "Si te interesa este tema y estás dispuesto a dedicar tiempo a ello, te animo a intentar implementar ese compilador como ejercicio."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch12-l7",
        "title": "Haciendo trampa",
        "sections": [
          {
            "id": "ch12-l7-s0",
            "title": "Haciendo trampa",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando definimos <code>if</code> y <code>while</code>, probablemente notaste que eran envoltorios más o menos triviales alrededor del propio <code>if</code> y <code>while</code> de JavaScript. De manera similar, los valores en Egg son simplemente valores regulares de JavaScript. Cerrar la brecha hacia un sistema más primitivo, como el código máquina que entiende el procesador, requiere más esfuerzo, pero la forma en que funciona se asemeja a lo que estamos haciendo aquí.Aunque el lenguaje de juguete de este capítulo no hace nada que no se pudiera hacer mejor en JavaScript, <em>sí</em> hay situaciones donde escribir pequeños lenguajes ayuda a realizar trabajos reales."
              },
              {
                "type": "paragraph",
                "content": "Tal lenguaje no tiene por qué parecerse a un lenguaje de programación típico. Si JavaScript no viniera equipado con expresiones regulares, por ejemplo, podrías escribir tu propio analizador sintáctico y evaluador para expresiones regulares."
              },
              {
                "type": "paragraph",
                "content": "O imagina que estás construyendo un programa que permite crear rápidamente analizadores sintácticos al proporcionar una descripción lógica del lenguaje que necesitan analizar. Podrías definir una notación específica para eso y un compilador que la convierta en un programa analizador."
              }
            ]
          },
          {
            "id": "ch12-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto es lo que comúnmente se denomina un <em>lenguaje específico de dominio</em>, un lenguaje diseñado para expresar un ámbito estrecho de conocimiento. Tal lenguaje puede ser más expresivo que un lenguaje de propósito general porque está diseñado para describir exactamente las cosas que necesitan ser descritas en su dominio, y nada más."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch12-l8",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch12-l8-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Agrega soporte para arrays en Egg añadiendo las siguientes tres funciones al ámbito superior: <code>array(.<wbr>.<wbr>.<wbr>valores)</code> para construir un array que contenga los valores de los argumentos, <code>length(array)</code> para obtener la longitud de un array y <code>element(array, n)</code> para obtener el n-ésimo elemento de un array."
              },
              {
                "type": "paragraph",
                "content": "La forma más sencilla de hacer esto es representar los arrays de Egg con arrays de JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Los valores añadidos al ámbito superior deben ser funciones. Al usar un argumento restante (con la notación de triple punto), la definición de <code>array</code> puede ser <em>muy</em> simple."
              }
            ]
          },
          {
            "id": "ch12-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La forma en que hemos definido <code>fun</code> permite que las funciones en Egg hagan referencia al ámbito circundante, lo que permite que el cuerpo de la función use valores locales que eran visibles en el momento en que se definió la función, al igual que lo hacen las funciones de JavaScript."
              },
              {
                "type": "paragraph",
                "content": "El siguiente programa ilustra esto: la función <code>f</code> devuelve una función que suma su argumento al argumento de <code>f</code>, lo que significa que necesita acceder al ámbito local dentro de <code>f</code> para poder usar la vinculación <code>a</code>."
              },
              {
                "type": "paragraph",
                "content": "Vuelve a la definición del formulario <code>fun</code> y explica qué mecanismo hace que esto funcione."
              }
            ]
          },
          {
            "id": "ch12-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una vez más, estamos montando un mecanismo en JavaScript para obtener la característica equivalente en Egg. Los formularios especiales reciben el ámbito local en el que se evalúan para que puedan evaluar sus subformas en ese ámbito. La función devuelta por <code>fun</code> tiene acceso al argumento <code>scope</code> dado a su función contenedora y lo utiliza para crear el ámbito local de la función cuando se llama."
              },
              {
                "type": "paragraph",
                "content": "Esto significa que el prototipo del ámbito local será el ámbito en el cual la función fue creada, lo que hace posible acceder a los enlaces en ese ámbito desde la función. Esto es todo lo que se necesita para implementar el cierre (aunque para compilarlo de una manera realmente eficiente, sería necesario hacer un poco más de trabajo)."
              },
              {
                "type": "paragraph",
                "content": "Sería bueno si pudiéramos escribir comentarios en Egg. Por ejemplo, siempre que encontremos un signo de almohadilla (<code>#</code>), podríamos tratar el resto de la línea como un comentario y ignorarlo, similar a <code>//</code> en JavaScript."
              }
            ]
          },
          {
            "id": "ch12-l8-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "No tenemos que hacer grandes cambios en el analizador para admitir esto. Simplemente podemos cambiar <code>skipSpace</code> para omitir comentarios como si fueran espacios en blanco de manera que todos los puntos donde se llama a <code>skipSpace</code> ahora también omitirán comentarios. Realiza este cambio."
              },
              {
                "type": "paragraph",
                "content": "Asegúrate de que tu solución maneje múltiples comentarios seguidos, con posiblemente espacios en blanco entre ellos o después de ellos."
              },
              {
                "type": "paragraph",
                "content": "Una expresión regular es probablemente la forma más sencilla de resolver esto. Escribe algo que coincida con “espacio en blanco o un comentario, cero o más veces”. Utiliza el método <code>exec</code> o <code>match</code> y observa la longitud del primer elemento en la matriz devuelta (la coincidencia completa) para averiguar cuántos caracteres cortar."
              }
            ]
          },
          {
            "id": "ch12-l8-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Actualmente, la única forma de asignar un enlace un valor es <code>define</code>. Esta construcción actúa como una forma tanto de definir nuevos enlaces como de dar un nuevo valor a los existentes."
              },
              {
                "type": "paragraph",
                "content": "Esta ambigüedad causa un problema. Cuando intentas darle un nuevo valor a un enlace no local, terminarás definiendo uno local con el mismo nombre en su lugar. Algunos lenguajes funcionan de esta manera por diseño, pero siempre he encontrado que es una forma incómoda de manejar el ámbito."
              },
              {
                "type": "paragraph",
                "content": "Agrega una forma especial <code>set</code>, similar a <code>define</code>, que da un nuevo valor a un enlace, actualizando el enlace en un ámbito exterior si aún no existe en el ámbito interior. Si el enlace no está definido en absoluto, lanza un <code>ReferenceError</code> (otro tipo de error estándar)."
              }
            ]
          },
          {
            "id": "ch12-l8-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La técnica de representar los ámbitos como objetos simples, que hasta ahora ha sido conveniente, te causará un pequeño problema en este punto. Es posible que desees usar la función <code>Object.<wbr>getPrototypeOf</code>, la cual devuelve el prototipo de un objeto. También recuerda que puedes utilizar <code>Object.hasOwn</code> para verificar si un objeto dado tiene una propiedad."
              },
              {
                "type": "paragraph",
                "content": "Tendrás que iterar a través de un scope a la vez, utilizando <code>Object.<wbr>getPrototypeOf</code> para ir al siguiente ámbito exterior. Para cada ámbito, utiliza <code>Object.hasOwn</code> para determinar si el enlace, indicado por la propiedad <code>name</code> del primer argumento de <code>set</code>, existe en ese ámbito. Si existe, establécelo en el resultado de evaluar el segundo argumento de <code>set</code> y luego devuelve ese valor."
              },
              {
                "type": "paragraph",
                "content": "Si se alcanza el ámbito más externo (<code>Object.<wbr>getPrototypeOf</code> devuelve null) y aún no hemos encontrado el enlace, significa que no existe y se debe lanzar un error."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      }
    ]
  },
  {
    "id": "ch13",
    "number": 13,
    "title": "JavaScript y el Navegador",
    "titleEs": "JavaScript y el Navegador",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "El sueño detrás de la Web es de un espacio de información común en el que nos comunicamos compartiendo información. Su universalidad es esencial: el h...",
    "isProject": false,
    "totalXP": 240,
    "lessons": [
      {
        "id": "ch13-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch13-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "El sueño detrás de la Web es de un espacio de información común en el que nos comunicamos compartiendo información. Su universalidad es esencial: el hecho de que un enlace de hipertexto pueda apuntar a cualquier cosa, ya sea personal, local o global, ya sea un borrador o altamente pulido. Tim Berners-Lee, La World Wide Web: Una historia personal muy breve"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/JavaScript y el Navegador __ Eloquent JavaScript_files/chapter_picture_13.jpg",
                "alt": "Ilustración que muestra una central telefónica"
              },
              {
                "type": "paragraph",
                "content": "Los próximos capítulos de este libro hablarán sobre los navegadores web. Sin los navegadores web, no habría JavaScript. O incluso si existiera, nadie le habría prestado atención."
              }
            ]
          },
          {
            "id": "ch13-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La tecnología web ha sido descentralizada desde el principio, no solo técnicamente, sino también en la forma en que evolucionó. Varios fabricantes de navegadores han añadido nueva funcionalidad de manera ad hoc y a veces sin mucho sentido, que luego, a veces, terminaba siendo adoptada por otros, y finalmente establecida como en los estándares."
              },
              {
                "type": "paragraph",
                "content": "Esto es a la vez una bendición y una maldición. Por un lado, es empoderador no tener a una parte central controlando un sistema, sino mejorando con la contribución de diferentes partes que trabajan en una colaboración laxa (o a veces en abierta hostilidad). Por otro lado, la forma caótica en que se desarrolló la Web significa que el sistema resultante no es precisamente un ejemplo brillante de coherencia interna. Algunas partes son directamente confusas y están mal diseñadas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch13-l1",
        "title": "Redes y el Internet",
        "sections": [
          {
            "id": "ch13-l1-s0",
            "title": "Redes y el Internet",
            "content": [
              {
                "type": "paragraph",
                "content": "Las redes de computadoras existen desde la década de 1950. Si conectas cables entre dos o más computadoras y les permites enviar datos de ida y vuelta a través de estos cables, puedes hacer todo tipo de cosas maravillosas."
              },
              {
                "type": "paragraph",
                "content": "Y si conectar dos máquinas en el mismo edificio nos permite hacer cosas maravillosas, conectar máquinas en todo el planeta debería ser aún mejor. La tecnología para comenzar a implementar esta visión se desarrolló en la década de 1980, y la red resultante se llama el <em>Internet</em>. Ha cumplido su promesa."
              },
              {
                "type": "paragraph",
                "content": "Una computadora puede usar esta red para enviar bits a otra computadora. Para que surja una comunicación efectiva de este envío de bits, las computadoras en ambos extremos deben saber qué se supone que representan los bits. El significado de cualquier secuencia dada de bits depende enteramente del tipo de cosa que está tratando de expresar y del mecanismo de codificación utilizado."
              }
            ]
          },
          {
            "id": "ch13-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un <em>protocolo de red</em> describe un estilo de comunicación sobre una red. Hay protocolos para enviar correos electrónicos, para recibir correos electrónicos, para compartir archivos e incluso para controlar computadoras que han sido infectadas por software malicioso."
              },
              {
                "type": "paragraph",
                "content": "El <em>Protocolo de Transferencia de Hipertexto</em> (HTTP) es un protocolo para recuperar recursos nombrados (trozos de información, como páginas web o imágenes). Especifica que el lado que realiza la solicitud debe comenzar con una línea como esta, nombrando el recurso y la versión del protocolo que está intentando usar:"
              },
              {
                "type": "paragraph",
                "content": "Hay muchas más reglas sobre la forma en que el solicitante puede incluir más información en la solicitud y la forma en que el otro lado, que devuelve el recurso, empaqueta su contenido. Veremos HTTP con un poco más de detalle en el Capítulo 18."
              }
            ]
          },
          {
            "id": "ch13-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría de los protocolos se construyen sobre otros protocolos. HTTP trata la red como un dispositivo similar a un flujo en el que puedes poner bits y hacer que lleguen al destino correcto en el orden correcto. Proporcionar esas garantías encima del envío de datos primitivos que proporciona la red es un problema bastante complicado."
              },
              {
                "type": "paragraph",
                "content": "El <em>Protocolo de Control de Transmisión</em> (TCP) es un protocolo que aborda este problema. Todos los dispositivos conectados a Internet lo “hablan” y la mayoría de las comunicaciones en Internet se construyen sobre él."
              },
              {
                "type": "paragraph",
                "content": "Una conexión TCP funciona de la siguiente manera: una computadora debe estar esperando, o <em>escuchando</em>, a que otras computadoras comiencen a hablar con ella. Para poder escuchar diferentes tipos de comunicación al mismo tiempo en una sola máquina, cada oyente tiene asociado un número (llamado <em>puerto</em>). La mayoría de los protocolos especifican qué puerto debe usarse de forma predeterminada. Por ejemplo, cuando queremos enviar un correo electrónico usando el protocolo SMTP, se espera que la máquina a través de la cual lo enviamos esté escuchando en el puerto 25."
              }
            ]
          },
          {
            "id": "ch13-l1-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Otra computadora puede establecer entonces una conexión conectándose a la máquina de destino usando el número de puerto correcto. Si la máquina de destino es alcanzable y está escuchando en ese puerto, la conexión se crea con éxito. La computadora que escucha se llama el <em>servidor</em>, y la computadora que se conecta se llama el <em>cliente</em>."
              },
              {
                "type": "paragraph",
                "content": "Dicha conexión actúa como un conducto bidireccional a través del cual pueden fluir los bits: las máquinas en ambos extremos pueden insertar datos en él. Una vez que los bits se transmiten con éxito, pueden volver a ser leídos por la máquina del otro lado. Este es un modelo conveniente. Se podría decir que TCP proporciona una abstracción de la red."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch13-l2",
        "title": "La Web",
        "sections": [
          {
            "id": "ch13-l2-s0",
            "title": "La Web",
            "content": [
              {
                "type": "paragraph",
                "content": "El <em>World Wide Web</em> (no se debe confundir con el Internet en su totalidad) es un conjunto de protocolos y formatos que nos permiten visitar páginas web en un navegador. La parte “Web” en el nombre se refiere al hecho de que estas páginas pueden enlazarse fácilmente entre sí, conectándose así en una gran malla por la que los usuarios pueden moverse."
              },
              {
                "type": "paragraph",
                "content": "Para formar parte de la Web, todo lo que necesitas hacer es conectar una máquina al Internet y hacer que escuche en el puerto 80 con el protocolo HTTP para que otras computadoras puedan solicitarle documentos."
              },
              {
                "type": "paragraph",
                "content": "Cada documento en la Web está nombrado por un <em>Localizador de Recursos Uniforme</em> (URL), que se ve algo así:"
              }
            ]
          },
          {
            "id": "ch13-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La primera parte nos dice que esta URL utiliza el protocolo HTTP (en contraposición, por ejemplo, a HTTP cifrado, que sería <em>https://</em>). Luego viene la parte que identifica desde qué servidor estamos solicitando el documento. Por último está una cadena de ruta que identifica el documento específico (o <em>recurso</em>) en el que estamos interesados."
              },
              {
                "type": "paragraph",
                "content": "Las máquinas conectadas a Internet tienen una <em>dirección IP</em>, que es un número que se puede utilizar para enviar mensajes a esa máquina, y se ve algo así como <code>149.210.142.219</code> o <code>2001:4860:4860::8888</code>. Pero las listas de números más o menos aleatorios son difíciles de recordar y complicados de escribir, así que en su lugar puedes registrar un <em>nombre de dominio</em> para una dirección específica o un conjunto de direcciones. Registré <em>eloquentjavascript.net</em> para apuntar a la dirección IP de una máquina que controlo y, por lo tanto, puedo usar ese nombre de dominio para servir páginas web."
              },
              {
                "type": "paragraph",
                "content": "Si escribes esta URL en la barra de direcciones de tu navegador, el navegador intentará recuperar y mostrar el documento en esa URL. Primero, tu navegador tiene que averiguar a qué dirección se refiere <em>eloquentjavascript.net</em>. Luego, utilizando el protocolo HTTP, hará una conexión con el servidor en esa dirección y solicitará el recurso <em>/13_browser.html</em>. Si todo va bien, el servidor enviará un documento, que tu navegador mostrará en tu pantalla."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch13-l3",
        "title": "HTML",
        "sections": [
          {
            "id": "ch13-l3-s0",
            "title": "HTML",
            "content": [
              {
                "type": "paragraph",
                "content": "HTML, que significa <em>Lenguaje de Marcado de Hipertexto</em>, es el formato de documento utilizado para páginas web. Un documento HTML contiene texto, así como <em>etiquetas</em> que estructuran el texto, describiendo cosas como enlaces, párrafos y encabezados."
              },
              {
                "type": "paragraph",
                "content": "Un documento HTML corto podría lucir así:"
              },
              {
                "type": "paragraph",
                "content": "Las etiquetas, encerradas en corchetes angulares (<code>&lt;</code> y <code>&gt;</code>, los símbolos de <em>menor que</em> y <em>mayor que</em>), proporcionan información sobre la estructura del documento. El otro texto es simplemente texto plano."
              }
            ]
          },
          {
            "id": "ch13-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El documento comienza con <code>&lt;!doctype html&gt;</code>, lo que indica al navegador interpretar la página como HTML <em>moderno</em>, en contraposición a estilos obsoletos que se utilizaban en el pasado."
              },
              {
                "type": "paragraph",
                "content": "Los documentos HTML tienen una cabecera y un cuerpo. La cabecera contiene información <em>sobre</em> el documento, y el cuerpo contiene el documento en sí. En este caso, la cabecera declara que el título de este documento es “Mi página de inicio” y que utiliza la codificación UTF-8, que es una forma de codificar texto Unicode como datos binarios. El cuerpo del documento contiene un encabezado (<code>&lt;h1&gt;</code>, que significa “encabezado 1” —<code>&lt;h2&gt;</code> a <code>&lt;h6&gt;</code> producen subencabezados) y dos párrafos (<code>&lt;p&gt;</code>)."
              },
              {
                "type": "paragraph",
                "content": "Las etiquetas vienen en varias formas. Un elemento, como el cuerpo, un párrafo o un enlace, comienza con una <em>etiqueta de apertura</em> como <code>&lt;p&gt;</code> y finaliza con una <em>etiqueta de cierre</em> como <code>&lt;/p&gt;</code>. Algunas etiquetas de apertura, como la de enlace (<code>&lt;a&gt;</code>), contienen información adicional en forma de pares <code>nombre=\"valor\"</code>. Estos se llaman <em>atributos</em>. En este caso, el destino del enlace se indica con <code>href=\"http://<wbr>eloquentjavascript.<wbr>net\"</code>, donde <code>href</code> significa “hipervínculo de referencia”."
              }
            ]
          },
          {
            "id": "ch13-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunos tipos de etiquetas no contienen nada y por lo tanto no necesitan ser cerradas. La etiqueta de metadatos <code>&lt;meta charset=\"utf-8\"&gt;</code> es un ejemplo de esto."
              },
              {
                "type": "paragraph",
                "content": "Para poder incluir corchetes angulares en el texto de un documento, a pesar de que tienen un significado especial en HTML, se debe introducir otra forma especial de notación. Un simple signo menor que se escribe como <code>&amp;lt;</code> (“menor que”), y un signo mayor que se escribe como <code>&amp;gt;</code> (“mayor que”). En HTML, un carácter y comercial (<code>&amp;</code>) seguido de un nombre o código de carácter y un punto y coma (<code>;</code>) se llama una <em>entidad</em> y será reemplazado por el carácter que codifica."
              },
              {
                "type": "paragraph",
                "content": "Esto es análogo a la manera en que se utilizan las barras invertidas en las cadenas de texto de JavaScript. Dado que este mecanismo también otorga un significado especial a los caracteres de y comercial, necesitan ser escapados como <code>&amp;amp;</code>. Dentro de los valores de los atributos, que están entre comillas dobles, se puede usar <code>&amp;quot;</code> para insertar un carácter de comillas real."
              }
            ]
          },
          {
            "id": "ch13-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "HTML se analiza de una manera notablemente tolerante a errores. Cuando faltan etiquetas que deberían estar ahí, el navegador las agrega automáticamente. La forma en que se hace esto se ha estandarizado, y puedes confiar en que todos los navegadores modernos lo harán de la misma manera."
              },
              {
                "type": "paragraph",
                "content": "El siguiente documento será tratado igual que el que se mostró anteriormente:"
              },
              {
                "type": "paragraph",
                "content": "Las etiquetas <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code> y <code>&lt;body&gt;</code> han desaparecido por completo. El navegador sabe que <code>&lt;meta&gt;</code> y <code>&lt;title&gt;</code> pertenecen a la cabecera y que <code>&lt;h1&gt;</code> significa que el cuerpo ha comenzado. Además, ya no cierro explícitamente los párrafos, ya que abrir un nuevo párrafo o finalizar el documento los cerrará implícitamente. Las comillas alrededor de los valores de los atributos también han desaparecido."
              }
            ]
          },
          {
            "id": "ch13-l3-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este libro generalmente omitirá las etiquetas <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code> y <code>&lt;body&gt;</code> en ejemplos para mantenerlos cortos y libres de desorden. Pero <em>sí</em> cerraré las etiquetas e incluiré comillas alrededor de los atributos."
              },
              {
                "type": "paragraph",
                "content": "También generalmente omitiré el doctype y la declaración <code>charset</code>. Esto no debe interpretarse como una recomendación para omitirlos de documentos HTML. Los navegadores a menudo hacen cosas ridículas cuando los olvidas. Deberías considerar que el doctype y los metadatos del <code>charset</code> están implícitamente presentes en los ejemplos, incluso cuando no se muestran realmente en el texto."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch13-l4",
        "title": "HTML y JavaScript",
        "sections": [
          {
            "id": "ch13-l4-s0",
            "title": "HTML y JavaScript",
            "content": [
              {
                "type": "paragraph",
                "content": "En el contexto de este libro, la etiqueta HTML más importante es <code>&lt;script&gt;</code>. Esta etiqueta nos permite incluir un fragmento de JavaScript en un documento."
              },
              {
                "type": "paragraph",
                "content": "Dicho script se ejecutará tan pronto como su etiqueta <code>&lt;script&gt;</code> sea encontrada mientras el navegador lee el HTML. Esta página mostrará un cuadro de diálogo al abrirla—la función <code>alert</code> se asemeja a <code>prompt</code>, en que muestra una ventana pequeña, pero solo muestra un mensaje sin solicitar entrada."
              },
              {
                "type": "paragraph",
                "content": "Incluir programas extensos directamente en documentos HTML a menudo es poco práctico. La etiqueta <code>&lt;script&gt;</code> puede recibir un atributo <code>src</code> para obtener un archivo de script (un archivo de texto que contiene un programa JavaScript) desde una URL."
              }
            ]
          },
          {
            "id": "ch13-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El archivo <em>code/hello.js</em> incluido aquí contiene el mismo programa—<code>alert(\"¡hola!\")</code>. Cuando una página HTML referencia otras URL como parte de sí misma—por ejemplo, un archivo de imagen o un script—los navegadores web los recuperarán inmediatamente e incluirán en la página."
              },
              {
                "type": "paragraph",
                "content": "Una etiqueta de script siempre debe cerrarse con <code>&lt;/script&gt;</code>, incluso si hace referencia a un archivo de script y no contiene ningún código. Si olvidas esto, el resto de la página se interpretará como parte del script."
              },
              {
                "type": "paragraph",
                "content": "Puedes cargar módulos ES (ver Capítulo 10) en el navegador al darle a tu etiqueta de script un atributo <code>type=\"module\"</code>. Dichos módulos pueden depender de otros módulos usando URLs relativas a sí mismos como nombres de módulo en declaraciones de <code>import</code>."
              }
            ]
          },
          {
            "id": "ch13-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunos atributos también pueden contener un programa JavaScript. La etiqueta <code>&lt;button&gt;</code> (que se muestra como un botón) soporta un atributo <code>onclick</code>. El valor del atributo se ejecutará cada vez que se haga clic en el botón."
              },
              {
                "type": "paragraph",
                "content": "Nota que tuve que utilizar comillas simples para el string en el atributo <code>onclick</code> porque las comillas dobles ya se usan para citar todo el atributo. También podría haber utilizado <code>&amp;quot;</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch13-l5",
        "title": "En el entorno controlado",
        "sections": [
          {
            "id": "ch13-l5-s0",
            "title": "En el entorno controlado",
            "content": [
              {
                "type": "paragraph",
                "content": "Ejecutar programas descargados de Internet es potencialmente peligroso. No sabes mucho sobre las personas detrás de la mayoría de los sitios que visitas, y no necesariamente tienen buenas intenciones. Ejecutar programas de personas que no tienen buenas intenciones es cómo se infecta tu computadora con virus, te roban tus datos y hackean tus cuentas."
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, la atracción de la Web es que puedes navegar por ella sin necesariamente confiar en todas las páginas que visitas. Por eso, los navegadores limitan severamente las cosas que un programa JavaScript puede hacer: no puede ver los archivos en tu computadora ni modificar nada que no esté relacionado con la página web en la que estaba incrustado."
              },
              {
                "type": "paragraph",
                "content": "Aislar un entorno de programación de esta manera se llama <em>sandboxing</em>, la idea es que el programa está jugando inofensivamente en un arenero. Pero debes imaginar este tipo particular de arenero como teniendo una jaula de barras de acero gruesas sobre él para que los programas que juegan en él no puedan salir realmente."
              }
            ]
          },
          {
            "id": "ch13-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La parte difícil del sandboxing es permitir que los programas tengan suficiente espacio para ser útiles y al mismo tiempo restringirlos para que no hagan nada peligroso. Muchas funcionalidades útiles, como comunicarse con otros servidores o leer el contenido del portapapeles, también pueden usarse para hacer cosas problemáticas que invaden la privacidad."
              },
              {
                "type": "paragraph",
                "content": "De vez en cuando, alguien encuentra una nueva forma de evitar las limitaciones de un navegador y hacer algo dañino, que va desde filtrar información privada menor hasta tomar el control de toda la máquina en la que se ejecuta el navegador. Los desarrolladores de navegadores responden reparando el agujero, y todo vuelve a estar bien, hasta que se descubre el próximo problema, y con suerte se publicita, en lugar de ser explotado en secreto por alguna agencia gubernamental u organización criminal."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch13-l6",
        "title": "Compatibilidad y las guerras de navegadores",
        "sections": [
          {
            "id": "ch13-l6-s0",
            "title": "Compatibilidad y las guerras de navegadores",
            "content": [
              {
                "type": "paragraph",
                "content": "En las etapas iniciales de la Web, un navegador llamado Mosaic dominaba el mercado. Después de unos años, el equilibrio se desplazó a Netscape, que a su vez fue en gran medida reemplazado por Internet Explorer de Microsoft. En cualquier punto en el que un único navegador era dominante, el fabricante de ese navegador se creía con derecho a inventar nuevas funciones para la Web unilateralmente. Dado que la mayoría de usuarios usaban el navegador más popular, los sitio webs simplemente comenzaban a usar esas características, sin importar los otros navegadores."
              },
              {
                "type": "paragraph",
                "content": "Esta fue la era oscura de la compatibilidad, a menudo llamada las <em>guerras de navegadores</em>. Los desarrolladores web se quedaron con no una Web unificada, sino dos o tres plataformas incompatibles. Para empeorar las cosas, los navegadores en uso alrededor de 2003 estaban llenos de errores, y por supuesto los errores eran diferentes para cada navegador. La vida era difícil para las personas que escribían páginas web."
              },
              {
                "type": "paragraph",
                "content": "Mozilla Firefox, un derivado sin ánimo de lucro de Netscape, desafió la posición de Internet Explorer a finales de la década de 2000. Debido a que Microsoft no estaba particularmente interesado en mantenerse competitivo en ese momento, Firefox le quitó mucho cuota de mercado. Alrededor del mismo tiempo, Google introdujo su navegador Chrome y el navegador de Apple Safari ganó popularidad, lo que llevó a una situación en la que había cuatro actores principales, en lugar de uno solo."
              }
            ]
          },
          {
            "id": "ch13-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los nuevos actores tenían una actitud más seria hacia los estándares y mejores prácticas de ingeniería, lo que nos dio menos incompatibilidad y menos errores. Microsoft, viendo cómo su cuota de mercado se desmoronaba, adoptó estas actitudes en su navegador Edge, que reemplaza a Internet Explorer. Si estás empezando a aprender desarrollo web hoy, considérate afortunado. Las últimas versiones de los principales navegadores se comportan de manera bastante uniforme y tienen relativamente pocos errores.Desafortunadamente, con la disminución constante de la cuota de mercado de Firefox y Edge convirtiéndose en simplemente un contenedor alrededor del núcleo de Chrome en 2018, esta uniformidad podría una vez más tomar la forma de un único proveedor —Google en este caso— teniendo el suficiente control sobre el mercado de navegadores para imponer su idea de cómo debería lucir la Web al resto del mundo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      }
    ]
  },
  {
    "id": "ch14",
    "number": 14,
    "title": "El Modelo de Objetos del Documento",
    "titleEs": "El Modelo de Objetos del Documento",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "¡Qué mal! ¡La misma vieja historia! Una vez que has terminado de construir tu casa, te das cuenta de que has aprendido accidentalmente algo que realme...",
    "isProject": false,
    "totalXP": 525,
    "lessons": [
      {
        "id": "ch14-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch14-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "¡Qué mal! ¡La misma vieja historia! Una vez que has terminado de construir tu casa, te das cuenta de que has aprendido accidentalmente algo que realmente deberías haber sabido antes de comenzar. Friedrich Nietzsche, Más allá del bien y del mal"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/El Modelo de Objetos del Documento __ Eloquent JavaScript_files/chapter_picture_14.jpg",
                "alt": "Ilustración que muestra un árbol con letras, imágenes y engranajes colgando de sus ramas"
              },
              {
                "type": "paragraph",
                "content": "Cuando abres una página web, tu navegador recupera el texto HTML de la página y lo analiza, de manera similar a como nuestro analizador de Capítulo 12 analizaba programas. El navegador construye un modelo de la estructura del documento y utiliza este modelo para dibujar la página en la pantalla."
              }
            ]
          },
          {
            "id": "ch14-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esta representación del documento es uno de los juguetes que un programa JavaScript tiene disponible en su caja de arena. Es una estructura de datos que puedes leer o modificar. Actúa como una estructura de datos <em>en vivo</em>: cuando se modifica, la página en la pantalla se actualiza para reflejar los cambios."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l1",
        "title": "Estructura del documento",
        "sections": [
          {
            "id": "ch14-l1-s0",
            "title": "Estructura del documento",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes imaginar un documento HTML como un conjunto anidado de cajas. Etiquetas como <code>&lt;body&gt;</code> y <code>&lt;/body&gt;</code> encierran otras etiquetas, que a su vez contienen otras etiquetas o texto. Aquí está el documento de ejemplo del capítulo anterior:"
              },
              {
                "type": "paragraph",
                "content": "Esta página tiene la siguiente estructura:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/El Modelo de Objetos del Documento __ Eloquent JavaScript_files/html-boxes.svg",
                "alt": "Diagrama que muestra un documento HTML como un conjunto de cajas anidadas. La caja externa está etiquetada como &#39;html&#39; y contiene dos cajas etiquetadas &#39;head&#39; y &#39;body&#39;. Dentro de ellas hay más cajas, con algunas de las cajas más internas que contienen el texto del documento."
              },
              {
                "type": "paragraph",
                "content": "La estructura de datos que el navegador utiliza para representar el documento sigue esta forma. Para cada caja, hay un objeto con el que podemos interactuar para saber cosas como qué etiqueta HTML representa y qué cajas y texto contiene. Esta representación se llama <em>Modelo de Objetos del Documento</em>, o DOM en resumen."
              }
            ]
          },
          {
            "id": "ch14-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El enlace global <code>document</code> nos da acceso a estos objetos. Su propiedad <code>documentElement</code> se refiere al objeto que representa la etiqueta <code>&lt;html&gt;</code>. Dado que cada documento HTML tiene una cabeza y un cuerpo, también tiene propiedades <code>head</code> y <code>body</code>, que apuntan a esos elementos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l2",
        "title": "Árboles",
        "sections": [
          {
            "id": "ch14-l2-s0",
            "title": "Árboles",
            "content": [
              {
                "type": "paragraph",
                "content": "Piensa en los árbol sintácticos del Capítulo 12 por un momento. Sus estructuras son sorprendentemente similares a la estructura de un documento de un navegador. Cada <em>nodo</em> puede referirse a otros nodos, <em>hijos</em>, que a su vez pueden tener sus propios hijos. Esta forma es típica de estructuras anidadas donde los elementos pueden contener subelementos que son similares a ellos mismos."
              },
              {
                "type": "paragraph",
                "content": "Llamamos a una estructura de datos un <em>árbol</em> cuando tiene una estructura de ramificación, no tiene ciclos (un nodo no puede contenerse a sí mismo, directa o indirectamente), y tiene un <em>raíz</em> única y bien definida. En el caso del DOM, <code>document.<wbr>documentElement</code> sirve como la raíz."
              },
              {
                "type": "paragraph",
                "content": "Los árboles son comunes en la informática. Además de representar estructuras recursivas como documentos HTML o programas, a menudo se utilizan para mantener conjuntos de datos ordenados porque los elementos generalmente se pueden encontrar o insertar de manera más eficiente en un árbol que en un arreglo plano."
              }
            ]
          },
          {
            "id": "ch14-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un árbol típico tiene diferentes tipos de nodos. El árbol de sintaxis para el lenguaje Egg tenía identificadores, valores y nodos de aplicación. Los nodos de aplicación pueden tener hijos, mientras que los identificadores y valores son <em>hojas</em>, o nodos sin hijos."
              },
              {
                "type": "paragraph",
                "content": "Lo mismo ocurre para el DOM. Los nodos de los <em>elementos</em>, que representan etiquetas HTML, determinan la estructura del documento. Estos pueden tener nodo hijos. Un ejemplo de dicho nodo es <code>document.body</code>. Algunos de estos hijos pueden ser nodo hoja, como fragmentos de texto o nodos comentario."
              },
              {
                "type": "paragraph",
                "content": "Cada objeto de nodo del DOM tiene una propiedad <code>nodeType</code>, que contiene un código (número) que identifica el tipo de nodo. Los elementos tienen el código 1, que también se define como la propiedad constante <code>Node.<wbr>ELEMENT_NODE</code>. Los nodos de texto, que representan una sección de texto en el documento, obtienen el código 3 (<code>Node.TEXT_NODE</code>). Los comentarios tienen el código 8 (<code>Node.<wbr>COMMENT_NODE</code>)."
              }
            ]
          },
          {
            "id": "ch14-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Otra forma de visualizar nuestro árbol de documento es la siguiente:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/El Modelo de Objetos del Documento __ Eloquent JavaScript_files/html-tree.svg",
                "alt": "Diagrama que muestra el documento HTML como un árbol, con flechas de nodos padres a nodos hijos"
              },
              {
                "type": "paragraph",
                "content": "Las hojas son nodos de texto, y las flechas indican las relaciones padre-hijo entre nodos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch14-l3",
        "title": "El estándar",
        "sections": [
          {
            "id": "ch14-l3-s0",
            "title": "El estándar",
            "content": [
              {
                "type": "paragraph",
                "content": "Usar códigos numéricos crípticos para representar tipos de nodos no es algo muy propio de JavaScript. Más adelante en este capítulo, veremos que otras partes de la interfaz del DOM también se sienten incómodas y extrañas. La razón de esto es que la interfaz del DOM no fue diseñada exclusivamente para JavaScript. Más bien, intenta ser una interfaz neutral en cuanto a lenguaje que también pueda utilizarse en otros sistemas, no solo para HTML, sino también para XML, que es un formato de datos genérico con una sintaxis similar a HTML."
              },
              {
                "type": "paragraph",
                "content": "Esto es lamentable. Los estándares a menudo son útiles. Pero en este caso, la ventaja (consistencia entre lenguajes) no es tan convincente. Tener una interfaz que esté correctamente integrada con el lenguaje que estás utilizando te ahorrará más tiempo que tener una interfaz familiar en varios lenguajes."
              },
              {
                "type": "paragraph",
                "content": "Como ejemplo de esta mala integración, considera la propiedad <code>childNodes</code> que tienen los nodos de elementos en el DOM. Esta propiedad contiene un objeto similar a un array, con una propiedad <code>length</code> y propiedades etiquetadas por números para acceder a los nodos hijos. Pero es una instancia del tipo <code>NodeList</code>, no un array real, por lo que no tiene métodos como <code>slice</code> y <code>map</code>."
              }
            ]
          },
          {
            "id": "ch14-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Luego, hay problemas que son simplemente de mala diseño. Por ejemplo, no hay forma de crear un nuevo nodo y agregar inmediatamente hijos o atributos a él. En su lugar, primero tienes que crearlo y luego agregar los hijos y atributos uno por uno, usando efectos secundarios. El código que interactúa mucho con el DOM tiende a ser largo, repetitivo y feo."
              },
              {
                "type": "paragraph",
                "content": "Pero estos defectos no son fatales. Dado que JavaScript nos permite crear nuestras propias abstracciones, es posible diseñar formas mejoradas de expresar las operaciones que estás realizando. Muchas bibliotecas destinadas a la programación del navegador vienen con herramientas de este tipo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l4",
        "title": "Movimiento a través del árbol",
        "sections": [
          {
            "id": "ch14-l4-s0",
            "title": "Movimiento a través del árbol",
            "content": [
              {
                "type": "paragraph",
                "content": "Los nodos DOM contienen una gran cantidad de enlaces a otros nodos cercanos. El siguiente diagrama ilustra esto:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/El Modelo de Objetos del Documento __ Eloquent JavaScript_files/html-links.svg",
                "alt": "Diagrama que muestra los enlaces entre nodos DOM. El nodo &#39;body&#39; se muestra como un cuadro, con una flecha &#39;firstChild&#39; apuntando al nodo &#39;h1&#39; en su inicio, una flecha &#39;lastChild&#39; apuntando al último nodo de párrafo, y una flecha &#39;childNodes&#39; apuntando a un array de enlaces a todos sus hijos. El párrafo del medio tiene una flecha &#39;previousSibling&#39; apuntando al nodo anterior, una flecha &#39;nextSibling&#39; al nodo siguiente, y una flecha &#39;parentNode&#39; apuntando al nodo &#39;body&#39;."
              },
              {
                "type": "paragraph",
                "content": "Aunque el diagrama muestra solo un enlace de cada tipo, cada nodo tiene una propiedad <code>parentNode</code> que apunta al nodo del que forma parte, si lo hay. De igual manera, cada nodo de elemento (tipo 1) tiene una propiedad <code>childNodes</code> que apunta a un objeto similar a un array que contiene sus hijos."
              }
            ]
          },
          {
            "id": "ch14-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En teoría, podrías moverte por todo el árbol utilizando solo estos enlaces padre e hijo. Pero JavaScript también te da acceso a varios enlaces de conveniencia adicionales. Las propiedades <code>firstChild</code> y <code>lastChild</code> apuntan a los primeros y últimos elementos hijos o tienen el valor <code>null</code> para nodos sin hijos. De manera similar, <code>previousSibling</code> y <code>nextSibling</code> apuntan a nodos adyacentes, que son nodos con el mismo padre que aparecen inmediatamente antes o después del nodo en sí. Para un primer hijo, <code>previousSibling</code> será nulo, y para un último hijo, <code>nextSibling</code> será nulo."
              },
              {
                "type": "paragraph",
                "content": "También está la propiedad <code>children</code>, que es como <code>childNodes</code> pero contiene solo hijos de elementos (tipo 1), no otros tipos de nodos hijos. Esto puede ser útil cuando no estás interesado en nodos de texto."
              },
              {
                "type": "paragraph",
                "content": "Cuando se trabaja con una estructura de datos anidada como esta, las funciones recursivas son frecuentemente útiles. La siguiente función examina un documento en busca de nodos de texto que contengan una cadena específica y devuelve <code>true</code> cuando ha encontrado uno:"
              }
            ]
          },
          {
            "id": "ch14-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad <code>nodeValue</code> de un nodo de texto contiene la cadena de texto que representa."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch14-l5",
        "title": "Encontrando elementos",
        "sections": [
          {
            "id": "ch14-l5-s0",
            "title": "Encontrando elementos",
            "content": [
              {
                "type": "paragraph",
                "content": "Navegar por estos enlaces entre padres, hijos y hermanos a menudo es útil. Pero si queremos encontrar un nodo específico en el documento, llegar a él empezando por <code>document.body</code> y siguiendo un camino fijo de propiedades no es una buena idea. Hacerlo implica hacer suposiciones en nuestro programa sobre la estructura precisa del documento, una estructura que podrías querer cambiar más adelante. Otro factor complicador es que se crean nodos de texto incluso para los espacios en blanco entre nodos. La etiqueta <code>&lt;body&gt;</code> del documento de ejemplo no tiene solo tres hijos (<code>&lt;h1&gt;</code> y dos elementos <code>&lt;p&gt;</code>) sino que en realidad tiene siete: esos tres, más los espacios en blanco antes, después y entre ellos."
              },
              {
                "type": "paragraph",
                "content": "Por lo tanto, si queremos obtener el atributo <code>href</code> del enlace en ese documento, no queremos decir algo como “Obtener el segundo hijo del sexto hijo del cuerpo del documento”. Sería mejor si pudiéramos decir “Obtener el primer enlace en el documento”. Y podemos hacerlo."
              },
              {
                "type": "paragraph",
                "content": "Todos los nodos de elemento tienen un método <code>getElementsByTagName</code>, que recoge todos los elementos con el nombre de etiqueta dado que son descendientes (hijos directos o indirectos) de ese nodo y los devuelve como un objeto similar a un array."
              }
            ]
          },
          {
            "id": "ch14-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para encontrar un nodo específico <em>único</em>, puedes darle un atributo <code>id</code> y usar <code>document.<wbr>getElementById</code> en su lugar."
              },
              {
                "type": "paragraph",
                "content": "Un tercer método similar es <code>getElementsByClassName</code>, que, al igual que <code>getElementsByTagName</code>, busca a través del contenido de un nodo de elemento y recupera todos los elementos que tienen la cadena dada en su atributo <code>class</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l6",
        "title": "Cambiando el documento",
        "sections": [
          {
            "id": "ch14-l6-s0",
            "title": "Cambiando el documento",
            "content": [
              {
                "type": "paragraph",
                "content": "Casi todo se puede cambiar en la estructura de datos del DOM. La forma del árbol del documento se puede modificar cambiando las relaciones padre-hijo. Los nodos tienen un método <code>remove</code> para removerlos de su nodo padre actual. Para añadir un nodo hijo a un nodo de elemento, podemos usar <code>appendChild</code>, que lo coloca al final de la lista de hijos, o <code>insertBefore</code>, que inserta el nodo dado como primer argumento antes del nodo dado como segundo argumento."
              },
              {
                "type": "paragraph",
                "content": "Un nodo puede existir en el documento en un solo lugar. Por lo tanto, insertar el párrafo <em>Tres</em> delante del párrafo <em>Uno</em> primero lo removerá del final del documento y luego lo insertará al principio, resultando en <em>Tres</em>/<em>Uno</em>/<em>Dos</em>. Todas las operaciones que insertan un nodo en algún lugar causarán, como un efecto secundario, que se elimine de su posición actual (si tiene una)."
              },
              {
                "type": "paragraph",
                "content": "El método <code>replaceChild</code> se usa para reemplazar un nodo hijo con otro. Toma como argumentos dos nodos: un nodo nuevo y el nodo que se reemplazará. El nodo reemplazado debe ser un hijo del elemento en el que se llama el método. Ten en cuenta que tanto <code>replaceChild</code> como <code>insertBefore</code> esperan que el nodo <em>nuevo</em> sea su primer argumento."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch14-l7",
        "title": "Creación de nodos",
        "sections": [
          {
            "id": "ch14-l7-s0",
            "title": "Creación de nodos",
            "content": [
              {
                "type": "paragraph",
                "content": "Digamos que queremos escribir un script que reemplace todas las imágenes (etiquetas <code>&lt;img&gt;</code>) en el documento con el texto contenido en sus atributos <code>alt</code>, que especifica una representación textual alternativa de la imagen."
              },
              {
                "type": "paragraph",
                "content": "Esto implica no solo eliminar las imágenes sino agregar un nuevo nodo de texto para reemplazarlas."
              },
              {
                "type": "paragraph",
                "content": "Dada una cadena, <code>createTextNode</code> nos da un nodo de texto que podemos insertar en el documento para que aparezca en la pantalla."
              }
            ]
          },
          {
            "id": "ch14-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El bucle que recorre las imágenes comienza al final de la lista. Esto es necesario porque la lista de nodos devuelta por un método como <code>getElementsByTagName</code> (o una propiedad como <code>childNodes</code>) es <em>dinámica</em>. Es decir, se actualiza a medida que el documento cambia. Si comenzáramos desde el principio, al quitar la primera imagen haría que la lista perdiera su primer elemento, por lo que la segunda vez que se repita el bucle, cuando <code>i</code> es 1, se detendría porque la longitud de la colección ahora también es 1."
              },
              {
                "type": "paragraph",
                "content": "Si quieres tener una colección <em>sólida</em> de nodos, en lugar de una en vivo, puedes convertir la colección en un array real llamando a <code>Array.from</code>."
              },
              {
                "type": "paragraph",
                "content": "Para crear nodos elemento, puedes utilizar el método <code>document.<wbr>createElement</code>. Este método toma un nombre de etiqueta y devuelve un nuevo nodo vacío del tipo dado."
              }
            ]
          },
          {
            "id": "ch14-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente ejemplo define una utilidad <code>elt</code>, que crea un nodo de elemento y trata el resto de sus argumentos como hijos de ese nodo. Luego, esta función se utiliza para agregar una atribución a una cita."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch14-l8",
        "title": "Atributos",
        "sections": [
          {
            "id": "ch14-l8-s0",
            "title": "Atributos",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunos atributos de elementos, como <code>href</code> para enlaces, pueden ser accedidos a través de una propiedad con el mismo nombre en el objeto DOM del elemento. Este es el caso para la mayoría de atributos estándar comúnmente usados."
              },
              {
                "type": "paragraph",
                "content": "HTML te permite establecer cualquier atributo que desees en los nodos. Esto puede ser útil porque te permite almacenar información adicional en un documento. Para leer o cambiar atributos personalizados, que no están disponibles como propiedades regulares del objeto, debes usar los métodos <code>getAttribute</code> y <code>setAttribute</code>."
              },
              {
                "type": "paragraph",
                "content": "Se recomienda prefijar los nombres de estos atributos inventados con <code>data-</code> para asegurarse de que no entren en conflicto con otros atributos."
              }
            ]
          },
          {
            "id": "ch14-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Existe un atributo comúnmente usado, <code>class</code>, que es una palabra clave en el lenguaje JavaScript. Por razones históricas—algunas implementaciones antiguas de JavaScript no podían manejar nombres de propiedades que coincidieran con palabras clave—la propiedad utilizada para acceder a este atributo se llama <code>className</code>. También puedes acceder a él con su nombre real, <code>\"class\"</code>, utilizando los métodos <code>getAttribute</code> y <code>setAttribute</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l9",
        "title": "Diseño",
        "sections": [
          {
            "id": "ch14-l9-s0",
            "title": "Diseño",
            "content": [
              {
                "type": "paragraph",
                "content": "Puede que hayas notado que diferentes tipos de elementos se disponen de manera diferente. Algunos, como párrafos (<code>&lt;p&gt;</code>) o encabezados (<code>&lt;h1&gt;</code>), ocupan todo el ancho del documento y se muestran en líneas separadas. Estos se llaman elementos de <em>bloque</em>. Otros, como enlaces (<code>&lt;a&gt;</code>) o el elemento <code>&lt;strong&gt;</code>, se muestran en la misma línea que el texto que los rodea. A estos elementos se les llama elementos <em>en línea</em>."
              },
              {
                "type": "paragraph",
                "content": "Para cualquier documento dado, los navegadores son capaces de calcular un diseño, que le da a cada elemento un tamaño y posición basados en su tipo y contenido. Luego, este diseño se usa para dibujar el documento realmente."
              },
              {
                "type": "paragraph",
                "content": "El tamaño y posición de un elemento pueden ser accedidos desde JavaScript. Las propiedades <code>offsetWidth</code> y <code>offsetHeight</code> te dan el espacio que el elemento ocupa en <em>píxeles</em>. Un píxel es la unidad básica de medida en el navegador. Tradicionalmente corresponde al punto más pequeño que la pantalla puede dibujar, pero en pantallas modernas, que pueden dibujar puntos <em>muy</em> pequeños, eso puede que ya no sea cierto, y un píxel del navegador puede abarcar múltiples puntos de la pantalla."
              }
            ]
          },
          {
            "id": "ch14-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "De manera similar, <code>clientWidth</code> y <code>clientHeight</code> te dan el tamaño del espacio <em>dentro</em> del elemento, ignorando el ancho del borde."
              },
              {
                "type": "paragraph",
                "content": "La manera más efectiva de encontrar la posición precisa de un elemento en la pantalla es el método <code>getBoundingClientRect</code>. Devuelve un objeto con las propiedades <code>top</code>, <code>bottom</code>, <code>left</code> y <code>right</code>, indicando las posiciones en píxeles de los lados del elemento en relación con la esquina superior izquierda de la pantalla. Si los quieres en relación al documento completo, debes sumar la posición actual de desplazamiento, que puedes encontrar en las variables <code>pageXOffset</code> y <code>pageYOffset</code>."
              },
              {
                "type": "paragraph",
                "content": "Diseñar un documento puede ser bastante trabajo. En aras de la rapidez, los motores de los navegadores no vuelven a diseñar inmediatamente un documento cada vez que se modifica, sino que esperan tanto como pueden. Cuando un programa de JavaScript que ha modificado el documento finaliza su ejecución, el navegador tendrá que calcular un nuevo diseño para dibujar el documento modificado en la pantalla. Cuando un programa <em>pide</em> la posición o tamaño de algo leyendo propiedades como <code>offsetHeight</code> o llamando a <code>getBoundingClientRect</code>, proporcionar esa información también requiere calcular un diseño."
              }
            ]
          },
          {
            "id": "ch14-l9-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un programa que alterna repetidamente entre la lectura de información de diseño del DOM y el cambio del DOM provoca que se realicen muchas computaciones de diseño y, en consecuencia, se ejecute muy lentamente. El siguiente código es un ejemplo de esto. Contiene dos programas diferentes que construyen una línea de caracteres <em>X</em> de 2,000 píxeles de ancho y mide el tiempo que lleva cada uno."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch14-l10",
        "title": "Estilos",
        "sections": [
          {
            "id": "ch14-l10-s0",
            "title": "Estilos",
            "content": [
              {
                "type": "paragraph",
                "content": "Hemos visto que diferentes elementos HTML se dibujan de manera diferente. Algunos se muestran como bloques, otros en línea. Algunos agregan estilos: <code>&lt;strong&gt;</code> hace que su contenido sea negrita, y <code>&lt;a&gt;</code> lo hace azul y lo subraya."
              },
              {
                "type": "paragraph",
                "content": "La forma en que una etiqueta <code>&lt;img&gt;</code> muestra una imagen o una etiqueta <code>&lt;a&gt;</code> hace que se siga un enlace al hacer clic está fuertemente vinculada al tipo de elemento. Pero podemos cambiar el estilo asociado con un elemento, como el color del texto o el subrayado. Aquí hay un ejemplo que utiliza la propiedad <code>style</code>:"
              },
              {
                "type": "paragraph",
                "content": "Un atributo de estilo puede contener uno o más <em>declaraciónes</em>, que son una propiedad (como <code>color</code>) seguida de dos puntos y un valor (como <code>verde</code>). Cuando hay más de una declaración, deben separarse por punto y comas, como en <code>\"color: rojo; border: ninguno\"</code>."
              }
            ]
          },
          {
            "id": "ch14-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos aspectos del documento pueden ser influenciados por el estilo. Por ejemplo, la propiedad <code>display</code> controla si un elemento se muestra como un bloque o como un elemento en línea."
              },
              {
                "type": "paragraph",
                "content": "La etiqueta <code>block</code> terminará en su propia línea ya que los elementos de bloque no se muestran en línea con el texto que los rodea. La última etiqueta no se muestra en absoluto: <code>display: none</code> evita que un elemento aparezca en la pantalla. Esta es una forma de ocultar elementos. A menudo es preferible a eliminarlos completamente del documento porque facilita revelarlos nuevamente más tarde."
              },
              {
                "type": "paragraph",
                "content": "El código JavaScript puede manipular directamente el estilo de un elemento a través de la propiedad <code>style</code> del elemento. Esta propiedad contiene un objeto que tiene propiedades para todas las posibles propiedades de estilo. Los valores de estas propiedades son cadenas de texto, a las cuales podemos escribir para cambiar un aspecto particular del estilo del elemento."
              }
            ]
          },
          {
            "id": "ch14-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunos nombres de propiedades de estilo contienen guiones, como <code>font-family</code>. Debido a que trabajar con estos nombres de propiedades en JavaScript es incómodo (tendrías que decir <code>style[\"font-family\"]</code>), los nombres de las propiedades en el objeto <code>style</code> para tales propiedades tienen los guiones eliminados y las letras posterior a ellos en mayúscula (<code>style.fontFamily</code>)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch14-l11",
        "title": "Estilos en cascada",
        "sections": [
          {
            "id": "ch14-l11-s0",
            "title": "Estilos en cascada",
            "content": [
              {
                "type": "paragraph",
                "content": "El sistema de estilos para HTML se llama CSS, por sus siglas en inglés, <em>Cascading Style Sheets</em>. Una <em>hoja de estilo</em> es un conjunto de reglas sobre cómo dar estilo a los elementos en un documento. Puede ser proporcionada dentro de una etiqueta <code>&lt;style&gt;</code>."
              },
              {
                "type": "paragraph",
                "content": "El <em>cascada</em> en el nombre se refiere al hecho de que múltiples reglas de este tipo se combinan para producir el estilo final de un elemento. En el ejemplo, el estilo predeterminado de las etiquetas <code>&lt;strong&gt;</code>, que les da <code>font-weight: bold</code>, se superpone por la regla en la etiqueta <code>&lt;style&gt;</code>, que agrega <code>font-style</code> y <code>color</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando múltiples reglas definen un valor para la misma propiedad, la regla más recientemente leída obtiene una precedencia más alta y gana. Por lo tanto, si la regla en la etiqueta <code>&lt;style&gt;</code> incluyera <code>font-weight: normal</code>, contradiciendo la regla predeterminada de <code>font-weight</code>, el texto sería normal, <em>no</em> negrita. Los estilos en un atributo <code>style</code> aplicado directamente al nodo tienen la mayor precedencia y siempre prevalecen."
              }
            ]
          },
          {
            "id": "ch14-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Es posible apuntar a cosas distintas de los nombres de etiqueta en reglas de CSS. Una regla para <code>.abc</code> se aplica a todos los elementos con <code>\"abc\"</code> en su atributo <code>class</code>. Una regla para <code>#xyz</code> se aplica al elemento con un atributo <code>id</code> de <code>\"xyz\"</code> (que debería ser único dentro del documento)."
              },
              {
                "type": "paragraph",
                "content": "La regla de precedencia que favorece a la regla más recientemente definida se aplica solo cuando las reglas tienen la misma <em>especificidad</em>. La especificidad de una regla es una medida de qué tan precisamente describe los elementos que coinciden, determinada por el número y tipo (etiqueta, clase o ID) de aspectos de elementos que requiere. Por ejemplo, una regla que apunta a <code>p.a</code> es más específica que las reglas que apuntan a <code>p</code> o simplemente <code>.a</code> y, por lo tanto, tendría precedencia sobre ellas."
              },
              {
                "type": "paragraph",
                "content": "La notación <code>p &gt; a {…}</code> aplica los estilos dados a todas las etiquetas <code>&lt;a&gt;</code> que son hijos directos de etiquetas <code>&lt;p&gt;</code>. De manera similar, <code>p a {…}</code> se aplica a todas las etiquetas <code>&lt;a&gt;</code> dentro de las etiquetas <code>&lt;p&gt;</code>, ya sean hijos directos o indirectos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l12",
        "title": "Selectores de consulta",
        "sections": [
          {
            "id": "ch14-l12-s0",
            "title": "Selectores de consulta",
            "content": [
              {
                "type": "paragraph",
                "content": "No vamos a usar hojas de estilo demasiado en este libro. Entenderlas es útil cuando se programa en el navegador, pero son lo suficientemente complicadas como para justificar un libro aparte."
              },
              {
                "type": "paragraph",
                "content": "La razón principal por la que introduje la sintaxis <em>selector</em>—la notación utilizada en las hojas de estilo para determinar a qué elementos se aplican un conjunto de estilos— es que podemos utilizar este mismo mini-lenguaje como una forma efectiva de encontrar elementos del DOM."
              },
              {
                "type": "paragraph",
                "content": "El método <code>querySelectorAll</code>, que está definido tanto en el objeto <code>document</code> como en los nodos de elementos, toma una cadena de selector y devuelve un <code>NodeList</code> que contiene todos los elementos que encuentra."
              }
            ]
          },
          {
            "id": "ch14-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "A diferencia de métodos como <code>getElementsByTagName</code>, el objeto devuelto por <code>querySelectorAll</code> <em>no</em> es dinámico. No cambiará cuando cambies el documento. Aun así, no es un array real, por lo que necesitas llamar a <code>Array.from</code> si deseas tratarlo como tal."
              },
              {
                "type": "paragraph",
                "content": "El método <code>querySelector</code> (sin la parte <code>All</code>) funciona de manera similar. Este es útil si deseas un elemento específico y único. Solo devolverá el primer elemento coincidente o <code>null</code> cuando no haya ningún elemento coincidente."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch14-l13",
        "title": "Posicionamiento y animación",
        "sections": [
          {
            "id": "ch14-l13-s0",
            "title": "Posicionamiento y animación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad de estilo <code>position</code> influye en el diseño de una manera poderosa. De forma predeterminada, tiene un valor de <code>static</code>, lo que significa que el elemento se sitúa en su lugar normal en el documento. Cuando se establece en <code>relative</code>, el elemento sigue ocupando espacio en el documento, pero ahora las propiedades de estilo <code>top</code> y <code>left</code> se pueden usar para moverlo con respecto a ese lugar normal. Cuando <code>position</code> se establece en <code>absolute</code>, el elemento se elimina del flujo normal del documento, es decir, ya no ocupa espacio y puede superponerse con otros elementos. Además, sus propiedades de <code>top</code> y <code>left</code> se pueden usar para posicionarlo absolutamente con respecto a la esquina superior izquierda del elemento contenedor más cercano cuya propiedad de <code>position</code> no sea <code>static</code>, o con respecto al documento si no existe tal elemento contenedor."
              },
              {
                "type": "paragraph",
                "content": "Podemos usar esto para crear una animación. El siguiente documento muestra una imagen de un gato que se mueve en una elipse:"
              },
              {
                "type": "paragraph",
                "content": "Nuestra imagen está centrada en la página y tiene una <code>posición</code> de <code>relative</code>. Actualizaremos repetidamente los estilos <code>top</code> e <code>left</code> de esa imagen para moverla."
              }
            ]
          },
          {
            "id": "ch14-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El script utiliza <code>requestAnimationFrame</code> para programar la ejecución de la función <code>animar</code> siempre que el navegador esté listo para repintar la pantalla. La función <code>animar</code> a su vez vuelve a llamar a <code>requestAnimationFrame</code> para programar la siguiente actualización. Cuando la ventana del navegador (o pestaña) está activa, esto provocará que las actualizaciones ocurran a una velocidad de aproximadamente 60 por segundo, lo que suele producir una animación atractiva."
              },
              {
                "type": "paragraph",
                "content": "Si simplemente actualizáramos el DOM en un bucle, la página se congelaría y nada aparecería en la pantalla. Los navegadores no actualizan su pantalla mientras se ejecuta un programa JavaScript, ni permiten ninguna interacción con la página. Por eso necesitamos <code>requestAnimationFrame</code> — le indica al navegador que hemos terminado por ahora, y puede continuar haciendo las cosas que hacen los navegadores, como actualizar la pantalla y responder a las acciones del usuario."
              },
              {
                "type": "paragraph",
                "content": "La función de animación recibe el tiempo actual como argumento. Para asegurar que el movimiento del gato por milisegundo sea estable, basa la velocidad a la que cambia el ángulo en la diferencia entre el tiempo actual y el último tiempo en que se ejecutó la función. Si simplemente moviera el ángulo por una cantidad fija por paso, el movimiento se interrumpiría si, por ejemplo, otra tarea pesada que se está ejecutando en la misma computadora impidiera que la función se ejecutara durante una fracción de segundo."
              }
            ]
          },
          {
            "id": "ch14-l13-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Moverse en círculos se hace utilizando las funciones trigonométricas <code>Math.cos</code> y <code>Math.sin</code>. Para aquellos que no estén familiarizados con ellas, las presentaré brevemente ya que ocasionalmente las utilizaremos en este libro."
              },
              {
                "type": "paragraph",
                "content": "<code>Math.cos</code> y <code>Math.sin</code> son útiles para encontrar puntos que se encuentran en un círculo alrededor del punto (0,0) con un radio de uno. Ambas funciones interpretan su argumento como la posición en este círculo, con cero denotando el punto en el extremo derecho del círculo, avanzando en el sentido de las agujas del reloj hasta que 2π (aproximadamente 6,28) nos ha llevado alrededor de todo el círculo. <code>Math.cos</code> te indica la coordenada x del punto que corresponde a la posición dada, y <code>Math.sin</code> devuelve la coordenada y. Las posiciones (o ángulos) mayores que 2π o menores que 0 son válidos, la rotación se repite de manera que <em>a</em>+2π se refiere al mismo ángulo que <em>a</em>."
              },
              {
                "type": "paragraph",
                "content": "Esta unidad para medir ángulos se llama radianes — un círculo completo son 2π radianes, similar a cómo son 360 grados al medir en grados. La constante π está disponible como <code>Math.PI</code> en JavaScript."
              }
            ]
          },
          {
            "id": "ch14-l13-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/El Modelo de Objetos del Documento __ Eloquent JavaScript_files/cos_sin.svg",
                "alt": "Diagrama que muestra el uso del coseno y el seno para calcular coordenadas. Se muestra un círculo con radio 1 con dos puntos en él. El ángulo desde el lado derecho del círculo hasta el punto, en radianes, se utiliza para calcular la posición de cada punto usando &#39;cos(ángulo)&#39; para la distancia horizontal desde el centro del círculo y sin(ángulo) para la distancia vertical."
              },
              {
                "type": "paragraph",
                "content": "El código de animación del gato mantiene un contador, <code>angle</code>, para el ángulo actual de la animación e incrementa el mismo cada vez que se llama la función <code>animate</code>. Luego puede usar este ángulo para calcular la posición actual del elemento de imagen. El estilo <code>top</code> es calculado con <code>Math.sin</code> y multiplicado por 20, que es el radio vertical de nuestra elipse. El estilo <code>left</code> se basa en <code>Math.cos</code> y multiplicado por 200 para que la elipse sea mucho más ancha que alta."
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que los estilos usualmente necesitan <em>unidades</em>. En este caso, tenemos que añadir <code>\"px\"</code> al número para indicarle al navegador que estamos contando en píxeles (en lugar de centímetros, “ems” u otras unidades). Esto es fácil de olvidar. Usar números sin unidades resultará en que tu estilo sea ignorado — a menos que el número sea 0, lo cual siempre significa lo mismo, independientemente de su unidad."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch14-l14",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch14-l14-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Los programas de JavaScript pueden inspeccionar e interferir con el documento que el navegador está mostrando a través de una estructura de datos llamada el DOM. Esta estructura de datos representa el modelo del documento del navegador, y un programa de JavaScript puede modificarlo para cambiar el documento visible."
              },
              {
                "type": "paragraph",
                "content": "El DOM está organizado como un árbol, en el cual los elementos están dispuestos jerárquicamente de acuerdo a la estructura del documento. Los objetos que representan elementos tienen propiedades como <code>parentNode</code> y <code>childNodes</code>, las cuales pueden ser usadas para navegar a través de este árbol."
              },
              {
                "type": "paragraph",
                "content": "La forma en que un documento es mostrado puede ser influenciada por el <em>estilo</em>, tanto adjuntando estilos directamente a nodos como definiendo reglas que coincidan con ciertos nodos. Hay muchas propiedades de estilo diferentes, como <code>color</code> o <code>display</code>. El código de JavaScript puede manipular el estilo de un elemento directamente a través de su propiedad <code>style</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch14-l15",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch14-l15-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Una tabla HTML se construye con la siguiente estructura de etiquetas:"
              },
              {
                "type": "paragraph",
                "content": "Dado un conjunto de datos de montañas, un array de objetos con propiedades <code>name</code>, <code>height</code>, y <code>place</code>, genera la estructura DOM para una tabla que enumera los objetos. Debería haber una columna por clave y una fila por objeto, además de una fila de encabezado con elementos <code>&lt;th&gt;</code> en la parte superior, enumerando los nombres de las columnas."
              },
              {
                "type": "paragraph",
                "content": "Escribe esto de manera que las columnas se deriven automáticamente de los objetos, tomando los nombres de las propiedades del primer objeto en los datos."
              }
            ]
          },
          {
            "id": "ch14-l15-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Muestra la tabla resultante en el documento agregándola al elemento que tenga un atributo <code>id</code> de <code>\"mountains\"</code>."
              },
              {
                "type": "paragraph",
                "content": "Una vez que tengas esto funcionando, alinea a la derecha las celdas que contienen valores numéricos estableciendo su propiedad <code>style.textAlign</code> en <code>\"right\"</code>."
              },
              {
                "type": "paragraph",
                "content": "Puedes usar <code>document.<wbr>createElement</code> para crear nuevos nodos de elementos, <code>document.<wbr>createTextNode</code> para crear nodos de texto y el método <code>appendChild</code> para poner nodos en otros nodos."
              }
            ]
          },
          {
            "id": "ch14-l15-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Querrás iterar sobre los nombres de las claves una vez para completar la fila superior y luego nuevamente para cada objeto en el array para construir las filas de datos. Para obtener un array de nombres de claves del primer objeto, <code>Object.keys</code> será útil."
              },
              {
                "type": "paragraph",
                "content": "Para agregar la tabla al nodo padre correcto, puedes usar <code>document.<wbr>getElementById</code> o <code>document.<wbr>querySelector</code> con <code>\"#mountains\"</code> para encontrar el nodo."
              },
              {
                "type": "paragraph",
                "content": "El método <code>document.<wbr>getElementsByTagName</code> devuelve todos los elementos hijos con un nombre de etiqueta dado. Implementa tu propia versión de esto como una función que tome un nodo y un string (el nombre de la etiqueta) como argumentos y devuelva un array que contenga todos los nodos de elementos descendientes con el nombre de etiqueta dado. Tu función debe recorrer el documento en sí. No puede usar un método como <code>querySelectorAll</code> para hacer el trabajo."
              }
            ]
          },
          {
            "id": "ch14-l15-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para encontrar el nombre de etiqueta de un elemento, usa su propiedad <code>nodeName</code>. Pero ten en cuenta que esto devolverá el nombre de la etiqueta en mayúsculas. Usa los métodos de string <code>toLowerCase</code> o <code>toUpperCase</code> para compensar esto."
              },
              {
                "type": "paragraph",
                "content": "La solución es más fácil de expresar con una función recursiva, similar a la función <code>talksAbout</code> definida anteriormente en este capítulo."
              },
              {
                "type": "paragraph",
                "content": "Puedes llamar a <code>byTagname</code> a sí misma de manera recursiva, concatenando los arrays resultantes para producir la salida. O puedes crear una función interna que se llame a sí misma de manera recursiva y que tenga acceso a un enlace de array definido en la función externa, al cual puede agregar los elementos coincidentes que encuentre. No olvides llamar a la función interna una vez desde la función externa para iniciar el proceso."
              }
            ]
          },
          {
            "id": "ch14-l15-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función recursiva debe verificar el tipo de nodo. Aquí estamos interesados solo en el tipo de nodo 1 (<code>Node.<wbr>ELEMENT_NODE</code>). Para estos nodos, debemos recorrer sus hijos y, para cada hijo, ver si el hijo coincide con la consulta mientras también hacemos una llamada recursiva en él para inspeccionar sus propios hijos."
              },
              {
                "type": "paragraph",
                "content": "Extiende la animación del gato definida anteriormente para que tanto el gato como su sombrero (<code>&lt;img src=\"img/<wbr>hat.<wbr>png\"&gt;</code>) orbiten en lados opuestos de la elipse."
              },
              {
                "type": "paragraph",
                "content": "O haz que el sombrero circule alrededor del gato. O altera la animación de alguna otra manera interesante."
              }
            ]
          },
          {
            "id": "ch14-l15-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para facilitar el posicionamiento de varios objetos, es probablemente una buena idea cambiar a posicionamiento absoluto. Esto significa que <code>top</code> y <code>left</code> se cuentan en relación al extremo superior izquierdo del documento. Para evitar usar coordenadas negativas, que harían que la imagen se salga de la página visible, puedes agregar un número fijo de píxeles a los valores de posición."
              },
              {
                "type": "paragraph",
                "content": "<code>Math.cos</code> y <code>Math.sin</code> miden los ángulos en radianes, donde un círculo completo es 2π. Para un ángulo dado, puedes obtener el ángulo opuesto sumando la mitad de este, que es <code>Math.PI</code>. Esto puede ser útil para poner el sombrero en el lado opuesto de la órbita."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      }
    ]
  },
  {
    "id": "ch15",
    "number": 15,
    "title": "Manejo de Eventos",
    "titleEs": "Manejo de Eventos",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "Tienes poder sobre tu mente, no sobre los eventos externos. Date cuenta de esto y encontrarás fuerza....",
    "isProject": false,
    "totalXP": 515,
    "lessons": [
      {
        "id": "ch15-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch15-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Tienes poder sobre tu mente, no sobre los eventos externos. Date cuenta de esto y encontrarás fuerza. Marco Aurelio, Meditaciones"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Manejo de Eventos __ Eloquent JavaScript_files/chapter_picture_15.jpg",
                "alt": "Ilustración que muestra una máquina de Rube Goldberg que involucra una pelota, una balanza, un par de tijeras y un martillo, los cuales se afectan en una reacción en cadena que enciende una bombilla."
              },
              {
                "type": "paragraph",
                "content": "Algunos programas trabajan con la entrada directa del usuario, como acciones del ratón y del teclado. Ese tipo de entrada no está disponible de antemano, como una estructura de datos bien organizada, llega pieza por pieza, en tiempo real, y el programa debe responder a medida que sucede."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch15-l1",
        "title": "Controladores de Eventos",
        "sections": [
          {
            "id": "ch15-l1-s0",
            "title": "Controladores de Eventos",
            "content": [
              {
                "type": "paragraph",
                "content": "Imagina una interfaz donde la única forma de saber si una tecla en el teclado está siendo presionada es leyendo el estado actual de esa tecla. Para poder reaccionar a las pulsaciones de teclas, tendrías que leer constantemente el estado de la tecla para capturarla antes de que se libere nuevamente. Sería peligroso realizar otras computaciones intensivas en tiempo, ya que podrías perder una pulsación de tecla."
              },
              {
                "type": "paragraph",
                "content": "Algunas máquinas primitivas manejan la entrada de esa manera. Un paso adelante sería que el hardware o el sistema operativo noten la pulsación de tecla y la pongan en una cola. Un programa puede luego verificar periódicamente la cola en busca de nuevos eventos y reaccionar a lo que encuentre allí."
              },
              {
                "type": "paragraph",
                "content": "Por supuesto, tiene que recordar mirar la cola y hacerlo a menudo, porque cualquier tiempo transcurrido entre la presión de la tecla y la notificación del evento por parte del programa hará que el software se sienta sin respuesta. Este enfoque se llama <em>sondeo</em>. La mayoría de los programadores prefieren evitarlo."
              }
            ]
          },
          {
            "id": "ch15-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un mecanismo mejor es que el sistema notifique activamente a nuestro código cuando ocurre un evento. Los navegadores hacen esto al permitirnos registrar funciones como <em>manejadores</em> para eventos específicos."
              },
              {
                "type": "paragraph",
                "content": "La asignación <code>window</code> se refiere a un objeto integrado proporcionado por el navegador. Representa la ventana del navegador que contiene el documento. Llamar a su método <code>addEventListener</code> registra el segundo argumento para que se llame cada vez que ocurra el evento descrito por su primer argumento."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l2",
        "title": "Eventos y nodos DOM",
        "sections": [
          {
            "id": "ch15-l2-s0",
            "title": "Eventos y nodos DOM",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada controlador de eventos del navegador se registra en un contexto. En el ejemplo anterior llamamos a <code>addEventListener</code> en el objeto <code>window</code> para registrar un controlador para toda la ventana. Un método similar también se encuentra en elementos del DOM y algunos otros tipos de objetos. Los escuchas de eventos solo se llaman cuando el evento ocurre en el contexto del objeto en el que están registrados."
              },
              {
                "type": "paragraph",
                "content": "Ese ejemplo adjunta un manejador al nodo del botón. Los clics en el botón hacen que se ejecute ese manejador, pero los clics en el resto del documento no lo hacen."
              },
              {
                "type": "paragraph",
                "content": "Darle a un nodo un atributo <code>onclick</code> tiene un efecto similar. Esto funciona para la mayoría de tipos de eventos: puedes adjuntar un manejador a través del atributo cuyo nombre es el nombre del evento con <code>on</code> al inicio."
              }
            ]
          },
          {
            "id": "ch15-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero un nodo solo puede tener un atributo <code>onclick</code>, por lo que solo puedes registrar un manejador por nodo de esa manera. El método <code>addEventListener</code> te permite agregar cualquier cantidad de manejadores, por lo que es seguro agregar manejadores incluso si ya hay otro manejador en el elemento."
              },
              {
                "type": "paragraph",
                "content": "El método <code>removeEventListener</code>, llamado con argumentos similares a <code>addEventListener</code>, remueve un manejador."
              },
              {
                "type": "paragraph",
                "content": "La función proporcionada a <code>removeEventListener</code> debe ser el mismo valor de función que se proporcionó a <code>addEventListener</code>. Por lo tanto, para anular el registro de un manejador, querrás darle un nombre a la función (<code>unaVez</code>, en el ejemplo) para poder pasar el mismo valor de función a ambos métodos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l3",
        "title": "Objetos de eventos",
        "sections": [
          {
            "id": "ch15-l3-s0",
            "title": "Objetos de eventos",
            "content": [
              {
                "type": "paragraph",
                "content": "Aunque lo hemos ignorado hasta ahora, las funciones de manejadores de eventos reciben un argumento: el <em>objeto de evento</em>. Este objeto contiene información adicional sobre el evento. Por ejemplo, si queremos saber <em>cuál</em> botón del mouse se presionó, podemos mirar la propiedad <code>button</code> del objeto de evento."
              },
              {
                "type": "paragraph",
                "content": "La información almacenada en un objeto de evento difiere según el tipo de evento. Discutiremos diferentes tipos más adelante en el capítulo. La propiedad <code>type</code> del objeto siempre contiene una cadena que identifica el evento (como <code>\"click\"</code> o <code>\"mousedown\"</code>)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch15-l4",
        "title": "Propagación",
        "sections": [
          {
            "id": "ch15-l4-s0",
            "title": "Propagación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para la mayoría de tipos de evento, los manejadores registrados en nodos con hijos también recibirán eventos que ocurran en los hijos. Si se hace clic en un botón dentro de un párrafo, los manejadores de eventos en el párrafo también verán el evento de clic."
              },
              {
                "type": "paragraph",
                "content": "Pero si tanto el párrafo como el botón tienen un controlador, el controlador más específico —el del botón— tiene prioridad para ejecutarse primero. Se dice que el evento <em>se propaga</em> hacia afuera, desde el nodo donde ocurrió hacia el nodo padre de ese nodo y hasta la raíz del documento. Finalmente, después de que todos los controladores registrados en un nodo específico hayan tenido su turno, los controladores registrados en toda la ventana tienen la oportunidad de responder al evento."
              },
              {
                "type": "paragraph",
                "content": "En cualquier momento, un controlador de eventos puede llamar al método <code>stopPropagation</code> en el objeto de evento para evitar que los controladores superiores reciban el evento. Esto puede ser útil cuando, por ejemplo, tienes un botón dentro de otro elemento clickeable y no quieres que los clics en el botón activen el comportamiento de click del elemento externo."
              }
            ]
          },
          {
            "id": "ch15-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente ejemplo registra controladores de <code>\"mousedown\"</code> tanto en un botón como en el párrafo que lo rodea. Cuando se hace clic con el botón derecho del ratón, el controlador del botón llama a <code>stopPropagation</code>, lo que evitará que se ejecute el controlador en el párrafo. Cuando el botón se hace clic con otro botón del ratón, ambos controladores se ejecutarán."
              },
              {
                "type": "paragraph",
                "content": "La mayoría de los objetos de eventos tienen una propiedad <code>target</code> que se refiere al nodo donde se originaron. Puedes usar esta propiedad para asegurarte de que no estás manejando accidentalmente algo que se propagó desde un nodo que no deseas manejar."
              },
              {
                "type": "paragraph",
                "content": "También es posible usar la propiedad <code>target</code> para abarcar un amplio rango para un tipo específico de evento. Por ejemplo, si tienes un nodo que contiene una larga lista de botones, puede ser más conveniente registrar un único controlador de clic en el nodo externo y hacer que utilice la propiedad <code>target</code> para averiguar si se hizo clic en un botón, en lugar de registrar controladores individuales en todos los botones."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l5",
        "title": "Acciones predeterminadas",
        "sections": [
          {
            "id": "ch15-l5-s0",
            "title": "Acciones predeterminadas",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos eventos tienen una acción predeterminada asociada a ellos. Si haces clic en un enlace, serás llevado al destino del enlace. Si presionas la flecha hacia abajo, el navegador desplazará la página hacia abajo. Si haces clic derecho, obtendrás un menú contextual. Y así sucesivamente."
              },
              {
                "type": "paragraph",
                "content": "Para la mayoría de los tipos de eventos, los controladores de eventos de JavaScript se ejecutan <em>antes</em> de que ocurra el comportamiento predeterminado. Si el controlador no desea que este comportamiento normal ocurra, típicamente porque ya se encargó de manejar el evento, puede llamar al método <code>preventDefault</code> en el objeto de evento."
              },
              {
                "type": "paragraph",
                "content": "Esto se puede utilizar para implementar tus propios atajos de teclado o menús contextuales. También se puede usar para interferir de manera molesta con el comportamiento que los usuarios esperan. Por ejemplo, aquí hay un enlace que no se puede seguir:"
              }
            ]
          },
          {
            "id": "ch15-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Trata de no hacer este tipo de cosas a menos que tengas una razón realmente válida. Será desagradable para las personas que utilicen tu página cuando se rompa el comportamiento esperado."
              },
              {
                "type": "paragraph",
                "content": "Dependiendo del navegador, algunos eventos no se pueden interceptar en absoluto. En Chrome, por ejemplo, el atajo de teclado para cerrar la pestaña actual (control-W o command-W) no se puede manejar con JavaScript."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l6",
        "title": "Eventos de teclado",
        "sections": [
          {
            "id": "ch15-l6-s0",
            "title": "Eventos de teclado",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se presiona una tecla en el teclado, tu navegador dispara un evento <code>\"keydown\"</code>. Cuando se suelta, obtienes un evento <code>\"keyup\"</code>."
              },
              {
                "type": "paragraph",
                "content": "A pesar de su nombre, <code>\"keydown\"</code> se dispara no solo cuando la tecla se presiona físicamente hacia abajo. Cuando se presiona y se mantiene una tecla, el evento se vuelve a disparar cada vez que la tecla <em>se repite</em>. A veces tienes que tener cuidado con esto. Por ejemplo, si agregas un botón al DOM cuando se presiona una tecla y lo eliminas de nuevo cuando se suelta la tecla, podrías agregar accidentalmente cientos de botones cuando se mantiene presionada la tecla durante más tiempo."
              },
              {
                "type": "paragraph",
                "content": "El ejemplo observó la propiedad <code>key</code> del objeto evento para ver sobre qué tecla es el evento. Esta propiedad contiene una cadena que, para la mayoría de las teclas, corresponde a lo que escribirías al presionar esa tecla. Para teclas especiales como <span class=\"keyname\">enter</span>, contiene una cadena que nombra la tecla (<code>\"Enter\"</code>, en este caso). Si mantienes presionado <span class=\"keyname\">shift</span> mientras presionas una tecla, eso también puede influir en el nombre de la tecla: <code>\"v\"</code> se convierte en <code>\"V\"</code>, y <code>\"1\"</code> puede convertirse en <code>\"!\"</code>, si eso es lo que produce al presionar <span class=\"keyname\">shift</span>-1 en tu teclado."
              }
            ]
          },
          {
            "id": "ch15-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las teclas modificadoras como <span class=\"keyname\">shift</span>, <span class=\"keyname\">control</span>, <span class=\"keyname\">alt</span> y <span class=\"keyname\">meta</span> (command en Mac) generan eventos de tecla igual que las teclas normales. Pero al buscar combinaciones de teclas, también puedes averiguar si estas teclas se mantienen presionadas mirando las propiedades <code>shiftKey</code>, <code>ctrlKey</code>, <code>altKey</code> y <code>metaKey</code> de los eventos de teclado y ratón."
              },
              {
                "type": "paragraph",
                "content": "El nodo del DOM donde se origina un evento de teclado depende del elemento que tiene foco cuando se presiona la tecla. La mayoría de los nodos no pueden tener foco a menos que les des un atributo <code>tabindex</code>, pero cosas como los enlaces, botones y campos de formulario pueden. Volveremos a los campos de formulario en el Capítulo 18. Cuando nada en particular tiene foco, <code>document.body</code> actúa como el nodo objetivo de los eventos de teclado."
              },
              {
                "type": "paragraph",
                "content": "Cuando el usuario está escribiendo texto, utilizar eventos de teclado para averiguar qué se está escribiendo es problemático. Algunas plataformas, especialmente el teclado virtual en teléfonos Android, no disparan eventos de teclado. Pero incluso cuando se tiene un teclado tradicional, algunos tipos de entrada de texto no coinciden con las pulsaciones de teclas de manera directa, como el software de <em>editor de método de entrada</em> (IME) utilizado por personas cuyos guiones no caben en un teclado, donde múltiples pulsaciones de teclas se combinan para crear caracteres."
              }
            ]
          },
          {
            "id": "ch15-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para detectar cuando se ha escrito algo, los elementos en los que se puede escribir, como las etiquetas <code>&lt;input&gt;</code> y <code>&lt;textarea&gt;</code>, activan eventos <code>\"input\"</code> cada vez que el usuario cambia su contenido. Para obtener el contenido real que se ha escrito, lo mejor es leerlo directamente del campo enfocado. Capítulo 18 mostrará cómo hacerlo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch15-l7",
        "title": "Eventos de puntero",
        "sections": [
          {
            "id": "ch15-l7-s0",
            "title": "Eventos de puntero",
            "content": [
              {
                "type": "paragraph",
                "content": "Actualmente existen dos formas ampliamente utilizadas de señalar cosas en una pantalla: los ratones (incluyendo dispositivos que actúan como ratones, como touchpads y trackballs) y las pantallas táctiles. Estas producen diferentes tipos de eventos."
              },
              {
                "type": "paragraph",
                "content": "Presionar un botón de ratón provoca que se disparen varios eventos. Los eventos <code>\"mousedown\"</code> y <code>\"mouseup\"</code> son similares a <code>\"keydown\"</code> y <code>\"keyup\"</code> y se activan cuando se presiona y se suelta el botón. Estos eventos ocurren en los nodos del DOM que están inmediatamente debajo del puntero del ratón cuando se produce el evento."
              },
              {
                "type": "paragraph",
                "content": "Después del evento <code>\"mouseup\"</code>, se dispara un evento <code>\"click\"</code> en el nodo más específico que contenía tanto la pulsación como la liberación del botón. Por ejemplo, si presiono el botón del ratón en un párrafo y luego muevo el puntero a otro párrafo y suelto el botón, el evento <code>\"click\"</code> ocurrirá en el elemento que contiene ambos párrafos."
              }
            ]
          },
          {
            "id": "ch15-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si dos clics ocurren cerca uno del otro, también se dispara un evento <code>\"dblclick\"</code> (doble clic), después del segundo evento de clic."
              },
              {
                "type": "paragraph",
                "content": "Para obtener información precisa sobre el lugar donde ocurrió un evento de ratón, puedes mirar sus propiedades <code>clientX</code> y <code>clientY</code>, que contienen las coordenadas del evento (en píxeles) relativas a la esquina superior izquierda de la ventana, o <code>pageX</code> y <code>pageY</code>, que son relativas a la esquina superior izquierda de todo el documento (lo cual puede ser diferente cuando la ventana ha sido desplazada)."
              },
              {
                "type": "paragraph",
                "content": "El siguiente programa implementa una aplicación de dibujo primitiva. Cada vez que haces clic en el documento, agrega un punto bajo el puntero de tu ratón. Ver Capítulo 19 para una aplicación de dibujo menos primitiva."
              }
            ]
          },
          {
            "id": "ch15-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada vez que el puntero del ratón se mueve, se dispara un evento <code>\"mousemove\"</code>. Este evento se puede usar para rastrear la posición del ratón. Una situación común en la que esto es útil es al implementar algún tipo de funcionalidad de arrastrar y soltar con el ratón."
              },
              {
                "type": "paragraph",
                "content": "Como ejemplo, el siguiente programa muestra una barra y configura controladores de eventos para que al arrastrar hacia la izquierda o hacia la derecha en esta barra, se haga más estrecha o más ancha:"
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que el controlador <code>\"mousemove\"</code> está registrado en toda la window. Incluso si el ratón sale de la barra durante el cambio de tamaño, mientras el botón se mantenga presionado todavía queremos actualizar su tamaño."
              }
            ]
          },
          {
            "id": "ch15-l7-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Debemos detener el cambio de tamaño de la barra cuando se libere el botón del ratón. Para eso, podemos usar la propiedad <code>buttons</code> (notar el plural), que nos indica qué botones están actualmente presionados. Cuando este valor es cero, ningún botón está presionado. Cuando se mantienen presionados botones, su valor es la suma de los códigos de esos botones—el botón izquierdo tiene el código 1, el derecho 2 y el central 4. Con el botón izquierdo y el derecho presionados, por ejemplo, el valor de <code>buttons</code> será 3."
              },
              {
                "type": "paragraph",
                "content": "Es importante destacar que el orden de estos códigos es diferente al utilizado por <code>button</code>, donde el botón central venía antes que el derecho. Como se mencionó, la consistencia no es realmente un punto fuerte de la interfaz de programación del navegador."
              },
              {
                "type": "paragraph",
                "content": "El estilo de navegador gráfico que usamos fue diseñado pensando en interfaces de ratón, en una época donde las pantallas táctiles eran raras. Para hacer que la web “funcione” en los primeros teléfonos con pantalla táctil, los navegadores de esos dispositivos fingían, hasta cierto punto, que los eventos táctiles eran eventos de ratón. Si tocas la pantalla, recibirás eventos de <code>\"mousedown\"</code>, <code>\"mouseup\"</code> y <code>\"click\"</code>."
              }
            ]
          },
          {
            "id": "ch15-l7-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero esta ilusión no es muy robusta. Una pantalla táctil funciona de manera diferente a un ratón: no tiene múltiples botones, no se puede rastrear el dedo cuando no está en la pantalla (para simular <code>\"mousemove\"</code>), y permite que varios dedos estén en la pantalla al mismo tiempo."
              },
              {
                "type": "paragraph",
                "content": "Los eventos de ratón solo cubren la interacción táctil en casos sencillos: si agregas un controlador de <code>\"click\"</code> a un botón, los usuarios táctiles aún podrán usarlo. Pero algo como la barra redimensionable del ejemplo anterior no funciona en una pantalla táctil."
              },
              {
                "type": "paragraph",
                "content": "Existen tipos específicos de eventos disparados por la interacción táctil. Cuando un dedo comienza a tocar la pantalla, se genera un evento <code>\"touchstart\"</code>. Cuando se mueve mientras toca, se generan eventos <code>\"touchmove\"</code>. Finalmente, cuando deja de tocar la pantalla, verás un evento <code>\"touchend\"</code>."
              }
            ]
          },
          {
            "id": "ch15-l7-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Debido a que muchas pantallas táctiles pueden detectar varios dedos al mismo tiempo, estos eventos no tienen un único conjunto de coordenadas asociadas. Más bien, sus objetos de eventos tienen una propiedad <code>touches</code>, que contiene un objeto similar a un array de puntos, cada uno con sus propias propiedades <code>clientX</code>, <code>clientY</code>, <code>pageX</code> y <code>pageY</code>."
              },
              {
                "type": "paragraph",
                "content": "Podrías hacer algo como esto para mostrar círculos rojos alrededor de cada dedo que toca:"
              },
              {
                "type": "paragraph",
                "content": "A menudo querrás llamar a <code>preventDefault</code> en los controladores de eventos táctiles para anular el comportamiento predeterminado del navegador (que puede incluir desplazar la página al deslizar) y evitar que se generen eventos de ratón, para los cuales también puedes tener un controlador."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      },
      {
        "id": "ch15-l8",
        "title": "Eventos de desplazamiento",
        "sections": [
          {
            "id": "ch15-l8-s0",
            "title": "Eventos de desplazamiento",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada vez que un elemento se desplaza, se dispara un evento <code>\"scroll\"</code>. Esto tiene varios usos, como saber qué está viendo actualmente el usuario (para desactivar animaciones fuera de la pantalla o enviar informes de vigilancia a tu malvada sede) o mostrar alguna indicación de progreso (resaltando parte de una tabla de contenidos o mostrando un número de página).El siguiente ejemplo dibuja una barra de progreso sobre el documento y la actualiza para llenarla a medida que se desplaza hacia abajo:"
              },
              {
                "type": "paragraph",
                "content": "Darle a un elemento una <code>position</code> de <code>fixed</code> actúa de manera similar a una posición <code>absolute</code>, pero también evita que se desplace junto con el resto del documento. El efecto es hacer que nuestra barra de progreso permanezca en la parte superior. Su ancho se cambia para indicar el progreso actual. Usamos <code>%</code>, en lugar de <code>px</code>, como unidad al establecer el ancho para que el elemento tenga un tamaño relativo al ancho de la página."
              },
              {
                "type": "paragraph",
                "content": "El enlace global <code>innerHeight</code> nos da la altura de la ventana, que debemos restar de la altura total desplazable, ya que no se puede seguir desplazando cuando se llega al final del documento. También existe un <code>innerWidth</code> para el ancho de la ventana. Al dividir <code>pageYOffset</code>, la posición actual de desplazamiento, por la posición máxima de desplazamiento y multiplicar por 100, obtenemos el porcentaje para la barra de progreso."
              }
            ]
          },
          {
            "id": "ch15-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Llamar a <code>preventDefault</code> en un evento de desplazamiento no impide que ocurra el desplazamiento. De hecho, el controlador de eventos se llama solo <em>después</em> de que ocurre el desplazamiento."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l9",
        "title": "Eventos de enfoque",
        "sections": [
          {
            "id": "ch15-l9-s0",
            "title": "Eventos de enfoque",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando un elemento recibe el enfoque, el navegador dispara un evento <code>\"focus\"</code> en él. Cuando pierde el enfoque, el elemento recibe un evento <code>\"blur\"</code>."
              },
              {
                "type": "paragraph",
                "content": "A diferencia de los eventos discutidos anteriormente, estos dos eventos no se propagan. Un controlador en un elemento padre no recibe notificaciones cuando un elemento hijo recibe o pierde el enfoque."
              },
              {
                "type": "paragraph",
                "content": "El siguiente ejemplo muestra texto de ayuda para el campo de texto que actualmente tiene el foco:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch15-l10",
        "title": "Evento de carga",
        "sections": [
          {
            "id": "ch15-l10-s0",
            "title": "Evento de carga",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando una página termina de cargarse, se dispara el evento <code>\"load\"</code> en los objetos ventana y cuerpo del documento. Esto se usa a menudo para programar acciones de inicialización que requieren que todo el documento haya sido construido. Recuerda que el contenido de las etiquetas <code>&lt;script&gt;</code> se ejecuta inmediatamente cuando se encuentra la etiqueta. Esto puede ser demasiado pronto, por ejemplo, cuando el script necesita hacer algo con partes del documento que aparecen después de la etiqueta <code>&lt;script&gt;</code>."
              },
              {
                "type": "paragraph",
                "content": "Elementos como imágenes y etiquetas de script que cargan un archivo externo también tienen un evento <code>\"load\"</code> que indica que se cargaron los archivos a los que hacen referencia. Al igual que los eventos relacionados con el enfoque, los eventos de carga no se propagan."
              },
              {
                "type": "paragraph",
                "content": "Cuando se cierra una página o se navega lejos de ella (por ejemplo, al seguir un enlace), se dispara un evento <code>\"beforeunload\"</code>. El uso principal de este evento es evitar que el usuario pierda accidentalmente su trabajo al cerrar un documento. Si previenes el comportamiento predeterminado en este evento <em>y</em> estableces la propiedad <code>returnValue</code> en el objeto de evento a una cadena, el navegador mostrará al usuario un cuadro de diálogo preguntando si realmente desea abandonar la página. Ese cuadro de diálogo podría incluir tu cadena, pero debido a que algunos sitios maliciosos intentan usar estos cuadros de diálogo para confundir a las personas y hacer que se queden en su página para ver anuncios de pérdida de peso dudosos, la mayoría de los navegadores ya no los muestran."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch15-l11",
        "title": "Eventos y el bucle de eventos",
        "sections": [
          {
            "id": "ch15-l11-s0",
            "title": "Eventos y el bucle de eventos",
            "content": [
              {
                "type": "paragraph",
                "content": "En el contexto del bucle de eventos, como se discutió en el Capítulo 11, los controladores de eventos del navegador se comportan como otras notificaciones asíncronas. Se programan cuando ocurre el evento pero deben esperar a que otros scripts que se estén ejecutando terminen antes de tener la oportunidad de ejecutarse."
              },
              {
                "type": "paragraph",
                "content": "El hecho de que los eventos solo se puedan procesar cuando no hay nada más en ejecución significa que, si el bucle de eventos está ocupado con otro trabajo, cualquier interacción con la página (que ocurre a través de eventos) se retrasará hasta que haya tiempo para procesarla. Entonces, si programas demasiado trabajo, ya sea con controladores de eventos de larga duración o con muchos que se ejecutan rápidamente, la página se volverá lenta y pesada de usar."
              },
              {
                "type": "paragraph",
                "content": "Para casos en los que <em>realmente</em> quieres hacer algo que consume mucho tiempo en segundo plano sin congelar la página, los navegadores proporcionan algo llamado <em>web workers</em>. Un worker es un proceso de JavaScript que se ejecuta junto al script principal, en su propia línea de tiempo."
              }
            ]
          },
          {
            "id": "ch15-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Imagina que elevar al cuadrado un número es una computación pesada y de larga duración que queremos realizar en un hilo separado. Podríamos escribir un archivo llamado <code>code/<wbr>squareworker.<wbr>js</code> que responda a mensajes calculando un cuadrado y enviando un mensaje de vuelta."
              },
              {
                "type": "paragraph",
                "content": "Para evitar los problemas de tener múltiples hilos tocando los mismos datos, los workers no comparten su alcance global ni ningún otro dato con el entorno del script principal. En cambio, debes comunicarte con ellos enviando mensajes de ida y vuelta."
              },
              {
                "type": "paragraph",
                "content": "Este código genera un worker que ejecuta ese script, le envía algunos mensajes y muestra las respuestas."
              }
            ]
          },
          {
            "id": "ch15-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>postMessage</code> envía un mensaje, lo que causará que se dispare un evento <code>\"message\"</code> en el receptor. El script que creó el worker envía y recibe mensajes a través del objeto <code>Worker</code>, mientras que el worker se comunica con el script que lo creó enviando y escuchando directamente en su alcance global. Solo se pueden enviar como mensajes valores que puedan representarse como JSON; el otro lado recibirá una <em>copia</em> de ellos en lugar del valor en sí mismo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch15-l12",
        "title": "Temporizadores",
        "sections": [
          {
            "id": "ch15-l12-s0",
            "title": "Temporizadores",
            "content": [
              {
                "type": "paragraph",
                "content": "Vimos la función <code>setTimeout</code> en el Capítulo 11. Programa otra función para que se llame más tarde, después de un cierto número de milisegundos."
              },
              {
                "type": "paragraph",
                "content": "A veces necesitas cancelar una función que has programado. Esto se hace almacenando el valor devuelto por <code>setTimeout</code> y llamando a <code>clearTimeout</code> sobre él."
              },
              {
                "type": "paragraph",
                "content": "La función <code>cancelAnimationFrame</code> funciona de la misma manera que <code>clearTimeout</code>; llamarla en un valor devuelto por <code>requestAnimationFrame</code> cancelará ese fotograma (si no se ha llamado ya)."
              }
            ]
          },
          {
            "id": "ch15-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un conjunto similar de funciones, <code>setInterval</code> y <code>clearInterval</code>, se utilizan para programar temporizadores que deben <em>repetirse</em> cada <em>X</em> milisegundos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l13",
        "title": "Debouncing",
        "sections": [
          {
            "id": "ch15-l13-s0",
            "title": "Debouncing",
            "content": [
              {
                "type": "paragraph",
                "content": "Algunos tipos de eventos pueden activarse rápidamente, muchas veces seguidas (como los eventos <code>\"mousemove\"</code> y <code>\"scroll\"</code>, por ejemplo). Al manejar tales eventos, debes tener cuidado de no hacer nada que consuma demasiado tiempo, ya que tu controlador tomará tanto tiempo que la interacción con el documento comenzará a sentirse lenta."
              },
              {
                "type": "paragraph",
                "content": "Si necesitas hacer algo importante en un controlador de este tipo, puedes usar <code>setTimeout</code> para asegurarte de que no lo estás haciendo con demasiada frecuencia. Esto suele llamarse <em>debouncing</em> el evento. Hay varios enfoques ligeramente diferentes para esto."
              },
              {
                "type": "paragraph",
                "content": "En el primer ejemplo, queremos reaccionar cuando el usuario ha escrito algo, pero no queremos hacerlo inmediatamente para cada evento de entrada. Cuando están escribiendo rápidamente, solo queremos esperar hasta que ocurra una pausa. En lugar de realizar inmediatamente una acción en el controlador de eventos, establecemos un tiempo de espera. También limpiamos el tiempo de espera anterior (si existe) para que cuando los eventos ocurran cerca uno del otro (más cerca de nuestro retraso de tiempo de espera), el tiempo de espera del evento anterior se cancele."
              }
            ]
          },
          {
            "id": "ch15-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dar un valor no definido a <code>clearTimeout</code> o llamarlo en un tiempo de espera que ya ha pasado no tiene efecto. Por lo tanto, no tenemos que tener cuidado de cuándo llamarlo, y simplemente lo hacemos para cada evento."
              },
              {
                "type": "paragraph",
                "content": "Podemos usar un patrón ligeramente diferente si queremos espaciar las respuestas para que estén separadas por al menos una cierta longitud de tiempo, pero queremos activarlas <em>durante</em> una serie de eventos, no solo después. Por ejemplo, podríamos querer responder a eventos <code>\"mousemove\"</code> mostrando las coordenadas actuales del mouse pero solo cada 250 milisegundos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l14",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch15-l14-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Los controladores de eventos hacen posible detectar y reaccionar a eventos que ocurren en nuestra página web. El método <code>addEventListener</code> se utiliza para registrar dicho controlador."
              },
              {
                "type": "paragraph",
                "content": "Cada evento tiene un tipo (<code>\"keydown\"</code>, <code>\"focus\"</code>, y así sucesivamente) que lo identifica. La mayoría de los eventos se activan en un elemento DOM específico y luego se <em>propagan</em> a los ancestros de ese elemento, lo que permite que los controladores asociados a esos elementos los manejen."
              },
              {
                "type": "paragraph",
                "content": "Cuando se llama a un controlador de eventos, se le pasa un objeto de evento con información adicional sobre el evento. Este objeto también tiene métodos que nos permiten detener una mayor propagación (<code>stopPropagation</code>) y evitar el manejo predeterminado del evento por parte del navegador (<code>preventDefault</code>)."
              }
            ]
          },
          {
            "id": "ch15-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Presionar una tecla dispara eventos <code>\"keydown\"</code> y <code>\"keyup\"</code>. Presionar un botón del mouse dispara eventos <code>\"mousedown\"</code>, <code>\"mouseup\"</code> y <code>\"click\"</code>. Mover el mouse dispara eventos <code>\"mousemove\"</code>. La interacción con pantallas táctiles dará lugar a eventos <code>\"touchstart\"</code>, <code>\"touchmove\"</code> y <code>\"touchend\"</code>."
              },
              {
                "type": "paragraph",
                "content": "El desplazamiento se puede detectar con el evento <code>\"scroll\"</code>, y los cambios de enfoque se pueden detectar con los eventos <code>\"focus\"</code> y <code>\"blur\"</code>. Cuando el documento ha terminado de cargarse, se activa un evento <code>\"load\"</code> en la ventana."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch15-l15",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch15-l15-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe una página que muestre un globo (usando el emoji de globo, 🎈). Cuando presiones la flecha hacia arriba, debería inflarse (crecer) un 10 por ciento, y cuando presiones la flecha hacia abajo, debería desinflarse (encoger) un 10 por ciento."
              },
              {
                "type": "paragraph",
                "content": "Puedes controlar el tamaño del texto (los emoji son texto) estableciendo la propiedad CSS <code>font-size</code> (<code>style.fontSize</code>) en su elemento padre. Recuerda incluir una unidad en el valor, por ejemplo, píxeles (<code>10px</code>)."
              },
              {
                "type": "paragraph",
                "content": "Los nombres de las teclas de flecha son <code>\"ArrowUp\"</code> y <code>\"ArrowDown\"</code>. Asegúrate de que las teclas cambien solo el globo, sin hacer scroll en la página."
              }
            ]
          },
          {
            "id": "ch15-l15-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando eso funcione, añade una característica en la que, si inflas el globo más allá de un cierto tamaño, explote. En este caso, explotar significa que se reemplace con un emoji de 💥, y el manejador de eventos se elimine (para que no se pueda inflar o desinflar la explosión)."
              },
              {
                "type": "paragraph",
                "content": "Querrás registrar un manejador para el evento <code>\"keydown\"</code> y mirar <code>event.key</code> para saber si se presionó la tecla de flecha hacia arriba o hacia abajo."
              },
              {
                "type": "paragraph",
                "content": "El tamaño actual se puede mantener en un enlace para que puedas basarte en él para el nuevo tamaño. Será útil definir una función que actualice el tamaño, tanto el enlace como el estilo del globo en el DOM, para que puedas llamarla desde tu manejador de eventos, y posiblemente también una vez al inicio, para establecer el tamaño inicial."
              }
            ]
          },
          {
            "id": "ch15-l15-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes cambiar el globo por una explosión reemplazando el nodo de texto por otro (usando <code>replaceChild</code>) o estableciendo la propiedad <code>textContent</code> de su nodo padre en una nueva cadena."
              },
              {
                "type": "paragraph",
                "content": "En los primeros días de JavaScript, que fue la época dorada de las páginas de inicio estridentes con un montón de imágenes animadas, la gente ideó formas verdaderamente inspiradoras de usar el lenguaje."
              },
              {
                "type": "paragraph",
                "content": "Una de estas era la <em>estela del ratón</em> —una serie de elementos que seguirían al puntero del ratón mientras lo movías por la página."
              }
            ]
          },
          {
            "id": "ch15-l15-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En este ejercicio, quiero que implementes una estela del ratón. Utiliza elementos <code>&lt;div&gt;</code> con posición absoluta y un tamaño fijo y color de fondo (consulta el código en la sección de “Clics de ratón” para un ejemplo). Crea un montón de estos elementos y, al mover el ratón, muéstralos en la estela del puntero del ratón."
              },
              {
                "type": "paragraph",
                "content": "Hay varias aproximaciones posibles aquí. Puedes hacer tu solución tan simple o tan compleja como desees. Una solución simple para empezar es mantener un número fijo de elementos de estela y recorrerlos, moviendo el siguiente a la posición actual del ratón cada vez que ocurra un evento <code>\"mousemove\"</code>."
              },
              {
                "type": "paragraph",
                "content": "Crear los elementos es mejor hacerlo con un bucle. Adjúntalos al documento para que aparezcan. Para poder acceder a ellos más tarde y cambiar su posición, querrás almacenar los elementos en un array."
              }
            ]
          },
          {
            "id": "ch15-l15-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Recorrerlos se puede hacer manteniendo una variable de contador y sumándole 1 cada vez que se dispare el evento <code>\"mousemove\"</code>. Luego se puede usar el operador de resto (<code>% elementos.<wbr>length</code>) para obtener un índice de array válido para elegir el elemento que deseas posicionar durante un evento dado."
              },
              {
                "type": "paragraph",
                "content": "Otro efecto interesante se puede lograr modelando un simple sistema de física. Usa el evento <code>\"mousemove\"</code> solo para actualizar un par de enlaces que siguen la posición del ratón. Luego utiliza <code>requestAnimationFrame</code> para simular que los elementos rastreadores son atraídos a la posición del puntero del ratón. En cada paso de animación, actualiza su posición basándote en su posición relativa al puntero (y, opcionalmente, una velocidad que está almacenada para cada elemento). Descubrir una buena forma de hacer esto queda a tu cargo."
              },
              {
                "type": "paragraph",
                "content": "Los paneles con pestañas son ampliamente utilizados en interfaces de usuario. Te permiten seleccionar un panel de interfaz eligiendo entre varias pestañas que sobresalen por encima de un elemento."
              }
            ]
          },
          {
            "id": "ch15-l15-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En este ejercicio debes implementar una interfaz de pestañas simple. Escribe una función, <code>asTabs</code>, que tome un nodo DOM y cree una interfaz de pestañas que muestre los elementos secundarios de ese nodo. Debería insertar una lista de elementos <code>&lt;button&gt;</code> en la parte superior del nodo, uno por cada elemento secundario, conteniendo el texto recuperado del atributo <code>data-tabname</code> del hijo. Todos los hijos originales excepto uno deben estar ocultos (con un estilo <code>display</code> de <code>none</code>). El nodo actualmente visible se puede seleccionar haciendo clic en los botones."
              },
              {
                "type": "paragraph",
                "content": "Cuando funcione, extiéndelo para dar estilo al botón de la pestaña actualmente seleccionada de manera diferente para que sea obvio cuál pestaña está seleccionada."
              },
              {
                "type": "paragraph",
                "content": "Un error en el que podrías caer es que no puedes usar directamente la propiedad <code>childNodes</code> del nodo como una colección de nodos de pestaña. Por un lado, cuando agregas los botones, también se convertirán en nodos secundarios y terminarán en este objeto porque es una estructura de datos en vivo. Por otro lado, los nodos de texto creados para el espacio en blanco entre los nodos también están en <code>childNodes</code> pero no deberían tener sus propias pestañas. Puedes usar <code>children</code> en lugar de <code>childNodes</code> para ignorar los nodos de texto."
              }
            ]
          },
          {
            "id": "ch15-l15-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Podrías empezar construyendo un array de pestañas para tener fácil acceso a ellas. Para implementar el estilo de los botones, podrías almacenar objetos que contengan tanto el panel de la pestaña como su botón."
              },
              {
                "type": "paragraph",
                "content": "Recomiendo escribir una función separada para cambiar las pestañas. Puedes almacenar la pestaña seleccionada previamente y cambiar solo los estilos necesarios para ocultarla y mostrar la nueva, o puedes actualizar el estilo de todas las pestañas cada vez que se seleccione una nueva pestaña."
              },
              {
                "type": "paragraph",
                "content": "Quizás quieras llamar a esta función inmediatamente para que la interfaz comience con la primera pestaña visible."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      }
    ]
  },
  {
    "id": "ch16",
    "number": 16,
    "title": "Proyecto: Un juego de plataformas",
    "titleEs": "Proyecto: Un juego de plataformas",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "Toda la realidad es un juego....",
    "isProject": true,
    "totalXP": 460,
    "lessons": [
      {
        "id": "ch16-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch16-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Toda la realidad es un juego. Iain Banks, The Player of Games"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un juego de plataformas __ Eloquent JavaScript_files/chapter_picture_16.jpg",
                "alt": "Ilustración que muestra un personaje de un juego de computadora saltando sobre lava en un mundo bidimensional"
              },
              {
                "type": "paragraph",
                "content": "Gran parte de mi fascinación inicial con las computadoras, al igual que la de muchos niños nerds, tenía que ver con los juegos de computadora. Me sentía atraído por los diminutos mundos simulados que podía manipular y en los que se desarrollaban historias (más o menos), supongo, debido a la forma en que proyectaba mi imaginación en ellos más que por las posibilidades que realmente ofrecían."
              }
            ]
          },
          {
            "id": "ch16-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "No le desearía a nadie una carrera en programación de juegos. Al igual que la industria de la música, la discrepancia entre la cantidad de jóvenes entusiastas que desean trabajar en ella y la demanda real de tales personas crea un entorno bastante insalubre. Pero escribir juegos por diversión resulta entretenido."
              },
              {
                "type": "paragraph",
                "content": "Este capítulo guiará a través de la implementación de un pequeño juego de plataformas. Los juegos de plataformas (o juegos de “saltos y carreras”) son juegos que esperan que el jugador mueva una figura a través de un mundo, que generalmente es bidimensional y se ve desde el lado, mientras salta sobre y sobre cosas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch16-l1",
        "title": "El juego",
        "sections": [
          {
            "id": "ch16-l1-s0",
            "title": "El juego",
            "content": [
              {
                "type": "paragraph",
                "content": "Nuestro juego estará basado aproximadamente en Dark Blue de Thomas Palef. Elegí ese juego porque es entretenido, minimalista y se puede construir sin mucho código. Se ve así:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un juego de plataformas __ Eloquent JavaScript_files/darkblue.png",
                "alt": "Captura de pantalla del juego &#39;Dark Blue&#39;, mostrando un mundo hecho de cajas de colores. Hay una caja negra que representa al jugador, de pie sobre líneas blancas en un fondo azul. Pequeñas monedas amarillas flotan en el aire, y algunas partes del fondo son rojas, representando lava."
              },
              {
                "type": "paragraph",
                "content": "La caja oscura representa al jugador, cuya tarea es recolectar las cajas amarillas (monedas) evitando las cosas rojas (lava). Un nivel se completa cuando se han recolectado todas las monedas."
              }
            ]
          },
          {
            "id": "ch16-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El jugador puede moverse con las teclas de flecha izquierda y derecha y puede saltar con la tecla de flecha hacia arriba. Saltar es una especialidad de este personaje del juego. Puede alcanzar varias veces su altura y puede cambiar de dirección en el aire. Esto puede no ser del todo realista, pero ayuda a darle al jugador la sensación de tener un control directo sobre el avatar en pantalla."
              },
              {
                "type": "paragraph",
                "content": "El juego consiste en un fondo estático, dispuesto como una rejilla, con los elementos móviles superpuestos en ese fondo. Cada campo en la rejilla está vacío, sólido o es lava. Los elementos móviles son el jugador, las monedas y ciertas piezas de lava. Las posiciones de estos elementos no están restringidas a la rejilla: sus coordenadas pueden ser fraccionarias, permitiendo un movimiento suave."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch16-l2",
        "title": "La tecnología",
        "sections": [
          {
            "id": "ch16-l2-s0",
            "title": "La tecnología",
            "content": [
              {
                "type": "paragraph",
                "content": "Usaremos el DOM del navegador para mostrar el juego y leeremos la entrada del usuario manejando eventos de teclado."
              },
              {
                "type": "paragraph",
                "content": "El código relacionado con la pantalla y el teclado es solo una pequeña parte del trabajo que necesitamos hacer para construir este juego. Dado que todo se ve como cajas de colores, dibujar es sencillo: creamos elementos del DOM y usamos estilos para darles un color de fondo, tamaño y posición."
              },
              {
                "type": "paragraph",
                "content": "Podemos representar el fondo como una tabla ya que es una cuadrícula inmutable de cuadrados. Los elementos de movimiento libre se pueden superponer utilizando elementos posicionados absolutamente."
              }
            ]
          },
          {
            "id": "ch16-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En juegos y otros programas que deben animar gráficos y responder a la entrada del usuario sin retrasos notables, la eficiencia es importante. Aunque el DOM no fue diseñado originalmente para gráficos de alto rendimiento, en realidad es mejor en esto de lo que podrías esperar. Viste algunas animaciones en el Capítulo 14. En una máquina moderna, un juego simple como este funciona bien, incluso si no nos preocupamos mucho por la optimización."
              },
              {
                "type": "paragraph",
                "content": "En el próximo capítulo, exploraremos otra tecnología del navegador, la etiqueta <code>&lt;canvas&gt;</code>, que proporciona una forma más tradicional de dibujar gráficos, trabajando en términos de formas y píxeles en lugar de elementos del DOM."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch16-l3",
        "title": "Niveles",
        "sections": [
          {
            "id": "ch16-l3-s0",
            "title": "Niveles",
            "content": [
              {
                "type": "paragraph",
                "content": "Queremos una forma legible y editable por humanos para especificar niveles. Dado que está bien que todo comience en una cuadrícula, podríamos usar cadenas grandes en las que cada carácter represente un elemento, ya sea una parte de la cuadrícula de fondo o un elemento móvil."
              },
              {
                "type": "paragraph",
                "content": "El plan para un nivel pequeño podría verse así:"
              },
              {
                "type": "paragraph",
                "content": "Los puntos representan un espacio vacío, los caracteres de almohadilla (<code>#</code>) son paredes y los signos más son lava. La posición inicial del jugador es el signo de arroba (<code>@</code>). Cada carácter O es una moneda, y el signo igual (<code>=</code>) en la parte superior es un bloque de lava que se mueve de un lado a otro horizontalmente."
              }
            ]
          },
          {
            "id": "ch16-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Además de las dos formas adicionales de lava en movimiento, el carácter de tubería (<code>|</code>) crea blobs que se mueven verticalmente, y <code>v</code> indica lava goteante: lava que se mueve verticalmente y no rebota de un lado a otro, solo se mueve hacia abajo, volviendo a su posición de inicio cuando golpea el suelo."
              },
              {
                "type": "paragraph",
                "content": "Un juego completo consta de varios niveles que el jugador debe completar. Un nivel se completa cuando se han recolectado todas las monedas. Si el jugador toca la lava, el nivel actual se restablece a su posición inicial y el jugador puede intentarlo de nuevo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch16-l4",
        "title": "Leyendo un nivel",
        "sections": [
          {
            "id": "ch16-l4-s0",
            "title": "Leyendo un nivel",
            "content": [
              {
                "type": "paragraph",
                "content": "La siguiente clase almacena un objeto nivel. Su argumento debe ser la cadena que define el nivel."
              },
              {
                "type": "paragraph",
                "content": "El método <code>trim</code> se utiliza para eliminar los espacios en blanco al principio y al final de la cadena de plan. Esto permite que nuestro plan de ejemplo comience con una nueva línea para que todas las líneas estén directamente debajo unas de otras. La cadena restante se divide en líneas en caracteres de nueva línea, y cada línea se convierte en un array, produciendo arrays de caracteres."
              },
              {
                "type": "paragraph",
                "content": "Entonces, <code>rows</code> contiene un array de arrays de caracteres, las filas del plan. Podemos derivar el ancho y alto del nivel a partir de estos. Pero aún debemos separar los elementos móviles de la cuadrícula de fondo. Llamaremos a los elementos móviles <em>actores</em>. Se almacenarán en un array de objetos. El fondo será un array de arrays de cadenas, que contienen tipos de campo como <code>\"empty\"</code>, <code>\"wall\"</code>, o <code>\"lava\"</code>."
              }
            ]
          },
          {
            "id": "ch16-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para crear estos arrays, mapeamos sobre las filas y luego sobre su contenido. Recuerda que <code>map</code> pasa el índice del array como segundo argumento a la función de mapeo, lo que nos indica las coordenadas x e y de un carácter dado. Las posiciones en el juego se almacenarán como pares de coordenadas, siendo la esquina superior izquierda 0,0 y cada cuadro de fondo siendo de 1 unidad de alto y ancho."
              },
              {
                "type": "paragraph",
                "content": "Para interpretar los caracteres en el plan, el constructor de <code>Level</code> utiliza el objeto <code>levelChars</code>, que, para cada carácter utilizado en las descripciones de niveles, contiene una cadena si es un tipo de fondo, y una clase si produce un actor. Cuando <code>type</code> es una clase de actor, se utiliza su método estático <code>create</code> para crear un objeto, que se agrega a <code>startActors</code>, y la función de mapeo devuelve <code>\"empty\"</code> para este cuadro de fondo."
              },
              {
                "type": "paragraph",
                "content": "La posición del actor se almacena como un objeto <code>Vec</code>. Este es un vector bidimensional, un objeto con propiedades <code>x</code> e <code>y</code>, como se ve en los ejercicios del Capítulo 6."
              }
            ]
          },
          {
            "id": "ch16-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "A medida que el juego avanza, los actores terminarán en lugares diferentes o incluso desaparecerán por completo (como hacen las monedas cuando se recogen). Utilizaremos una clase <code>State</code> para seguir el estado de un juego en ejecución."
              },
              {
                "type": "paragraph",
                "content": "La propiedad <code>status</code> cambiará a <code>\"lost\"</code> o <code>\"won\"</code> cuando el juego haya terminado."
              },
              {
                "type": "paragraph",
                "content": "Este es nuevamente una estructura de datos persistente: actualizar el estado del juego crea un nuevo estado y deja intacto el anterior."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch16-l5",
        "title": "Actores",
        "sections": [
          {
            "id": "ch16-l5-s0",
            "title": "Actores",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos de actores representan la posición actual y el estado de un elemento móvil dado en nuestro juego. Todos los objetos de actores se ajustan a la misma interfaz. Tienen las propiedades <code>size</code> y <code>pos</code> que contienen el tamaño y las coordenadas de la esquina superior izquierda del rectángulo que representa a este actor."
              },
              {
                "type": "paragraph",
                "content": "Luego tienen un método <code>update</code>, que se utiliza para calcular su nuevo estado y posición después de un paso de tiempo dado. Simula la acción que realiza el actor: moverse en respuesta a las teclas de flecha para el jugador y rebotar de un lado a otro para la lava, y devuelve un nuevo objeto de actor actualizado."
              },
              {
                "type": "paragraph",
                "content": "Una propiedad <code>type</code> contiene una cadena que identifica el tipo de actor: <code>\"player\"</code>, <code>\"coin\"</code> o <code>\"lava\"</code>. Esto es útil al dibujar el juego: la apariencia del rectángulo dibujado para un actor se basa en su tipo."
              }
            ]
          },
          {
            "id": "ch16-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las clases de actores tienen un método estático <code>create</code> que es utilizado por el constructor <code>Level</code> para crear un actor a partir de un carácter en el plan de nivel. Recibe las coordenadas del carácter y el carácter en sí, que es necesario porque la clase <code>Lava</code> maneja varios caracteres diferentes."
              },
              {
                "type": "paragraph",
                "content": "Esta es la clase <code>Vec</code> que usaremos para nuestros valores bidimensionales, como la posición y tamaño de los actores."
              },
              {
                "type": "paragraph",
                "content": "El método <code>times</code> escala un vector por un número dado. Será útil cuando necesitemos multiplicar un vector de velocidad por un intervalo de tiempo para obtener la distancia recorrida durante ese tiempo."
              }
            ]
          },
          {
            "id": "ch16-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los diferentes tipos de actores tienen sus propias clases debido a que su comportamiento es muy diferente. Definamos estas clases. Llegaremos a sus métodos <code>update</code> más adelante."
              },
              {
                "type": "paragraph",
                "content": "La clase <code>Player</code> tiene una propiedad <code>speed</code> que almacena su velocidad actual para simular el impulso y la gravedad."
              },
              {
                "type": "paragraph",
                "content": "Dado que un jugador tiene una altura de un cuadro y medio, su posición inicial se establece medio cuadro por encima de la posición donde apareció el carácter <code>@</code>. De esta manera, su parte inferior se alinea con la parte inferior del cuadro en el que apareció."
              }
            ]
          },
          {
            "id": "ch16-l5-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad <code>size</code> es la misma para todas las instancias de <code>Player</code>, por lo que la almacenamos en el prototipo en lugar de en las propias instancias. Podríamos haber utilizado un getter como <code>type</code>, pero eso crearía y devolvería un nuevo objeto <code>Vec</code> cada vez que se lee la propiedad, lo cual sería derrochador. (Las cadenas, al ser inmutables, no tienen que ser recreadas cada vez que se evalúan)."
              },
              {
                "type": "paragraph",
                "content": "Al construir un actor <code>Lava</code>, necesitamos inicializar el objeto de manera diferente dependiendo del personaje en el que se base. La lava dinámica se mueve a lo largo de su velocidad actual hasta que choca con un obstáculo. En ese momento, si tiene una propiedad de <code>reset</code>, saltará de nuevo a su posición de inicio (goteando). Si no la tiene, invertirá su velocidad y continuará en la otra dirección (rebotando)."
              },
              {
                "type": "paragraph",
                "content": "El método <code>create</code> mira el carácter que pasa el constructor de <code>Level</code> y crea el actor de lava apropiado."
              }
            ]
          },
          {
            "id": "ch16-l5-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los actores <code>Coin</code> son relativamente simples. Mayoritariamente solo se quedan en su lugar. Pero para animar un poco el juego, se les da un “balanceo”, un ligero movimiento vertical de ida y vuelta. Para hacer un seguimiento de esto, un objeto moneda almacena una posición base y también una propiedad de <code>wobble</code> que sigue la fase del movimiento de balanceo. Juntos, estos determinan la posición real de la moneda (almacenada en la propiedad <code>pos</code>)."
              },
              {
                "type": "paragraph",
                "content": "En Capítulo 14, vimos que <code>Math.sin</code> nos da la coordenada y de un punto en un círculo. Esa coordenada va de ida y vuelta en una forma de onda suave a medida que nos movemos a lo largo del círculo, lo que hace que la función seno sea útil para modelar un movimiento ondulado."
              },
              {
                "type": "paragraph",
                "content": "Para evitar una situación en la que todas las monedas se mueven hacia arriba y hacia abajo sincrónicamente, la fase inicial de cada moneda se aleatoriza. El periodo de la onda de <code>Math.sin</code>, el ancho de una onda que produce, es 2π. Multiplicamos el valor devuelto por <code>Math.random</code> por ese número para darle a la moneda una posición inicial aleatoria en la onda."
              }
            ]
          },
          {
            "id": "ch16-l5-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora podemos definir el objeto <code>levelChars</code> que mapea caracteres del plano a tipos de cuadrícula de fondo o clases de actor."
              },
              {
                "type": "paragraph",
                "content": "Esto nos brinda todas las partes necesarias para crear una instancia de <code>Level</code>."
              },
              {
                "type": "paragraph",
                "content": "La tarea por delante es mostrar esos niveles en pantalla y modelar el tiempo y movimiento dentro de ellos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      },
      {
        "id": "ch16-l6",
        "title": "Dibujo",
        "sections": [
          {
            "id": "ch16-l6-s0",
            "title": "Dibujo",
            "content": [
              {
                "type": "paragraph",
                "content": "En el próximo capítulo, mostraremos el mismo juego de una manera diferente. Para hacerlo posible, colocamos la lógica de dibujo detrás de una interfaz y la pasamos al juego como argumento. De esta manera, podemos usar el mismo programa de juego con diferentes nuevos módulos de visualización."
              },
              {
                "type": "paragraph",
                "content": "Un objeto de visualización de juego dibuja un nivel y estado dados. Pasamos su constructor al juego para permitir que sea reemplazado. La clase de visualización que definimos en este capítulo se llama <code>DOMDisplay</code> porque utiliza elementos del DOM para mostrar el nivel."
              },
              {
                "type": "paragraph",
                "content": "Utilizaremos una hoja de estilo para establecer los colores reales y otras propiedades fijas de los elementos que conforman el juego. También sería posible asignar directamente a la propiedad <code>style</code> de los elementos al crearlos, pero eso produciría programas más verbosos."
              }
            ]
          },
          {
            "id": "ch16-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La siguiente función auxiliar proporciona una forma concisa de crear un elemento y darle algunos atributos y nodos secundarios:"
              },
              {
                "type": "paragraph",
                "content": "Una visualización se crea dándole un elemento padre al que debe adjuntarse y un objeto de nivel."
              },
              {
                "type": "paragraph",
                "content": "La cuadrícula de fondo del nivel, que nunca cambia, se dibuja una vez. Los actores se vuelven a dibujar cada vez que se actualiza la visualización con un estado dado. La propiedad <code>actorLayer</code> se utilizará para realizar un seguimiento del elemento que contiene a los actores para que puedan ser fácilmente eliminados y reemplazados."
              }
            ]
          },
          {
            "id": "ch16-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Nuestras coordenadas y tamaños se rastrean en unidades de cuadrícula, donde un tamaño o distancia de 1 significa un bloque de cuadrícula. Al establecer tamaños de píxeles, tendremos que escalar estas coordenadas: todo en el juego sería ridículamente pequeño con un solo píxel por cuadrado. La constante <code>scale</code> indica el número de píxeles que una unidad ocupa en la pantalla."
              },
              {
                "type": "paragraph",
                "content": "El elemento <code>&lt;table&gt;</code> se corresponde bien con la estructura de la propiedad <code>rows</code> del nivel: cada fila de la cuadrícula se convierte en una fila de tabla (<code>&lt;tr&gt;</code>). Las cadenas en la cuadrícula se usan como nombres de clase para los elementos de celda de tabla (<code>&lt;td&gt;</code>). El código utiliza el operador de propagación (triple punto) para pasar matrices de nodos secundarios a <code>elt</code> como argumentos separados.El siguiente CSS hace que la tabla se vea como el fondo que queremos:"
              },
              {
                "type": "paragraph",
                "content": "Algunos de estos (<code>table-layout</code>, <code>border-spacing</code> y <code>padding</code>) se utilizan para suprimir comportamientos predeterminados no deseados. No queremos que el diseño de la tabla dependa del contenido de sus celdas, ni queremos espacio entre las celdas de la tabla o relleno dentro de ellas."
              }
            ]
          },
          {
            "id": "ch16-l6-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La regla <code>background</code> establece el color de fondo. CSS permite que los colores se especifiquen tanto como palabras (<code>white</code>) como con un formato como <code>rgb(R, G, B)</code>, donde los componentes rojo, verde y azul del color se separan en tres números de 0 a 255. Por lo tanto, en <code>rgb(52, 166, 251)</code>, el componente rojo es 52, el verde es 166 y el azul es 251. Dado que el componente azul es el más grande, el color resultante será azulado. En la regla <code>.lava</code>, el primer número (rojo) es el más grande."
              },
              {
                "type": "paragraph",
                "content": "Dibujamos cada actor creando un elemento DOM para él y estableciendo la posición y el tamaño de ese elemento en función de las propiedades del actor. Los valores tienen que ser multiplicados por <code>scale</code> para pasar de unidades de juego a píxeles."
              },
              {
                "type": "paragraph",
                "content": "Para agregar más de una clase a un elemento, separamos los nombres de las clases por espacios. En el siguiente código CSS mostrado a continuación, la clase <code>actor</code> da a los actores su posición absoluta. El nombre de su tipo se utiliza como una clase adicional para darles un color. No tenemos que definir la clase <code>lava</code> de nuevo porque estamos reutilizando la clase para las casillas de lava de la cuadrícula que definimos anteriormente."
              }
            ]
          },
          {
            "id": "ch16-l6-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>syncState</code> se utiliza para que la pantalla muestre un estado dado. Primero elimina los gráficos de actores antiguos, si los hay, y luego vuelve a dibujar los actores en sus nuevas posiciones. Puede ser tentador intentar reutilizar los elementos DOM para actores, pero para que eso funcione, necesitaríamos mucho más trabajo adicional para asociar actores con elementos DOM y asegurarnos de que eliminamos elementos cuando sus actores desaparecen. Dado que típicamente habrá solo un puñado de actores en el juego, volver a dibujar todos ellos no es costoso."
              },
              {
                "type": "paragraph",
                "content": "Al agregar el estado actual del nivel como nombre de clase al contenedor, podemos estilizar ligeramente al actor del jugador cuando el juego se gana o se pierde, añadiendo una regla CSS que tenga efecto solo cuando el jugador tiene un elemento ancestro con una clase específica."
              },
              {
                "type": "paragraph",
                "content": "Después de tocar la lava, el color del jugador se vuelve rojo oscuro, sugiriendo quemaduras. Cuando se ha recolectado la última moneda, agregamos dos sombras blancas difuminadas, una en la parte superior izquierda y otra en la parte superior derecha, para crear un efecto de halo blanco."
              }
            ]
          },
          {
            "id": "ch16-l6-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "No podemos asumir que el nivel siempre encaja en el <em>viewport</em> – el elemento en el que dibujamos el juego. Por eso es necesaria la llamada a <code>scrollPlayerIntoView</code>. Se asegura de que si el nivel sobresale del viewport, desplacemos ese viewport para asegurar que el jugador esté cerca de su centro. El siguiente CSS le da al elemento DOM contenedor del juego un tamaño máximo y asegura que cualquier cosa que sobresalga de la caja del elemento no sea visible. También le damos una posición relativa para que los actores dentro de él estén posicionados de manera relativa a la esquina superior izquierda del nivel."
              },
              {
                "type": "paragraph",
                "content": "En el método <code>scrollPlayerIntoView</code>, encontramos la posición del jugador y actualizamos la posición de desplazamiento del elemento contenedor. Cambiamos la posición de desplazamiento manipulando las propiedades <code>scrollLeft</code> y <code>scrollTop</code> de ese elemento cuando el jugador está demasiado cerca del borde."
              },
              {
                "type": "paragraph",
                "content": "La forma en que se encuentra el centro del jugador muestra cómo los métodos en nuestro tipo <code>Vec</code> permiten que los cálculos con objetos se escriban de una manera relativamente legible. Para encontrar el centro del actor, sumamos su posición (esquina superior izquierda) y la mitad de su tamaño. Ese es el centro en coordenadas de nivel, pero lo necesitamos en coordenadas de píxeles, así que luego multiplicamos el vector resultante por nuestra escala de visualización."
              }
            ]
          },
          {
            "id": "ch16-l6-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "A continuación, una serie de comprobaciones verifica que la posición del jugador no esté fuera del rango permitido. Ten en cuenta que a veces esto establecerá coordenadas de desplazamiento sin sentido que están por debajo de cero o más allá del área desplazable del elemento. Esto está bien, el DOM las limitará a valores aceptables. Establecer <code>scrollLeft</code> en -10 hará que se convierta en 0."
              },
              {
                "type": "paragraph",
                "content": "Hubiera sido un poco más sencillo intentar siempre desplazar al jugador al centro del viewport. Pero esto crea un efecto bastante brusco. Mientras saltas, la vista se desplazará constantemente hacia arriba y hacia abajo. Es más agradable tener un área “neutral” en el centro de la pantalla donde puedas moverte sin causar ningún desplazamiento."
              },
              {
                "type": "paragraph",
                "content": "Ahora podemos mostrar nuestro pequeño nivel."
              }
            ]
          },
          {
            "id": "ch16-l6-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La etiqueta <code>&lt;link&gt;</code>, cuando se utiliza con <code>rel=\"stylesheet\"</code>, es una forma de cargar un archivo CSS en una página. El archivo <code>game.css</code> contiene los estilos necesarios para nuestro juego."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 60
      },
      {
        "id": "ch16-l7",
        "title": "Movimiento y colisión",
        "sections": [
          {
            "id": "ch16-l7-s0",
            "title": "Movimiento y colisión",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora estamos en el punto en el que podemos comenzar a agregar movimiento. El enfoque básico, seguido por la mayoría de juegos como este, es dividir tiempo en pequeños pasos y, para cada paso, mover a los actores una distancia correspondiente a su velocidad multiplicada por el tamaño del paso de tiempo. Mediremos el tiempo en segundos, por lo que las velocidades se expresan en unidades por segundo."
              },
              {
                "type": "paragraph",
                "content": "Mover cosas es fácil. La parte difícil es lidiar con las interacciones entre los elementos. Cuando el jugador golpea una pared o el suelo, no debería simplemente atravesarlo. El juego debe notar cuando un movimiento dado hace que un objeto golpee a otro objeto y responder en consecuencia. Para las paredes, el movimiento debe detenerse. Al golpear una moneda, esa moneda debe ser recogida. Al tocar lava, el juego debería perderse."
              },
              {
                "type": "paragraph",
                "content": "Resolver esto para el caso general es una tarea grande. Puedes encontrar bibliotecas, generalmente llamadas <em>motores físicos</em>, que simulan la interacción entre objetos físicos en dos o tres dimensiones. Tomaremos un enfoque más modesto en este capítulo, manejando solo colisiones entre objetos rectangulares y manejándolas de una manera bastante simplista."
              }
            ]
          },
          {
            "id": "ch16-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Antes de mover al jugador o un bloque de lava, probamos si el movimiento los llevaría dentro de una pared. Si lo hace, simplemente cancelamos el movimiento por completo. La respuesta a tal colisión depende del tipo de actor. El jugador se detendrá, mientras que un bloque de lava rebotará."
              },
              {
                "type": "paragraph",
                "content": "Este enfoque requiere que nuestros pasos de tiempo sean bastante pequeños, ya que hará que el movimiento se detenga antes de que los objetos realmente se toquen. Si los pasos de tiempo (y por lo tanto los pasos de movimiento) son demasiado grandes, el jugador terminaría elevándose a una distancia notable sobre el suelo. Otro enfoque, argumentablemente mejor pero más complicado, sería encontrar el punto exacto de colisión y moverse allí. Tomaremos el enfoque simple y ocultaremos sus problemas asegurando que la animación avance en pasos pequeños."
              },
              {
                "type": "paragraph",
                "content": "Este método nos indica si un rectángulo (especificado por una posición y un tamaño) toca un elemento de rejilla de un tipo dado."
              }
            ]
          },
          {
            "id": "ch16-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método calcula el conjunto de cuadrados de rejilla con los que el cuerpo se superpone utilizando <code>Math.floor</code> y <code>Math.ceil</code> en sus coordenadas. Recuerda que los cuadrados de la rejilla son de tamaño 1 por 1 unidad. Al redondear los lados de un cuadro hacia arriba y hacia abajo, obtenemos el rango de cuadrados de fondo que el cuadro toca."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Un juego de plataformas __ Eloquent JavaScript_files/game-grid.svg",
                "alt": "Diagrama que muestra una rejilla con un cuadro negro superpuesto. Todos los cuadrados de la rejilla que están parcialmente cubiertos por el bloque están marcados."
              },
              {
                "type": "paragraph",
                "content": "Recorremos el bloque de cuadrados de rejilla encontrado al redondear las coordenadas y devolvemos <code>true</code> cuando se encuentra un cuadro coincidente. Los cuadrados fuera del nivel siempre se tratan como <code>\"wall\"</code> para asegurar que el jugador no pueda salir del mundo y que no intentemos leer fuera de los límites de nuestra matriz <code>rows</code>."
              }
            ]
          },
          {
            "id": "ch16-l7-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>update</code> de estado utiliza <code>touches</code> para determinar si el jugador está tocando lava."
              },
              {
                "type": "paragraph",
                "content": "El método recibe un paso de tiempo y una estructura de datos que le indica qué teclas se mantienen presionadas. Lo primero que hace es llamar al método <code>update</code> en todos los actores, produciendo un array de actores actualizados. Los actores también reciben el paso de tiempo, las teclas y el estado, para que puedan basar su actualización en esos valores. Solo el jugador realmente lee las teclas, ya que es el único actor controlado por el teclado."
              },
              {
                "type": "paragraph",
                "content": "Si el juego ya ha terminado, no es necesario realizar más procesamiento (no se puede ganar el juego después de haber perdido, o viceversa). De lo contrario, el método prueba si el jugador está tocando lava de fondo. Si es así, se pierde el juego y hemos terminado. Finalmente, si el juego sigue en curso, verifica si algún otro actor se superpone al jugador.La superposición entre actores se detecta con la función <code>overlap</code>. Toma dos objetos actor y devuelve true cuando se tocan, lo cual sucede cuando se superponen tanto a lo largo del eje x como a lo largo del eje y."
              }
            ]
          },
          {
            "id": "ch16-l7-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si algún actor se superpone, su método <code>collide</code> tiene la oportunidad de actualizar el estado. Tocar un actor de lava establece el estado del juego en <code>\"lost\"</code>. Las monedas desaparecen cuando las tocas y establecen el estado en <code>\"won\"</code> cuando son la última moneda del nivel."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch16-l8",
        "title": "Actualizaciones de actores",
        "sections": [
          {
            "id": "ch16-l8-s0",
            "title": "Actualizaciones de actores",
            "content": [
              {
                "type": "paragraph",
                "content": "Los métodos <code>update</code> de los objetos actor toman como argumentos el paso de tiempo, el objeto de estado y un objeto <code>keys</code>. El de tipo actor <code>Lava</code> ignora el objeto <code>keys</code>."
              },
              {
                "type": "paragraph",
                "content": "Este método <code>update</code> calcula una nueva posición agregando el producto del paso de tiempo y la velocidad actual a su posición anterior. Si no hay obstáculos que bloqueen esa nueva posición, se mueve allí. Si hay un obstáculo, el comportamiento depende del tipo de bloque de lava—la lava goteante tiene una posición de <code>reset</code> a la que regresa cuando golpea algo. La lava rebotante invierte su velocidad multiplicándola por -1 para que comience a moverse en la dirección opuesta."
              },
              {
                "type": "paragraph",
                "content": "Las monedas utilizan su método <code>update</code> para balancearse. Ignoran las colisiones con la cuadrícula ya que simplemente se balancean dentro de su propio cuadrado."
              }
            ]
          },
          {
            "id": "ch16-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad <code>wobble</code> se incrementa para hacer un seguimiento del tiempo y luego se utiliza como argumento para <code>Math.sin</code> para encontrar la nueva posición en la onda. La posición actual de la moneda se calcula a partir de su posición base y un desplazamiento basado en esta onda."
              },
              {
                "type": "paragraph",
                "content": "Eso deja al jugador en sí. El movimiento del jugador se maneja por separado por eje porque golpear el suelo no debería impedir el movimiento horizontal, y golpear una pared no debería detener el movimiento de caída o de salto."
              },
              {
                "type": "paragraph",
                "content": "El movimiento horizontal se calcula en función del estado de las teclas de flecha izquierda y derecha. Cuando no hay una pared bloqueando la nueva posición creada por este movimiento, se utiliza. De lo contrario, se mantiene la posición anterior."
              }
            ]
          },
          {
            "id": "ch16-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El movimiento vertical funciona de manera similar pero tiene que simular saltos y gravedad. La velocidad vertical del jugador (<code>ySpeed</code>) se acelera primero para tener en cuenta la gravedad."
              },
              {
                "type": "paragraph",
                "content": "Comprobamos las paredes nuevamente. Si no golpeamos ninguna, se usa la nueva posición. Si <em>hay</em> una pared, hay dos posibles resultados. Cuando se presiona la flecha hacia arriba <em>y</em> estamos bajando (lo que significa que lo que golpeamos está debajo de nosotros), la velocidad se establece en un valor negativo relativamente grande. Esto hace que el jugador salte. Si ese no es el caso, el jugador simplemente chocó con algo y la velocidad se establece en cero."
              },
              {
                "type": "paragraph",
                "content": "La fuerza de la gravedad, la velocidad de salto y otras constantes en el juego se determinaron simplemente probando algunos números y viendo cuáles se sentían correctos. Puedes experimentar con ellos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch16-l9",
        "title": "Seguimiento de teclas",
        "sections": [
          {
            "id": "ch16-l9-s0",
            "title": "Seguimiento de teclas",
            "content": [
              {
                "type": "paragraph",
                "content": "Para un juego como este, no queremos que las teclas tengan efecto una vez por pulsación de tecla. Más bien, queremos que su efecto (mover la figura del jugador) se mantenga activo mientras se mantienen presionadas."
              },
              {
                "type": "paragraph",
                "content": "Necesitamos configurar un controlador de teclas que almacene el estado actual de las teclas de flecha izquierda, derecha y arriba. También queremos llamar a <code>preventDefault</code> para esas teclas para que no terminen desplazando la página."
              },
              {
                "type": "paragraph",
                "content": "La siguiente función, al darle un array de nombres de teclas, devolverá un objeto que sigue la posición actual de esas teclas. Registra controladores de eventos para eventos <code>\"keydown\"</code> y <code>\"keyup\"</code> y, cuando el código de tecla en el evento está presente en el conjunto de códigos que está siguiendo, actualiza el objeto."
              }
            ]
          },
          {
            "id": "ch16-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La misma función manejadora se utiliza para ambos tipos de eventos. Esta función examina la propiedad <code>type</code> del objeto de evento para determinar si el estado de la tecla debe actualizarse a verdadero (<code>\"keydown\"</code>) o falso (<code>\"keyup\"</code>)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch16-l10",
        "title": "Ejecutando el juego",
        "sections": [
          {
            "id": "ch16-l10-s0",
            "title": "Ejecutando el juego",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>requestAnimationFrame</code>, que vimos en el Capítulo 14, proporciona una buena forma de animar un juego. Pero su interfaz es bastante primitiva, ya que su uso requiere que llevemos un registro del momento en que se llamó a nuestra función la última vez y llamemos a <code>requestAnimationFrame</code> nuevamente después de cada fotograma."
              },
              {
                "type": "paragraph",
                "content": "Vamos a definir una función auxiliar que envuelva todo eso en una interfaz conveniente y nos permita simplemente llamar a <code>runAnimation</code>, dándole una función que espera una diferencia de tiempo como argumento y dibuja un solo fotograma. Cuando la función de fotograma devuelve el valor <code>false</code>, la animación se detiene."
              },
              {
                "type": "paragraph",
                "content": "He establecido un paso de fotograma máximo de 100 milisegundos (una décima parte de un segundo). Cuando la pestaña del navegador o la ventana con nuestra página está oculta, las llamadas a <code>requestAnimationFrame</code> se suspenden hasta que la pestaña o la ventana se vuelva a mostrar. En este caso, la diferencia entre <code>lastTime</code> y <code>time</code> será todo el tiempo en el que la página estuvo oculta. Avanzar el juego tanto en un solo paso se vería ridículo y podría causar efectos secundarios extraños, como que el jugador caiga a través del suelo."
              }
            ]
          },
          {
            "id": "ch16-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función también convierte los pasos de tiempo a segundos, que son una cantidad más fácil de entender que los milisegundos."
              },
              {
                "type": "paragraph",
                "content": "La función <code>runLevel</code> toma un objeto <code>Level</code> y un constructor de display y devuelve una promesa. Muestra el nivel (en <code>document.body</code>) y permite al usuario jugar a través de él. Cuando el nivel termina (perdido o ganado), <code>runLevel</code> espera un segundo más (para que el usuario vea qué sucede), luego borra la pantalla, detiene la animación y resuelve la promesa con el estado final del juego."
              },
              {
                "type": "paragraph",
                "content": "Un juego es una secuencia de niveles. Cada vez que el jugador muere, el nivel actual se reinicia. Cuando se completa un nivel, pasamos al siguiente nivel. Esto se puede expresar mediante la siguiente función, que toma un array de planes de nivel (cadenas) y un constructor de display:"
              }
            ]
          },
          {
            "id": "ch16-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Debido a que hicimos que <code>runLevel</code> devuelva una promesa, <code>runGame</code> puede escribirse utilizando una función <code>async</code>, como se muestra en el Capítulo 11. Devuelve otra promesa, que se resuelve cuando el jugador termina el juego."
              },
              {
                "type": "paragraph",
                "content": "Hay un conjunto de planes de niveles disponibles en el enlace <code>GAME_LEVELS</code> en el sandbox de este capítulo. Esta página los alimenta a <code>runGame</code>, comenzando un juego real."
              },
              {
                "type": "paragraph",
                "content": "Intenta vencerlos. Me divertí construyéndolos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch16-l11",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch16-l11-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Es tradicional que los juegos de plataformas hagan que el jugador comience con un número limitado de <em>vidas</em> y resten una vida cada vez que mueren. Cuando el jugador se queda sin vidas, el juego se reinicia desde el principio."
              },
              {
                "type": "paragraph",
                "content": "Ajusta <code>runGame</code> para implementar vidas. Haz que el jugador comience con tres vidas. Muestra el número actual de vidas (usando <code>console.log</code>) cada vez que comienza un nivel."
              },
              {
                "type": "paragraph",
                "content": "Haz posible pausar y despausar el juego presionando la tecla Esc."
              }
            ]
          },
          {
            "id": "ch16-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esto se puede hacer cambiando la función <code>runLevel</code> para configurar un manejador de eventos de teclado que interrumpa o reanude la animación cada vez que se presiona la tecla Esc."
              },
              {
                "type": "paragraph",
                "content": "La interfaz de <code>runAnimation</code> puede no parecer adecuada para esto a primera vista, pero lo es si reorganizas la forma en que <code>runLevel</code> la llama."
              },
              {
                "type": "paragraph",
                "content": "Cuando tengas eso funcionando, hay algo más que podrías intentar. La forma en que hemos estado registrando los controladores de eventos de teclado es algo problemática. El objeto <code>arrowKeys</code> es actualmente una asignación global, y sus controladores de eventos se mantienen incluso cuando no hay ningún juego en ejecución. Podrías decir que <em>escapan</em> de nuestro sistema. Amplía <code>trackKeys</code> para proporcionar una forma de anular el registro de sus controladores y luego cambia <code>runLevel</code> para registrar sus controladores cuando comienza y desregistrarlos nuevamente cuando termine."
              }
            ]
          },
          {
            "id": "ch16-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una animación puede ser interrumpida devolviendo <code>false</code> desde la función dada a <code>runAnimation</code>. Puede ser continuada llamando a <code>runAnimation</code> nuevamente."
              },
              {
                "type": "paragraph",
                "content": "Así que necesitamos comunicar el hecho de que estamos pausando el juego a la función dada a <code>runAnimation</code>. Para eso, puedes usar una asignación a la que tanto el controlador de eventos como esa función tengan acceso."
              },
              {
                "type": "paragraph",
                "content": "Al encontrar una forma de anular los controladores registrados por <code>trackKeys</code>, recuerda que el valor de función <em>exactamente</em> igual que se pasó a <code>addEventListener</code> debe pasarse a <code>removeEventListener</code> para quitar con éxito un controlador. Por lo tanto, el valor de función <code>handler</code> creado en <code>trackKeys</code> debe estar disponible para el código que anula los controladores."
              }
            ]
          },
          {
            "id": "ch16-l11-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes agregar una propiedad al objeto devuelto por <code>trackKeys</code>, que contenga ese valor de función o un método que maneje la anulación directamente."
              },
              {
                "type": "paragraph",
                "content": "Es tradicional que los juegos de plataformas tengan enemigos a los que puedes saltar encima para derrotar. Este ejercicio te pide que agregues un tipo de actor así al juego."
              },
              {
                "type": "paragraph",
                "content": "Lo llamaremos monstruo. Los monstruos se mueven solo horizontalmente. Puedes hacer que se muevan en la dirección del jugador, que reboten de un lado a otro como lava horizontal, o tengan cualquier patrón de movimiento que desees. La clase no tiene que manejar caídas, pero debe asegurarse de que el monstruo no atraviese paredes."
              }
            ]
          },
          {
            "id": "ch16-l11-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando un monstruo toca al jugador, el efecto depende de si el jugador está saltando encima de ellos o no. Puedes aproximarlo comprobando si el final del jugador está cerca de la parte superior del monstruo. Si este es el caso, el monstruo desaparece. Si no, el juego se pierde."
              },
              {
                "type": "paragraph",
                "content": "Si deseas implementar un tipo de movimiento que sea mutable, como el rebote, asegúrate de almacenar el estado necesario en el objeto del actor, inclúyelo como argumento del constructor y agrégalo como propiedad."
              },
              {
                "type": "paragraph",
                "content": "Recuerda que <code>update</code> devuelve un <em>nuevo</em> objeto en lugar de cambiar el anterior."
              }
            ]
          },
          {
            "id": "ch16-l11-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al manejar la colisión, encuentra al jugador en <code>state.actors</code> y compara su posición con la posición del monstruo. Para obtener la <em>parte inferior</em> del jugador, debes sumar su tamaño vertical a su posición vertical. La creación de un estado actualizado se parecerá al método <code>collide</code> de <code>Coin</code> (eliminando al actor) o a <code>Lava</code> (cambiando el estado a <code>\"lost\"</code>), dependiendo de la posición del jugador."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 50
      }
    ]
  },
  {
    "id": "ch17",
    "number": 17,
    "title": "Dibujando en Canvas",
    "titleEs": "Dibujando en Canvas",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "Dibujar es engañar....",
    "isProject": false,
    "totalXP": 545,
    "lessons": [
      {
        "id": "ch17-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch17-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Dibujar es engañar. M.C. Escher, citado por Bruno Ernst en El Espejo Mágico de M.C. Escher"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Dibujando en Canvas __ Eloquent JavaScript_files/chapter_picture_17.jpg",
                "alt": "Ilustración que muestra un brazo robótico con aspecto industrial dibujando una ciudad en un trozo de papel"
              },
              {
                "type": "paragraph",
                "content": "Los navegadores nos ofrecen varias formas de mostrar gráficos. La forma más simple es usar estilos para posicionar y colorear elementos DOM regulares. Esto puede llevarnos bastante lejos, como mostró el juego en el capítulo anterior. Al agregar imágenes de fondo parcialmente transparentes a los nodos, podemos hacer que se vean exactamente como queremos. Incluso es posible rotar o sesgar nodos con el estilo <code>transform</code>."
              }
            ]
          },
          {
            "id": "ch17-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero estaríamos utilizando el DOM para algo para lo que no fue diseñado originalmente. Algunas tareas, como dibujar una línea entre puntos arbitrarios, son extremadamente incómodas de hacer con elementos HTML regulares."
              },
              {
                "type": "paragraph",
                "content": "Hay dos alternativas. La primera es basada en el DOM pero utiliza <em>Gráficos Vectoriales Escalables</em> (SVG), en lugar de HTML. Piensa en SVG como un dialecto de marcado de documento que se centra en las formas en lugar de en el texto. Puedes incrustar un documento SVG directamente en un documento HTML o incluirlo con una etiqueta <code>&lt;img&gt;</code>."
              },
              {
                "type": "paragraph",
                "content": "La segunda alternativa se llama <em>lienzo</em>. Un lienzo es un solo elemento DOM que encapsula una imagen. Proporciona una interfaz de programación para dibujar formas en el espacio ocupado por el nodo. La principal diferencia entre un lienzo y una imagen SVG es que en SVG se conserva la descripción original de las formas para que puedan moverse o redimensionarse en cualquier momento. Un lienzo, por otro lado, convierte las formas en píxels (puntos de color en una cuadrícula) en cuanto se dibujan y no recuerda qué representan estos píxeles. La única forma de mover una forma en un lienzo es borrar el lienzo (o la parte del lienzo alrededor de la forma) y volver a dibujarlo con la forma en una nueva posición."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch17-l1",
        "title": "SVG",
        "sections": [
          {
            "id": "ch17-l1-s0",
            "title": "SVG",
            "content": [
              {
                "type": "paragraph",
                "content": "Este libro no se adentrará en detalles sobre SVG, pero explicaré brevemente cómo funciona. Al final del capítulo, volveré a los compromisos que debes considerar al decidir qué mecanismo de dibujo es adecuado para una aplicación determinada."
              },
              {
                "type": "paragraph",
                "content": "Este es un documento HTML con una sencilla imagen SVG en él:"
              },
              {
                "type": "paragraph",
                "content": "Estas etiquetas crean elementos del DOM, al igual que las etiquetas HTML, con las que los scripts pueden interactuar. Por ejemplo, esto cambia el elemento <code>&lt;circle&gt;</code> para que se coloree de cian:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch17-l2",
        "title": "El elemento canvas",
        "sections": [
          {
            "id": "ch17-l2-s0",
            "title": "El elemento canvas",
            "content": [
              {
                "type": "paragraph",
                "content": "Los gráficos en lienzo pueden ser dibujados en un elemento <code>&lt;canvas&gt;</code>. Puedes darle a dicho elemento atributos <code>width</code> y <code>height</code> para determinar su tamaño en píxels."
              },
              {
                "type": "paragraph",
                "content": "Un lienzo nuevo está vacío, lo que significa que es completamente transparente y por lo tanto se muestra como espacio vacío en el documento."
              },
              {
                "type": "paragraph",
                "content": "La etiqueta <code>&lt;canvas&gt;</code> está destinada a permitir diferentes estilos de dibujo. Para acceder a una interfaz de dibujo real, primero necesitamos crear un <em>contexto</em>, un objeto cuyos métodos proporcionan la interfaz de dibujo. Actualmente existen tres estilos de dibujo ampliamente compatibles: <code>\"2d\"</code> para gráficos bidimensionales, <code>\"webgl\"</code> para gráficos tridimensionales a través de la interfaz OpenGL, y <code>\"webgpu\"</code>, una alternativa más moderna y flexible a WebGL."
              }
            ]
          },
          {
            "id": "ch17-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este libro no discutirá WebGL ni WebGPU—nos mantendremos en dos dimensiones. Pero si estás interesado en gráficos tridimensionales, te animo a investigar sobre WebGPU. Proporciona una interfaz directa al hardware gráfico y te permite renderizar escenas incluso complicadas de manera eficiente, utilizando JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Creas un contexto con el método <code>getContext</code> en el elemento DOM <code>&lt;canvas&gt;</code>."
              },
              {
                "type": "paragraph",
                "content": "Después de crear el objeto de contexto, el ejemplo dibuja un rectángulo rojo de 100 píxeles de ancho y 50 píxeles de alto, con su esquina superior izquierda en las coordenadas (10,10)."
              }
            ]
          },
          {
            "id": "ch17-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al igual que en HTML (y SVG), el sistema de coordenadas que utiliza el lienzo sitúa el (0,0) en la esquina superior izquierda, y el eje y-positivo va hacia abajo desde allí. Por lo tanto, (10,10) está 10 píxeles abajo y a la derecha de la esquina superior izquierda."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch17-l3",
        "title": "Líneas y superficies",
        "sections": [
          {
            "id": "ch17-l3-s0",
            "title": "Líneas y superficies",
            "content": [
              {
                "type": "paragraph",
                "content": "En la interfaz de lienzo, una forma puede ser <em>rellenada</em>, lo que significa que su área recibe un color o patrón determinado, o puede ser <em>trazada</em>, lo que significa que se dibuja una línea a lo largo de su borde. La misma terminología se utiliza en SVG."
              },
              {
                "type": "paragraph",
                "content": "El método <code>fillRect</code> rellena un rectángulo. Primero toma las coordenadas x e y de la esquina superior izquierda del rectángulo, luego su ancho y finalmente su altura. Un método similar llamado <code>strokeRect</code> dibuja el contorno de un rectángulo."
              },
              {
                "type": "paragraph",
                "content": "Ninguno de los métodos toma más parámetros. El color del relleno, el grosor del trazo, y demás, no son determinados por un argumento del método, como podrías esperar razonablemente, sino por propiedades del objeto contexto."
              }
            ]
          },
          {
            "id": "ch17-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad <code>fillStyle</code> controla la forma en que se rellenan las formas. Puede establecerse como una cadena que especifica un color, utilizando la notación de color utilizada por CSS."
              },
              {
                "type": "paragraph",
                "content": "La propiedad <code>strokeStyle</code> funciona de manera similar, pero determina el color utilizado para una línea contorneada. El ancho de esa línea se determina mediante la propiedad <code>lineWidth</code>, que puede contener cualquier número positivo."
              },
              {
                "type": "paragraph",
                "content": "Cuando no se especifica ningún atributo <code>width</code> o <code>height</code>, como en el ejemplo, un elemento canvas obtiene un ancho predeterminado de 300 píxeles y una altura de 150 píxeles."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch17-l4",
        "title": "Caminos",
        "sections": [
          {
            "id": "ch17-l4-s0",
            "title": "Caminos",
            "content": [
              {
                "type": "paragraph",
                "content": "Un camino es una secuencia de líneas. La interfaz del canvas 2D toma un enfoque peculiar para describir un camino. Se realiza completamente a través de efecto secundarios. Los caminos no son valores que se puedan almacenar y pasar. En su lugar, si deseas hacer algo con un camino, haces una secuencia de llamadas a métodos para describir su forma."
              },
              {
                "type": "paragraph",
                "content": "Este ejemplo crea un camino con varios segmentos horizontales de línea y luego lo traza usando el método <code>stroke</code>. Cada segmento creado con <code>lineTo</code> comienza en la posición <em>actual</em> del camino. Esa posición suele ser el final del último segmento, a menos que se haya llamado a <code>moveTo</code>. En ese caso, el siguiente segmento comenzaría en la posición pasada a <code>moveTo</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando se rellena un camino (usando el método <code>fill</code>), cada forma se llena por separado. Un camino puede contener múltiples formas—cada movimiento de <code>moveTo</code> inicia una nueva forma. Pero el camino necesita estar <em>cerrado</em> (significando que su inicio y final están en la misma posición) antes de poder ser rellenado. Si el camino aún no está cerrado, se agrega una línea desde su final hasta su inicio, y se rellena la forma encerrada por el camino completado."
              }
            ]
          },
          {
            "id": "ch17-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este ejemplo dibuja un triángulo relleno. Ten en cuenta que solo se dibujan explícitamente dos de los lados del triángulo. El tercero, desde la esquina inferior derecha de regreso a la parte superior, se da por implícito y no estaría allí cuando se traze el recorrido."
              },
              {
                "type": "paragraph",
                "content": "También puedes usar el método <code>closePath</code> para cerrar explícitamente un recorrido agregando un segmento real line de vuelta al inicio del recorrido. Este segmento <em>se</em> dibuja cuando se traza el recorrido."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch17-l5",
        "title": "Curvas",
        "sections": [
          {
            "id": "ch17-l5-s0",
            "title": "Curvas",
            "content": [
              {
                "type": "paragraph",
                "content": "Un recorrido también puede contener líneas curvadas. Lamentablemente, estas son un poco más complicadas de dibujar."
              },
              {
                "type": "paragraph",
                "content": "El método <code>quadraticCurveTo</code> dibuja una curva hacia un punto dado. Para determinar la curvatura de la línea, el método recibe un punto de control así como un punto de destino. Imagina este punto de control como <em>atrayendo</em> la línea, dándole su curva. La línea no pasará por el punto de control, pero su dirección en los puntos de inicio y fin será tal que una línea recta en esa dirección apuntaría hacia el punto de control. El siguiente ejemplo ilustra esto:"
              },
              {
                "type": "paragraph",
                "content": "Dibujamos una curva cuadrática de izquierda a derecha, con (60,10) como punto de control, y luego dibujamos dos segmentos line que pasan por ese punto de control y vuelven al inicio de la línea. El resultado se asemeja a un emblema de <em>Star Trek</em>. Puedes ver el efecto del punto de control: las líneas que salen de las esquinas inferiores comienzan en la dirección del punto de control y luego se curvan hacia su objetivo."
              }
            ]
          },
          {
            "id": "ch17-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>bezierCurveTo</code> dibuja un tipo de curva similar. En lugar de un único punto de control, este tiene dos—uno para cada uno de los extremos de la línea. Aquí hay un boceto similar para ilustrar el comportamiento de dicha curva:"
              },
              {
                "type": "paragraph",
                "content": "Los dos puntos de control especifican la dirección en ambos extremos de la curva. Cuanto más separados estén de su punto correspondiente, más la curva “abultará\" en esa dirección."
              },
              {
                "type": "paragraph",
                "content": "curves como estas pueden ser difíciles de trabajar, no siempre es claro cómo encontrar los control points que proporcionan la forma que estás buscando. A veces puedes calcularlos y a veces simplemente tendrás que encontrar un valor adecuado mediante prueba y error."
              }
            ]
          },
          {
            "id": "ch17-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>arc</code> es una forma de dibujar una línea que se curva a lo largo del borde de un círculo. Toma un par de coordenadas para el centro del arco, un radio, y luego un ángulo de inicio y un ángulo final."
              },
              {
                "type": "paragraph",
                "content": "Estos últimos dos parámetros permiten dibujar solo parte del círculo. Los ángulos se miden en radianes, no en grados. Esto significa que un círculo completo tiene un ángulo de 2π, o <code>2 * Math.PI</code>, que es aproximadamente 6.28. El ángulo comienza a contar en el punto a la derecha del centro del círculo y va en sentido horario desde allí. Puedes usar un inicio de 0 y un final mayor que 2π (por ejemplo, 7) para dibujar un círculo completo."
              },
              {
                "type": "paragraph",
                "content": "La imagen resultante contiene una línea desde la derecha del círculo completo (primer llamado a <code>arc</code>) hasta la derecha del cuarto del círculo (segundo llamado). Al igual que otros métodos de dibujo de trayectos, una línea dibujada con <code>arc</code> está conectada al segmento de trayecto anterior. Puedes llamar a <code>moveTo</code> o comenzar un nuevo trayecto para evitar esto."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch17-l6",
        "title": "Dibujo de un diagrama de sectores",
        "sections": [
          {
            "id": "ch17-l6-s0",
            "title": "Dibujo de un diagrama de sectores",
            "content": [
              {
                "type": "paragraph",
                "content": "Imagina que acabas de aceptar un trabajo en EconomiCorp, Inc., y tu primera tarea es dibujar un diagrama de sectores de los resultados de la encuesta de satisfacción de los clientes."
              },
              {
                "type": "paragraph",
                "content": "El enlace <code>results</code> contiene una matriz de objetos que representan las respuestas de la encuesta."
              },
              {
                "type": "paragraph",
                "content": "Para dibujar un diagrama de sectores, dibujamos una serie de sectores circulares, cada uno compuesto por un arco y un par de líneas hacia el centro de ese arco. Podemos calcular el ángulo ocupado por cada arco dividiendo un círculo completo (2π) por el número total de respuestas y luego multiplicando ese número (el ángulo por respuesta) por el número de personas que eligieron una opción determinada."
              }
            ]
          },
          {
            "id": "ch17-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero un gráfico que no nos dice qué significan las porciones no es muy útil. Necesitamos una forma de dibujar texto en el canvas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch17-l7",
        "title": "Texto",
        "sections": [
          {
            "id": "ch17-l7-s0",
            "title": "Texto",
            "content": [
              {
                "type": "paragraph",
                "content": "Un contexto de dibujo en lienzo 2D proporciona los métodos <code>fillText</code> y <code>strokeText</code>. Este último puede ser útil para contornear letras, pero generalmente <code>fillText</code> es lo que necesitas. Este llenará el contorno del texto dado con el <code>fillStyle</code> actual."
              },
              {
                "type": "paragraph",
                "content": "Puedes especificar el tamaño, estilo y fuente del texto con la propiedad <code>font</code>. Este ejemplo solo da un tamaño de fuente y un nombre de familia. También es posible agregar <code>italic</code> o <code>bold</code> al comienzo de la cadena para seleccionar un estilo."
              },
              {
                "type": "paragraph",
                "content": "Los dos últimos argumentos de <code>fillText</code> y <code>strokeText</code> proporcionan la posición en la que se dibuja la fuente. Por defecto, indican la posición del inicio de la línea alfabética del texto, que es la línea en la que las letras “se paran”, sin contar las partes colgantes en letras como la <em>j</em> o la <em>p</em>. Puedes cambiar la posición horizontal configurando la propiedad <code>textAlign</code> en <code>\"end\"</code> o <code>\"center\"</code> y la posición vertical configurando <code>textBaseline</code> en <code>\"top\"</code>, <code>\"middle\"</code> o <code>\"bottom\"</code>."
              }
            ]
          },
          {
            "id": "ch17-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Volveremos a nuestro gráfico circular y al problema de etiquetar las porciones, en los ejercicios al final del capítulo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch17-l8",
        "title": "Imágenes",
        "sections": [
          {
            "id": "ch17-l8-s0",
            "title": "Imágenes",
            "content": [
              {
                "type": "paragraph",
                "content": "En gráficos por computadora, a menudo se hace una distinción entre gráficos <em>vectoriales</em> y gráficos <em>de mapa de bits</em>. El primero es lo que hemos estado haciendo hasta ahora en este capítulo: especificar una imagen dando una descripción lógica de las formas. Los gráficos de mapa de bits, por otro lado, no especifican formas reales, sino que trabajan con datos de píxel (rasteros de puntos de colores)."
              },
              {
                "type": "paragraph",
                "content": "El método <code>drawImage</code> nos permite dibujar datos de píxel en un canvas. Estos datos de píxel pueden originarse desde un elemento <code>&lt;img&gt;</code> o desde otro lienzo. El siguiente ejemplo crea un elemento <code>&lt;img&gt;</code> independiente y carga un archivo de imagen en él. Pero no podemos comenzar a dibujar inmediatamente desde esta imagen porque es posible que el navegador aún no la haya cargado. Para manejar esto, registramos un controlador de eventos <code>\"load\"</code> y hacemos el dibujo después de que la imagen se haya cargado."
              },
              {
                "type": "paragraph",
                "content": "Por defecto, <code>drawImage</code> dibujará la imagen a su tamaño original. También se le pueden proporcionar dos argumentos adicionales para establecer un ancho y alto diferente."
              }
            ]
          },
          {
            "id": "ch17-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se utilizan <em>nueve</em> argumentos en <code>drawImage</code>, se puede usar para dibujar solo un fragmento de una imagen. Los argumentos segundo a quinto indican el rectángulo (x, y, ancho y alto) en la imagen de origen que se debería copiar, y los argumentos sexto a noveno indican el rectángulo (en el lienzo) en el cual se debería copiar."
              },
              {
                "type": "paragraph",
                "content": "Esto se puede utilizar para empaquetar varios <em>sprites</em> (elementos de imagen) en un único archivo de imagen y luego dibujar solo la parte que se necesita. Por ejemplo, tenemos esta imagen que contiene un personaje de juego en múltiples poses:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Dibujando en Canvas __ Eloquent JavaScript_files/player_big.png",
                "alt": "Arte de píxeles mostrando un personaje de videojuego en 10 poses diferentes. Las primeras 8 forman su ciclo de animación de carrera, la novena tiene al personaje parado, y la décima lo muestra saltando."
              },
              {
                "type": "paragraph",
                "content": "Alternando qué pose dibujamos, podemos mostrar una animación que parece un personaje caminando."
              }
            ]
          },
          {
            "id": "ch17-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para animar una imagen en un lienzo, el método <code>clearRect</code> es útil. Se asemeja a <code>fillRect</code>, pero en lugar de colorear el rectángulo, lo vuelve transparente, eliminando los píxeles dibujados anteriormente."
              },
              {
                "type": "paragraph",
                "content": "Sabemos que cada <em>sprite</em>, cada subimagen, tiene un ancho de 24 píxeles y una altura de 30 píxeles. El siguiente código carga la imagen y luego establece un intervalo (temporizador repetido) para dibujar el siguiente frame:"
              },
              {
                "type": "paragraph",
                "content": "El enlace <code>ciclo</code> sigue nuestra posición en la animación. En cada frame, se incrementa y luego se recorta de nuevo al rango de 0 a 7 usando el operador de resto. Este enlace se utiliza luego para calcular la coordenada x que tiene el sprite para la pose actual en la imagen."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch17-l9",
        "title": "Transformación",
        "sections": [
          {
            "id": "ch17-l9-s0",
            "title": "Transformación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero, ¿qué pasa si queremos que nuestro personaje camine hacia la izquierda en lugar de hacia la derecha? Podríamos dibujar otro conjunto de sprites, por supuesto. Pero también podemos instruir al lienzo para que dibuje la imagen en sentido contrario."
              },
              {
                "type": "paragraph",
                "content": "Llamar al método <code>scale</code> hará que todo lo que se dibuje después de él se escale. Este método toma dos parámetros, uno para establecer una escala horizontal y otro para establecer una escala vertical."
              },
              {
                "type": "paragraph",
                "content": "Escalar hará que todo en la imagen dibujada, incluyendo el grosor de línea, se estire o se comprima como se especifique. Escalar por una cantidad negativa volteará la imagen. La volteadura ocurre alrededor del punto (0,0), lo que significa que también volteará la dirección del sistema de coordenadas. Cuando se aplica una escala horizontal de -1, una forma dibujada en la posición x 100 terminará en lo que solía ser la posición -100."
              }
            ]
          },
          {
            "id": "ch17-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Así que para voltear una imagen, no podemos simplemente agregar <code>cx.scale(-1, 1)</code> antes de la llamada a <code>drawImage</code> porque eso movería nuestra imagen fuera del lienzo, donde no sería visible. Podrías ajustar las coordenadas dadas a <code>drawImage</code> para compensar esto dibujando la imagen en la posición x -50 en lugar de 0. Otra solución, que no requiere que el código que hace el dibujo sepa sobre el cambio de escala, es ajustar el eje alrededor del cual ocurre el escalado."
              },
              {
                "type": "paragraph",
                "content": "Hay varios otros métodos además de <code>scale</code> que influyen en el sistema de coordenadas de un lienzo. Puedes rotar formas dibujadas posteriormente con el método <code>rotate</code> y moverlas con el método <code>translate</code>. Lo interesante—y confuso—es que estas transformaciones <em>se apilan</em>, lo que significa que cada una ocurre relativa a las transformaciones anteriores."
              },
              {
                "type": "paragraph",
                "content": "Entonces, si traducimos por 10 píxeles horizontales dos veces, todo se dibujará 20 píxeles a la derecha. Si primero movemos el centro del sistema de coordenadas a (50,50) y luego rotamos por 20 grados (aproximadamente 0.1π radianes), esa rotación ocurrirá <em>alrededor</em> del punto (50,50)."
              }
            ]
          },
          {
            "id": "ch17-l9-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/Dibujando en Canvas __ Eloquent JavaScript_files/transform.svg",
                "alt": "Diagrama que muestra el resultado de apilar transformaciones. El primer diagrama traduce y luego rota, causando que la traducción ocurra normalmente y la rotación alrededor del objetivo de la traducción. El segundo diagrama primero rota y luego traduce, causando que la rotación ocurra alrededor del origen y la dirección de traducción se incline por esa rotación."
              },
              {
                "type": "paragraph",
                "content": "Pero si <em>primero</em> rotamos 20 grados y <em>luego</em> traducimos por (50,50), la traducción ocurrirá en el sistema de coordenadas rotado y producirá una orientación diferente. El orden en el que se aplican las transformaciones es importante."
              },
              {
                "type": "paragraph",
                "content": "Para voltear una imagen alrededor de la línea vertical en una posición x dada, podemos hacer lo siguiente:"
              }
            ]
          },
          {
            "id": "ch17-l9-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Movemos el eje y a donde queremos que esté nuestro espejo, aplicamos el efecto de espejo y finalmente devolvemos el eje y a su lugar adecuado en el universo espejado. La siguiente imagen explica por qué esto funciona:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Dibujando en Canvas __ Eloquent JavaScript_files/mirror.svg",
                "alt": "Diagrama que muestra el efecto de trasladar y espejar un triángulo"
              },
              {
                "type": "paragraph",
                "content": "Esto muestra los sistemas de coordenadas antes y después del espejo a través de la línea central. Los triángulos están numerados para ilustrar cada paso. Si dibujamos un triángulo en una posición x positiva, por defecto estaría en el lugar donde se encuentra el triángulo 1. Una llamada a <code>flipHorizontally</code> primero realiza una traslación a la derecha, lo que nos lleva al triángulo 2. Luego escala, volteando el triángulo a la posición 3. Esto no es donde debería estar, si estuviera reflejado en la línea dada. La segunda llamada a <code>translate</code> corrige esto, “cancela” la traslación inicial y hace que el triángulo 4 aparezca exactamente donde debería."
              }
            ]
          },
          {
            "id": "ch17-l9-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora podemos dibujar un personaje espejado en la posición (100,0) volteando el mundo alrededor del centro vertical del personaje."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch17-l10",
        "title": "Almacenando y eliminando transformaciones",
        "sections": [
          {
            "id": "ch17-l10-s0",
            "title": "Almacenando y eliminando transformaciones",
            "content": [
              {
                "type": "paragraph",
                "content": "Las transformaciones permanecen. Todo lo que dibujemos después de ese personaje espejado también estará reflejado. Eso podría ser inconveniente."
              },
              {
                "type": "paragraph",
                "content": "Es posible guardar la transformación actual, hacer algunos dibujos y transformaciones, y luego restaurar la antigua transformación. Esto suele ser lo apropiado para una función que necesita transformar temporalmente el sistema de coordenadas. Primero, guardamos cualquier transformación que estuviera utilizando el código que llamó a la función. Luego, la función realiza su tarea, agregando más transformaciones sobre la transformación actual. Finalmente, volvemos a la transformación con la que comenzamos."
              },
              {
                "type": "paragraph",
                "content": "Los métodos <code>save</code> y <code>restore</code> en el contexto 2D del lienzo hacen este manejo de transformaciones. Conceptualmente mantienen una pila de estados de transformación. Cuando llamas a <code>save</code>, el estado actual se apila, y cuando llamas a <code>restore</code>, se elimina el estado de la cima de la pila y se usa como la transformación actual del contexto. También puedes llamar a <code>resetTransform</code> para restablecer completamente la transformación."
              }
            ]
          },
          {
            "id": "ch17-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>branch</code> en el siguiente ejemplo ilustra lo que puedes hacer con una función que cambia la transformación y luego llama a una función (en este caso a sí misma), que continúa dibujando con la transformación dada.Esta función dibuja una forma parecida a un árbol dibujando una línea, moviendo el centro del sistema de coordenadas al final de la línea, y llamándose a sí misma dos veces, primero rotada a la izquierda y luego rotada a la derecha. Cada llamada reduce la longitud de la rama dibujada, y la recursividad se detiene cuando la longitud desciende por debajo de 8."
              },
              {
                "type": "paragraph",
                "content": "Si las llamadas a <code>save</code> y <code>restore</code> no estuvieran allí, la segunda llamada recursiva a <code>branch</code> terminaría con la posición y rotación creadas por la primera llamada. No estaría conectada a la rama actual sino más bien a la rama más interna y a la derecha dibujada por la primera llamada. La forma resultante podría ser interesante, pero definitivamente no sería un árbol."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch17-l11",
        "title": "De vuelta al juego",
        "sections": [
          {
            "id": "ch17-l11-s0",
            "title": "De vuelta al juego",
            "content": [
              {
                "type": "paragraph",
                "content": "Ahora sabemos lo suficiente sobre el dibujo en canvas para empezar a trabajar en un sistema de display basado en canvas para el juego del capítulo anterior. El nuevo display ya no mostrará solo cajas de colores. En su lugar, usaremos <code>drawImage</code> para dibujar imágenes que representen los elementos del juego."
              },
              {
                "type": "paragraph",
                "content": "Definimos otro tipo de objeto de display llamado <code>CanvasDisplay</code>, que soporta la misma interfaz que <code>DOMDisplay</code> del Capítulo 16, es decir, los métodos <code>syncState</code> y <code>clear</code>."
              },
              {
                "type": "paragraph",
                "content": "Este objeto mantiene un poco más de información que <code>DOMDisplay</code>. En lugar de utilizar la posición de desplazamiento de su elemento DOM, realiza un seguimiento de su propio viewport, que nos indica qué parte del nivel estamos viendo actualmente. Por último, mantiene una propiedad <code>flipPlayer</code> para que incluso cuando el jugador esté quieto, siga mirando en la dirección en la que se movió por última vez."
              }
            ]
          },
          {
            "id": "ch17-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>syncState</code> primero calcula un nuevo viewport y luego dibuja la escena del juego en la posición adecuada."
              },
              {
                "type": "paragraph",
                "content": "A diferencia de <code>DOMDisplay</code>, este estilo de visualización <strong>sí</strong> tiene que redibujar el fondo en cada actualización. Debido a que las formas en un lienzo son solo píxeles, una vez que las dibujamos no hay una buena manera de moverlas (o eliminarlas). La única forma de actualizar la visualización en lienzo es borrarla y volver a dibujar la escena. También puede ser que hayamos hecho scroll, lo que requeriría que el fondo esté en una posición diferente."
              },
              {
                "type": "paragraph",
                "content": "El método <code>updateViewport</code> es similar al método <code>scrollPlayerIntoView</code> de <code>DOMDisplay</code>. Verifica si el jugador está demasiado cerca del borde de la pantalla y mueve el <strong>viewport</strong> en ese caso."
              }
            ]
          },
          {
            "id": "ch17-l11-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las llamadas a <code>Math.max</code> y <code>Math.min</code> aseguran que el <strong>viewport</strong> no termine mostrando espacio fuera del nivel. <code>Math.max(x, 0)</code> se asegura de que el número resultante no sea menor que cero. <code>Math.min</code> garantiza de manera similar que un valor se mantenga por debajo de un límite dado."
              },
              {
                "type": "paragraph",
                "content": "Al <strong>limpiar</strong> la visualización, usaremos un color ligeramente diferente según si el juego se ha ganado (más brillante) o perdido (más oscuro)."
              },
              {
                "type": "paragraph",
                "content": "Para dibujar el fondo, recorremos los mosaicos que son visibles en el <strong>viewport</strong> actual, utilizando el mismo truco usado en el método <code>touches</code> del capítulo anterior."
              }
            ]
          },
          {
            "id": "ch17-l11-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las casillas que no están vacías se dibujan con <code>drawImage</code>. La imagen <code>otherSprites</code> contiene las imágenes utilizadas para elementos que no son el jugador. Contiene, de izquierda a derecha, la casilla de pared, la casilla de lava y el sprite de una moneda."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Dibujando en Canvas __ Eloquent JavaScript_files/sprites_big.png",
                "alt": "Arte pixelado que muestra tres sprites: una pieza de pared, hecha de pequeñas piedras blancas, un cuadrado de lava naranja y una moneda redonda."
              },
              {
                "type": "paragraph",
                "content": "Las casillas de fondo son de 20 por 20 píxeles ya que usaremos la misma escala que en <code>DOMDisplay</code>. Por lo tanto, el desplazamiento para las casillas de lava es 20 (el valor del enlace <code>scale</code>), y el desplazamiento para las paredes es 0."
              }
            ]
          },
          {
            "id": "ch17-l11-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "No nos molesta esperar a que se cargue la imagen del sprite. Llamar a <code>drawImage</code> con una imagen que aún no se ha cargado simplemente no hará nada. Por lo tanto, podríamos no dibujar correctamente el juego durante los primeros cuadros, mientras la imagen aún se está cargando, pero eso no es un problema grave. Dado que seguimos actualizando la pantalla, la escena correcta aparecerá tan pronto como termine la carga."
              },
              {
                "type": "paragraph",
                "content": "El personaje de movimiento que se mostró anteriormente se utilizará para representar al jugador. El código que lo dibuja necesita seleccionar el sprite adecuado y la dirección basándose en el movimiento actual del jugador. Los primeros ocho sprites contienen una animación de caminar. Cuando el jugador se está moviendo a lo largo de una superficie, los recorremos según el tiempo actual. Queremos cambiar de fotogramas cada 60 milisegundos, por lo que primero dividimos el tiempo por 60. Cuando el jugador está quieto, dibujamos el noveno sprite. Durante los saltos, que se reconocen por el hecho de que la velocidad vertical no es cero, usamos el décimo sprite de la derecha."
              },
              {
                "type": "paragraph",
                "content": "Dado que los sprites son ligeramente más anchos que el objeto del jugador—24 en lugar de 16 píxeles para permitir algo de espacio para los pies y los brazos—el método debe ajustar la coordenada x y el ancho por una cantidad dada (<code>playerXOverlap</code>)."
              }
            ]
          },
          {
            "id": "ch17-l11-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El método <code>drawPlayer</code> es llamado por <code>drawActors</code>, el cual es responsable de dibujar todos los actores en el juego."
              },
              {
                "type": "paragraph",
                "content": "Cuando se está dibujando algo que no es el jugador, miramos su tipo para encontrar el desplazamiento del sprite correcto. El tile de lava se encuentra en el desplazamiento 20, y el sprite de la moneda se encuentra en 40 (dos veces <code>scale</code>)."
              },
              {
                "type": "paragraph",
                "content": "Tenemos que restar la posición del viewport al calcular la posición del actor, ya que (0,0) en nuestro canvas corresponde a la esquina superior izquierda del viewport, no a la esquina superior izquierda del nivel. También podríamos haber usado <code>translate</code> para esto. De ambas maneras funciona."
              }
            ]
          },
          {
            "id": "ch17-l11-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este documento conecta el nuevo display a <code>runGame</code>:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      },
      {
        "id": "ch17-l12",
        "title": "Elección de una interfaz gráfica",
        "sections": [
          {
            "id": "ch17-l12-s0",
            "title": "Elección de una interfaz gráfica",
            "content": [
              {
                "type": "paragraph",
                "content": "Por lo tanto, cuando necesitas generar gráficos en el navegador, puedes elegir entre HTML simple, SVG y canvas. No hay un enfoque único <em>mejor</em> que funcione en todas las situaciones. Cada opción tiene sus fortalezas y debilidades."
              },
              {
                "type": "paragraph",
                "content": "HTML simple tiene la ventaja de ser simple. También se integra bien con texto. Tanto SVG como canvas te permiten dibujar texto, pero no te ayudarán a posicionar ese texto o envolverlo cuando ocupa más de una línea. En una imagen basada en HTML, es mucho más fácil incluir bloques de texto."
              },
              {
                "type": "paragraph",
                "content": "SVG se puede utilizar para producir gráficos nítidos que se ven bien en cualquier nivel de zoom. A diferencia de HTML, está diseñado para dibujar y, por lo tanto, es más adecuado para ese propósito."
              }
            ]
          },
          {
            "id": "ch17-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tanto SVG como HTML construyen una estructura de datos (el DOM) que representa tu imagen. Esto hace posible modificar elementos después de ser dibujados. Si necesitas cambiar repetidamente una pequeña parte de una imagen grande en respuesta a lo que está haciendo el usuario o como parte de una animación, hacerlo en un canvas puede ser innecesariamente costoso. El DOM también nos permite registrar manipuladores de eventos de ratón en cada elemento de la imagen (incluso en formas dibujadas con SVG). No puedes hacer eso con canvas."
              },
              {
                "type": "paragraph",
                "content": "Pero el enfoque orientado a píxeles de canvas puede ser una ventaja al dibujar una gran cantidad de elementos pequeños. El hecho de que no construye una estructura de datos, sino que solo dibuja repetidamente sobre la misma superficie de píxeles, hace que canvas tenga un menor costo por forma."
              },
              {
                "type": "paragraph",
                "content": "También hay efectos, como renderizar una escena píxel por píxel (por ejemplo, usando un ray tracer) o procesar una imagen con JavaScript (desenfocarla o distorsionarla), que solo son prácticos con un elemento canvas."
              }
            ]
          },
          {
            "id": "ch17-l12-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En algunos casos, puede que desees combinar varias de estas técnicas. Por ejemplo, podrías dibujar un gráfico con SVG o canvas pero mostrar información textual posicionando un elemento HTML encima de la imagen."
              },
              {
                "type": "paragraph",
                "content": "Para aplicaciones poco exigentes, realmente no importa mucho qué interfaz elijas. La visualización que construimos para nuestro juego en este capítulo podría haber sido implementada utilizando cualquiera de estas tres tecnologías gráficas ya que no necesita dibujar texto, manejar interacción del mouse o trabajar con una cantidad extraordinariamente grande de elementos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch17-l13",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch17-l13-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "En este capítulo discutimos técnicas para dibujar gráficos en el navegador, centrándonos en el elemento <code>&lt;canvas&gt;</code>."
              },
              {
                "type": "paragraph",
                "content": "Un nodo canvas representa un área en un documento en la que nuestro programa puede dibujar. Este dibujo se realiza a través de un objeto de contexto de dibujo, creado con el método <code>getContext</code>."
              },
              {
                "type": "paragraph",
                "content": "La interfaz de dibujo 2D nos permite rellenar y trazar varias formas. La propiedad <code>fillStyle</code> del contexto determina cómo se rellenan las formas. Las propiedades <code>strokeStyle</code> y <code>lineWidth</code> controlan la forma en que se dibujan las líneas."
              }
            ]
          },
          {
            "id": "ch17-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los rectángulos y trozos de texto se pueden dibujar con una sola llamada a método. Los métodos <code>fillRect</code> y <code>strokeRect</code> dibujan rectángulos, y los métodos <code>fillText</code> y <code>strokeText</code> dibujan texto. Para crear formas personalizadas, primero debemos construir un camino."
              },
              {
                "type": "paragraph",
                "content": "Llamar a <code>beginPath</code> inicia un nuevo camino. Varios otros métodos agregan líneas y curvas al camino actual. Por ejemplo, <code>lineTo</code> puede agregar una línea recta. Cuando un camino está terminado, se puede rellenar con el método <code>fill</code> o trazarse con el método <code>stroke</code>."
              },
              {
                "type": "paragraph",
                "content": "Mover píxeles desde una imagen u otro canvas a nuestro canvas se hace con el método <code>drawImage</code>. Por defecto, este método dibuja toda la imagen fuente, pero al darle más parámetros, puedes copiar un área específica de la imagen. Utilizamos esto para nuestro juego copiando poses individuales del personaje del juego de una imagen que contenía muchas poses."
              }
            ]
          },
          {
            "id": "ch17-l13-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las transformaciones te permiten dibujar una forma en múltiples orientaciones. Un contexto de dibujo 2D tiene una transformación actual que se puede cambiar con los métodos <code>translate</code>, <code>scale</code> y <code>rotate</code>. Estos afectarán todas las operaciones de dibujo subsiguientes. Un estado de transformación se puede guardar con el método <code>save</code> y restaurar con el método <code>restore</code>."
              },
              {
                "type": "paragraph",
                "content": "Al mostrar una animación en un canvas, se puede usar el método <code>clearRect</code> para borrar parte del canvas antes de volver a dibujarlo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch17-l14",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch17-l14-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Escribe un programa que dibuje las siguientes formas en un lienzo canvas:"
              },
              {
                "type": "list",
                "content": [
                  "Un trapecio (un rectángulo que es más ancho en un lado)",
                  "Un diamante rojo diamond (un rectángulo rotado 45 grados o ¼π radianes)",
                  "Una línea en zigzag",
                  "Un espiral compuesta por 100 segmentos de línea recta",
                  "Una estrella amarilla star"
                ]
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Dibujando en Canvas __ Eloquent JavaScript_files/exercise_shapes.png",
                "alt": "Imagen que muestra las formas que se te pide dibujar"
              },
              {
                "type": "paragraph",
                "content": "Cuando dibujes las dos últimas, es posible que quieras consultar la explicación de <code>Math.cos</code> y <code>Math.sin</code> en el Capítulo 14, que describe cómo obtener coordenadas en un círculo utilizando estas funciones."
              }
            ]
          },
          {
            "id": "ch17-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Recomiendo crear una función para cada forma. Pasa la posición y opcionalmente otras propiedades como el tamaño o el número de puntos, como parámetros. La alternativa, que es codificar números en todo tu código, tiende a hacer que el código sea innecesariamente difícil de leer y modificar."
              },
              {
                "type": "paragraph",
                "content": "El trapecio (1) es más fácil de dibujar usando un recorrido. Elige coordenadas centrales adecuadas y agrega cada una de las cuatro esquinas alrededor del centro."
              },
              {
                "type": "paragraph",
                "content": "{{index “función flipHorizontally”, rotación}}"
              }
            ]
          },
          {
            "id": "ch17-l14-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El diamante diamond (2) se puede dibujar de forma directa, con un recorrido, o de forma interesante, con una transformación de <code>rotación</code>. Para usar la rotación, tendrás que aplicar un truco similar al que hicimos en la función <code>flipHorizontally</code>. Debido a que quieres rotar alrededor del centro de tu rectángulo y no alrededor del punto (0,0), primero debes <code>translate</code> allí, luego rotar, y luego volver a trasladar."
              },
              {
                "type": "paragraph",
                "content": "Asegúrate de restablecer la transformación después de dibujar cualquier forma que la cree."
              },
              {
                "type": "paragraph",
                "content": "Para el zigzag (3) se vuelve impráctico escribir una nueva llamada a <code>lineTo</code> para cada segmento de línea. En su lugar, deberías usar un bucle. En cada iteración, puedes hacer que dibuje dos segmentos de línea (derecha y luego izquierda nuevamente) o uno, en cuyo caso debes usar la paridad (<code>% 2</code>) del índice del bucle para determinar si ir a la izquierda o a la derecha."
              }
            ]
          },
          {
            "id": "ch17-l14-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "También necesitarás un bucle para la espiral (4). Si dibujas una serie de puntos, con cada punto moviéndose más lejos a lo largo de un círculo alrededor del centro de la espiral, obtienes un círculo. Si, durante el bucle, varías el radio del círculo en el que estás poniendo el punto actual y das más de una vuelta, el resultado es una espiral."
              },
              {
                "type": "paragraph",
                "content": "La estrella (5) representada está construida con líneas <code>quadraticCurveTo</code>. También podrías dibujar una con líneas rectas. Divide un círculo en ocho piezas para una estrella con ocho puntas, o cuantas piezas desees. Dibuja líneas entre estos puntos, haciéndolas curvar hacia el centro de la estrella. Con <code>quadraticCurveTo</code>, puedes usar el centro como punto de control."
              },
              {
                "type": "paragraph",
                "content": "Anteriormente en este capítulo, vimos un programa de ejemplo que dibujaba un gráfico circular. Modifica este programa para que el nombre de cada categoría se muestre junto a la porción que la representa. Intenta encontrar una forma agradable de posicionar automáticamente este texto que funcione también para otros conjuntos de datos. Puedes asumir que las categorías son lo suficientemente grandes como para dejar espacio suficiente para sus etiquetas."
              }
            ]
          },
          {
            "id": "ch17-l14-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Podrías necesitar <code>Math.sin</code> y <code>Math.cos</code> de nuevo, que se describen en el Capítulo 14."
              },
              {
                "type": "paragraph",
                "content": "Necesitarás llamar a <code>fillText</code> y establecer las propiedades <code>textAlign</code> y <code>textBaseline</code> del contexto de manera que el texto termine donde quieras."
              },
              {
                "type": "paragraph",
                "content": "Una forma sensata de posicionar las etiquetas sería poner el texto en la línea que va desde el centro del círculo a través del medio de la porción. No quieres poner el texto directamente contra el lado del círculo, sino mover el texto hacia afuera del círculo por un número determinado de píxeles."
              }
            ]
          },
          {
            "id": "ch17-l14-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El ángulo de esta línea es <code>currentAngle + 0.<wbr>5 * sliceAngle</code>. El siguiente código encuentra una posición en esta línea a 120 píxeles del centro:"
              },
              {
                "type": "paragraph",
                "content": "Para <code>textBaseline</code>, el valor <code>\"middle\"</code> probablemente sea apropiado al usar este enfoque. Lo que se debe usar para <code>textAlign</code> depende de en qué lado del círculo nos encontremos. En el lado izquierdo, debería ser <code>\"right\"</code>, y en el lado derecho, debería ser <code>\"left\"</code>, de manera que el texto se posicione lejos del círculo."
              },
              {
                "type": "paragraph",
                "content": "Si no estás seguro de cómo averiguar en qué lado del círculo se encuentra un ángulo dado, consulta la explicación de <code>Math.cos</code> en el Capítulo 14. El coseno de un ángulo nos indica qué coordenada x le corresponde, lo que a su vez nos dice exactamente en qué lado del círculo estamos."
              }
            ]
          },
          {
            "id": "ch17-l14-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Utiliza la técnica de <code>requestAnimationFrame</code> que vimos en el Capítulo 14 y Capítulo 16 para dibujar una caja con una pelota rebotando dentro. La pelota se mueve a una velocidad constante y rebota en los lados de la caja cuando los alcanza."
              },
              {
                "type": "paragraph",
                "content": "Un cuadro es fácil de dibujar con <code>strokeRect</code>. Define una variable que contenga su tamaño o define dos variables si el ancho y alto de tu cuadro difieren. Para crear una pelota redonda, comienza un camino y llama a <code>arc(x, y, radio, 0, 7)</code>, que crea un arco que va desde cero a más de un círculo completo. Luego rellena el camino."
              },
              {
                "type": "paragraph",
                "content": "Para modelar la posición y la velocidad de la pelota, puedes usar la clase <code>Vec</code> del Capítulo 16 (que está disponible en esta página){if interactive}. Dale una velocidad inicial, preferiblemente una que no sea puramente vertical u horizontal, y en cada cuadro multiplica esa velocidad por la cantidad de tiempo transcurrido. Cuando la pelota se acerca demasiado a una pared vertical, invierte el componente x en su velocidad. De manera similar, invierte el componente y cuando golpea una pared horizontal."
              }
            ]
          },
          {
            "id": "ch17-l14-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Después de encontrar la nueva posición y velocidad de la pelota, usa <code>clearRect</code> para borrar la escena y vuélvela a dibujar usando la nueva posición."
              },
              {
                "type": "paragraph",
                "content": "Una desventaja de las transformaciones es que ralentizan el dibujo de mapas de bits. La posición y el tamaño de cada píxel deben ser transformados, y aunque es posible que los navegadores se vuelvan más inteligentes sobre las transformaciones en el futuro, actualmente causan un aumento medible en el tiempo que lleva dibujar un mapa de bits."
              },
              {
                "type": "paragraph",
                "content": "En un juego como el nuestro, en el que solo estamos dibujando un sprite transformado, esto no es un problema. Pero imagina que necesitamos dibujar cientos de personajes o miles de partículas giratorias de una explosión."
              }
            ]
          },
          {
            "id": "ch17-l14-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Piensa en una forma de permitirnos dibujar un personaje invertido sin cargar archivos de imagen adicionales y sin tener que hacer llamadas transformadas de <code>drawImage</code> en cada cuadro."
              },
              {
                "type": "paragraph",
                "content": "La clave para la solución está en el hecho de que podemos usar un elemento canvas como imagen de origen al usar <code>drawImage</code>. Es posible crear un elemento <code>&lt;canvas&gt;</code> adicional, sin agregarlo al documento, y dibujar nuestros sprites invertidos en él, una vez. Al dibujar un cuadro real, simplemente copiamos los sprites ya invertidos al lienzo principal."
              },
              {
                "type": "paragraph",
                "content": "Se requeriría cierto cuidado porque las imágenes no se cargan instantáneamente. Hacemos el dibujo invertido solo una vez y, si lo hacemos antes de que la imagen se cargue, no dibujará nada. Se puede usar un controlador de <code>\"load\"</code> en la imagen para dibujar las imágenes invertidas en el lienzo adicional. Este lienzo se puede usar como fuente de dibujo inmediatamente (simplemente estará en blanco hasta que dibujemos el personaje en él)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 65
      }
    ]
  },
  {
    "id": "ch18",
    "number": 18,
    "title": "HTTP y Formularios",
    "titleEs": "HTTP y Formularios",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "Lo que a menudo resultaba difícil para las personas entender sobre el diseño era que no había nada más allá de las URL, HTTP y HTML. No había una comp...",
    "isProject": false,
    "totalXP": 605,
    "lessons": [
      {
        "id": "ch18-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch18-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Lo que a menudo resultaba difícil para las personas entender sobre el diseño era que no había nada más allá de las URL, HTTP y HTML. No había una computadora central “controlando” la Web, no existía una sola red en la que funcionaran estos protocolos, ni siquiera una organización en algún lugar que “dirigiera” la Web. La Web no era una “cosa” física que existía en un cierto “lugar”. Era un “espacio” en el que la información podía existir. Tim Berners-Lee"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/HTTP y Formularios __ Eloquent JavaScript_files/chapter_picture_18.jpg",
                "alt": "Ilustración mostrando un formulario de registro en la web en un pergamino"
              },
              {
                "type": "paragraph",
                "content": "El <em>Protocolo de Transferencia de Hipertexto</em>, mencionado anteriormente en el Capítulo 13, es el mecanismo a través del cual se solicita y proporciona datos en la World Wide Web. Este capítulo describe el protocolo con más detalle y explica la forma en que JavaScript del navegador tiene acceso a él."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch18-l1",
        "title": "El protocolo",
        "sections": [
          {
            "id": "ch18-l1-s0",
            "title": "El protocolo",
            "content": [
              {
                "type": "paragraph",
                "content": "Si escribes <em>eloquentjavascript.net/18_http.html</em> en la barra de direcciones de tu navegador, el navegador primero busca la dirección del servidor asociado con <em>eloquentjavascript.net</em> e intenta abrir una conexión TCP con él en el puerto 80, el puerto predeterminado para el tráfico HTTP. Si el servidor existe y acepta la conexión, el navegador podría enviar algo como esto:"
              },
              {
                "type": "paragraph",
                "content": "Luego el servidor responde, a través de esa misma conexión."
              },
              {
                "type": "paragraph",
                "content": "El navegador toma la parte de la respuesta después de la línea en blanco, su <em>cuerpo</em> (no confundir con la etiqueta HTML <code>&lt;body&gt;</code>), y lo muestra como un documento HTML."
              }
            ]
          },
          {
            "id": "ch18-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La información enviada por el cliente se llama la <em>solicitud</em>. Comienza con esta línea:"
              },
              {
                "type": "paragraph",
                "content": "La primera palabra es el <em>método</em> de la solicitud. <code>GET</code> significa que queremos <em>obtener</em> el recurso especificado. Otros métodos comunes son <code>DELETE</code> para eliminar un recurso, <code>PUT</code> para crearlo o reemplazarlo, y <code>POST</code> para enviar información a él. Cabe destacar que el servidor no está obligado a llevar a cabo cada solicitud que recibe. Si te acercas a un sitio web aleatorio y le dices que <code>DELETE</code> su página principal, probablemente se negará."
              },
              {
                "type": "paragraph",
                "content": "La parte después del nombre del método es la ruta del <em>recurso</em> al que aplica la solicitud. En el caso más simple, un recurso es simplemente un archivo en el servidor, pero el protocolo no lo requiere así. Un recurso puede ser cualquier cosa que pueda transferirse <em>como si fuera</em> un archivo. Muchos servidores generan las respuestas que producen al vuelo. Por ejemplo, si abres <em>https://github.com/marijnh</em>, el servidor buscará en su base de datos un usuario llamado “marijnh”, y si lo encuentra, generará una página de perfil para ese usuario.Después de la ruta del recurso, la primera línea de la solicitud menciona <code>HTTP/1.1</code> para indicar la versión del protocolo HTTP que está utilizando."
              }
            ]
          },
          {
            "id": "ch18-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En la práctica, muchos sitios utilizan la versión 2 de HTTP, que soporta los mismos conceptos que la versión 1.1 pero es mucho más complicada para que pueda ser más rápida. Los navegadores cambiarán automáticamente a la versión de protocolo adecuada al comunicarse con un servidor dado, y el resultado de una solicitud es el mismo independientemente de la versión utilizada. Dado que la versión 1.1 es más directa y más fácil de entender, la usaremos para ilustrar el protocolo."
              },
              {
                "type": "paragraph",
                "content": "La respuesta del servidor comenzará también con una versión, seguida del estado de la respuesta, primero como un código de estado de tres dígitos y luego como una cadena legible por humanos."
              },
              {
                "type": "paragraph",
                "content": "Los códigos de estado que comienzan con 2 indican que la solicitud tuvo éxito. Los códigos que comienzan con 4 significan que hubo un problema con la solicitud. El 404 es probablemente el código de estado de HTTP más famoso, lo que significa que el recurso no se pudo encontrar. Los códigos que comienzan con 5 indican que ocurrió un error en el servidor y la solicitud no es la responsable."
              }
            ]
          },
          {
            "id": "ch18-l1-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La primera línea de una solicitud o respuesta puede ir seguida de cualquier número de <em>cabeceras</em>. Estas son líneas en la forma <code>nombre: valor</code> que especifican información adicional sobre la solicitud o respuesta. Estas cabeceras eran parte del ejemplo de respuesta:"
              },
              {
                "type": "paragraph",
                "content": "Esto nos indica el tamaño y tipo del documento de respuesta. En este caso, es un documento HTML de 87,320 bytes. También nos dice cuándo se modificó por última vez ese documento."
              },
              {
                "type": "paragraph",
                "content": "El cliente y servidor son libres de decidir qué cabeceras incluir en sus solicitudes o respuestas. Sin embargo, algunas de ellas son necesarias para que todo funcione. Por ejemplo, sin la cabecera <code>Content-Type</code> en la respuesta, el navegador no sabrá cómo mostrar el documento."
              }
            ]
          },
          {
            "id": "ch18-l1-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Después de las cabeceras, tanto las solicitudes como las respuestas pueden incluir una línea en blanco seguida de un cuerpo, que contiene el documento real que se envía. Las solicitudes <code>GET</code> y <code>DELETE</code> no envían ningún dato, pero las solicitudes <code>PUT</code> y <code>POST</code> sí lo hacen. Algunos tipos de respuestas, como las respuestas de error, tampoco requieren un cuerpo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch18-l2",
        "title": "Navegadores y HTTP",
        "sections": [
          {
            "id": "ch18-l2-s0",
            "title": "Navegadores y HTTP",
            "content": [
              {
                "type": "paragraph",
                "content": "Como vimos, un navegador hará una solicitud cuando introducimos una URL en la barra de direcciones. Cuando la página HTML resultante hace referencia a otros archivos, como imágenes y archivos de JavaScript, el navegador los recuperará también."
              },
              {
                "type": "paragraph",
                "content": "Un sitio web moderadamente complicado puede incluir fácilmente entre 10 y 200 recursos. Para poder obtenerlos rápidamente, los navegadores harán varias solicitudes <code>GET</code> simultáneamente en lugar de esperar las respuestas una por una.Las páginas HTML pueden incluir formularios, que permiten al usuario completar información y enviarla al servidor. A continuación se muestra un ejemplo de un formulario:"
              },
              {
                "type": "paragraph",
                "content": "Este código describe un formulario con dos campos: uno pequeño que pide un nombre y otro más grande para escribir un mensaje. Cuando se hace clic en el botón Enviar, el formulario se envía, lo que significa que el contenido de sus campos se empaqueta en una solicitud HTTP y el navegador navega hacia el resultado de esa solicitud."
              }
            ]
          },
          {
            "id": "ch18-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando el atributo <code>method</code> del elemento <code>&lt;form&gt;</code> es <code>GET</code> (o se omite), la información del formulario se agrega al final de la URL de <code>action</code> como una cadena de consulta. El navegador podría hacer una solicitud a esta URL:"
              },
              {
                "type": "paragraph",
                "content": "El signo de interrogación indica el final de la parte de la ruta de la URL y el inicio de la consulta. Le siguen pares de nombres y valores, correspondientes al atributo <code>name</code> en los elementos del campo del formulario y al contenido de esos elementos, respectivamente. Un carácter ampersand (<code>&amp;</code>) se utiliza para separar los pares."
              },
              {
                "type": "paragraph",
                "content": "El mensaje real codificado en la URL es “Yes?”, pero el signo de interrogación se reemplaza por un código extraño. Algunos caracteres en las cadenas de consulta deben ser escapados. El signo de interrogación, representado como <code>%3F</code>, es uno de ellos. Parece haber una regla no escrita de que cada formato necesita su propia forma de escapar caracteres. Este, llamado codificación de URL, utiliza un signo de porcentaje seguido de dos dígitos hexadecimales (base 16) que codifican el código de caracteres. En este caso, 3F, que es 63 en notación decimal, es el código de un signo de interrogación. JavaScript proporciona las funciones <code>encodeURIComponent</code> y <code>decodeURIComponent</code> para codificar y decodificar este formato."
              }
            ]
          },
          {
            "id": "ch18-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si cambiamos el atributo <code>method</code> del formulario HTML en el ejemplo que vimos anteriormente a <code>POST</code>, la solicitud HTTP realizada para enviar el formulario utilizará el método <code>POST</code> y colocará la cadena de consulta en el cuerpo de la solicitud, en lugar de agregarla a la URL."
              },
              {
                "type": "paragraph",
                "content": "Las solicitudes <code>GET</code> deben utilizarse para solicitudes que no tengan efectos secundarios, sino simplemente para solicitar información. Las solicitudes que cambian algo en el servidor, como por ejemplo crear una nueva cuenta o publicar un mensaje, deben expresarse con otros métodos, como <code>POST</code>. El software del lado del cliente, como un navegador, sabe que no debe hacer solicitudes <code>POST</code> a ciegas, pero a menudo implícitamente realiza solicitudes <code>GET</code>, por ejemplo, para precargar un recurso que cree que pronto el usuario necesitará.Volveremos a hablar de formularios y cómo interactuar con ellos desde JavaScript más adelante en el capítulo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch18-l3",
        "title": "Fetch",
        "sections": [
          {
            "id": "ch18-l3-s0",
            "title": "Fetch",
            "content": [
              {
                "type": "paragraph",
                "content": "La interfaz a través de la cual JavaScript del navegador puede hacer solicitudes HTTP se llama <code>fetch</code>."
              },
              {
                "type": "paragraph",
                "content": "Llamar a <code>fetch</code> devuelve una promesa que se resuelve en un objeto <code>Response</code> que contiene información sobre la respuesta del servidor, como su código de estado y sus encabezados. Los encabezados están envueltos en un objeto similar a un <code>Map</code> que trata sus claves (los nombres de los encabezados) como insensibles a mayúsculas y minúsculas porque los nombres de los encabezados no deben ser sensibles a mayúsculas y minúsculas. Esto significa que <code>headers.<wbr>get(\"Content-Type\")</code> y <code>headers.<wbr>get(\"content-TYPE\")</code> devolverán el mismo valor."
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que la promesa devuelta por <code>fetch</code> se resuelve con éxito incluso si el servidor responde con un código de error. También puede ser rechazada si hay un error de red o si el servidor al que se dirige la solicitud no se puede encontrar."
              }
            ]
          },
          {
            "id": "ch18-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El primer argumento de <code>fetch</code> es la URL que se debe solicitar. Cuando esa URL no comienza con un nombre de protocolo (como <em>http:</em>), se trata como <em>relativa</em>, lo que significa que se interpreta en relación con el documento actual. Cuando comienza con una barra (/), reemplaza la ruta actual, que es la parte después del nombre del servidor. Cuando no lo hace, la parte de la ruta actual hasta e incluyendo su último carácter de barra se coloca al principio de la URL relativa."
              },
              {
                "type": "paragraph",
                "content": "Para acceder al contenido real de una respuesta, puedes usar su método <code>text</code>. Debido a que la promesa inicial se resuelve tan pronto como se han recibido los encabezados de la respuesta y porque leer el cuerpo de la respuesta podría llevar un poco más de tiempo, esto devuelve nuevamente una promesa."
              },
              {
                "type": "paragraph",
                "content": "Un método similar, llamado <code>json</code>, devuelve una promesa que se resuelve al valor que obtienes al analizar el cuerpo como JSON o se rechaza si no es un JSON válido."
              }
            ]
          },
          {
            "id": "ch18-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por defecto, <code>fetch</code> utiliza el método <code>GET</code> para realizar su solicitud y no incluye un cuerpo de solicitud. Puedes configurarlo de manera diferente pasando un objeto con opciones adicionales como segundo argumento. Por ejemplo, esta solicitud intenta eliminar <code>ejemplo/<wbr>datos.<wbr>txt</code>:"
              },
              {
                "type": "paragraph",
                "content": "El código de estado 405 significa “método no permitido”, la forma en que un servidor HTTP dice “Me temo que no puedo hacer eso”."
              },
              {
                "type": "paragraph",
                "content": "Para agregar un cuerpo de solicitud, puedes incluir una opción <code>body</code>. Para establecer cabeceras, está la opción <code>headers</code>. Por ejemplo, esta solicitud incluye una cabecera <code>Range</code>, que indica al servidor que devuelva solo una parte de un documento."
              }
            ]
          },
          {
            "id": "ch18-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El navegador automáticamente añadirá algunas cabeceras de solicitud, como “Host” y aquellas necesarias para que el servidor pueda determinar el tamaño del cuerpo. Sin embargo, añadir tus propias cabeceras es muchas veces útil para incluir cosas como información de autenticación o para indicar al servidor en qué formato de archivo te gustaría recibir."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch18-l4",
        "title": "Aislamiento HTTP",
        "sections": [
          {
            "id": "ch18-l4-s0",
            "title": "Aislamiento HTTP",
            "content": [
              {
                "type": "paragraph",
                "content": "Realizar solicitudes HTTP en scripts de páginas web plantea nuevamente preocupaciones sobre seguridad. La persona que controla el script puede no tener los mismos intereses que la persona en cuya computadora se está ejecutando. Específicamente, si visito <em>themafia.org</em>, no quiero que sus scripts puedan hacer una solicitud a <em>mybank.com</em>, utilizando información de identificación de mi navegador, con instrucciones para transferir todo mi dinero."
              },
              {
                "type": "paragraph",
                "content": "Por esta razón, los navegadores nos protegen al impedir que los scripts hagan solicitudes HTTP a otros dominios (nombres como <em>themafia.org</em> y <em>mybank.com</em>)."
              },
              {
                "type": "paragraph",
                "content": "Esto puede ser un problema molesto al construir sistemas que necesitan acceder a varios dominios por razones legítimas. Afortunadamente, los servidores pueden incluir una cabecera como esta en sus respuestas para indicar explícitamente al navegador que está bien que la solicitud provenga de otro dominio:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch18-l5",
        "title": "Apreciando HTTP",
        "sections": [
          {
            "id": "ch18-l5-s0",
            "title": "Apreciando HTTP",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se construye un sistema que requiere comunicación entre un programa JavaScript que se ejecuta en el navegador (lado del cliente) y un programa en un servidor (lado del servidor), hay varias formas diferentes de modelar esta comunicación."
              },
              {
                "type": "paragraph",
                "content": "Un modelo comúnmente utilizado es el de las <em>llamadas de procedimiento remoto</em>. En este modelo, la comunicación sigue los patrones de llamadas de función normales, excepto que la función en realidad se está ejecutando en otra máquina. Llamarla implica hacer una solicitud al servidor que incluye el nombre de la función y sus argumentos. La respuesta a esa solicitud contiene el valor devuelto."
              },
              {
                "type": "paragraph",
                "content": "Cuando se piensa en términos de llamadas de procedimiento remoto, HTTP es simplemente un vehículo de comunicación, y es muy probable que escribas una capa de abstracción que lo oculte por completo."
              }
            ]
          },
          {
            "id": "ch18-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Otro enfoque es construir tu comunicación en torno al concepto de recursos y métodos HTTP. En lugar de un procedimiento remoto llamado <code>addUser</code>, usas una solicitud <code>PUT</code> a <code>/usuarios/larry</code>. En lugar de codificar las propiedades de ese usuario en argumentos de función, defines un formato de documento JSON (o utilizas un formato existente) que represente a un usuario. El cuerpo de la solicitud <code>PUT</code> para crear un nuevo recurso es entonces dicho documento. Se obtiene un recurso realizando una solicitud <code>GET</code> a la URL del recurso (por ejemplo, <code>/usuario/larry</code>), que de nuevo devuelve el documento que representa al recurso.Este segundo enfoque facilita el uso de algunas de las características que proporciona HTTP, como el soporte para la caché de recursos (mantener una copia de un recurso en el cliente para un acceso rápido). Los conceptos utilizados en HTTP, que están bien diseñados, pueden proporcionar un conjunto útil de principios para diseñar la interfaz de tu servidor."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l6",
        "title": "Seguridad y HTTPS",
        "sections": [
          {
            "id": "ch18-l6-s0",
            "title": "Seguridad y HTTPS",
            "content": [
              {
                "type": "paragraph",
                "content": "Los datos que viajan por Internet tienden a seguir un largo y peligroso camino. Para llegar a su destino, deben pasar por cualquier cosa, desde puntos de acceso Wi-Fi de cafeterías hasta redes controladas por varias empresas y estados. En cualquier punto a lo largo de su ruta, pueden ser inspeccionados o incluso modificados."
              },
              {
                "type": "paragraph",
                "content": "Si es importante que algo se mantenga en secreto, como la contraseña de tu cuenta de correo electrónico, o que llegue a su destino sin modificaciones, como el número de cuenta al que transfieres dinero a través del sitio web de tu banco, HTTP simple no es suficiente."
              },
              {
                "type": "paragraph",
                "content": "El protocolo seguro HTTP, utilizado para URLs que comienzan con <em>https://</em>, envuelve el tráfico HTTP de una manera que dificulta su lectura y manipulación. Antes de intercambiar datos, el cliente verifica que el servidor sea quien dice ser, solicitándole que demuestre que tiene un certificado criptográfico emitido por una autoridad de certificación que el navegador reconoce. Luego, todos los datos que pasan por la conexión están encriptados de una manera que debería evitar el espionaje y la manipulación."
              }
            ]
          },
          {
            "id": "ch18-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Así, cuando funciona correctamente, HTTPS evita que otras personas se hagan pasar por el sitio web con el que estás intentando comunicarte <em>y</em> que espíen tu comunicación. No es perfecto, y ha habido varios incidentes en los que HTTPS falló debido a certificados falsificados o robados y software defectuoso, pero es <em>mucho</em> más seguro que el simple HTTP."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l7",
        "title": "Campos de formulario",
        "sections": [
          {
            "id": "ch18-l7-s0",
            "title": "Campos de formulario",
            "content": [
              {
                "type": "paragraph",
                "content": "Los formularios fueron diseñados originalmente para la Web pre-JavaScript para permitir que los sitios web envíen información enviada por el usuario en una solicitud HTTP. Este diseño asume que la interacción con el servidor siempre ocurre navegando a una nueva página."
              },
              {
                "type": "paragraph",
                "content": "Pero sus elementos son parte del DOM al igual que el resto de la página, y los elementos DOM que representan los campos de formulario admiten una serie de propiedades y eventos que no están presentes en otros elementos. Esto hace posible inspeccionar y controlar dichos campos de entrada con programas JavaScript y hacer cosas como agregar nueva funcionalidad a un formulario o utilizar formularios y campos como bloques de construcción en una aplicación JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Un formulario web consiste en cualquier número de campos de entrada agrupados en una etiqueta <code>&lt;form&gt;</code>. HTML permite varios estilos diferentes de campos, que van desde simples casillas de verificación de encendido/apagado hasta menús desplegables y campos para entrada de texto. Este libro no intentará discutir exhaustivamente todos los tipos de campos, pero comenzaremos con una vista general aproximada."
              }
            ]
          },
          {
            "id": "ch18-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Muchos tipos de campos utilizan la etiqueta <code>&lt;input&gt;</code>. El atributo <code>type</code> de esta etiqueta se utiliza para seleccionar el estilo del campo. Estos son algunos tipos comúnmente utilizados de <code>&lt;input&gt;</code>:"
              },
              {
                "type": "paragraph",
                "content": "Los campos de formulario no necesariamente tienen que aparecer en una etiqueta <code>&lt;form&gt;</code>. Puedes ponerlos en cualquier parte de una página. Campos sin formulario no pueden ser enviados (solo un formulario en su totalidad puede), pero al responder a la entrada con JavaScript, a menudo no queremos enviar nuestros campos de forma normal de todos modos."
              },
              {
                "type": "paragraph",
                "content": "La interfaz de JavaScript para estos elementos difiere según el tipo de elemento."
              }
            ]
          },
          {
            "id": "ch18-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los campos de texto de varias líneas tienen su propia etiqueta, <code>&lt;textarea&gt;</code>, principalmente porque sería incómodo utilizar un atributo para especificar un valor de inicio de varias líneas. La etiqueta <code>&lt;textarea&gt;</code> requiere una etiqueta de cierre <code>&lt;/<wbr>textarea&gt;</code> coincidente y utiliza el texto entre esas dos etiquetas, en lugar del atributo <code>valor</code>, como texto de inicio."
              },
              {
                "type": "paragraph",
                "content": "Finalmente, la etiqueta <code>&lt;select&gt;</code> se usa para crear un campo que permite al usuario seleccionar de varias opciones predefinidas."
              },
              {
                "type": "paragraph",
                "content": "Cada vez que cambia el valor de un campo de formulario, se desencadenará un evento <code>\"cambio\"</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch18-l8",
        "title": "Enfoque",
        "sections": [
          {
            "id": "ch18-l8-s0",
            "title": "Enfoque",
            "content": [
              {
                "type": "paragraph",
                "content": "A diferencia de la mayoría de elementos en documentos HTML, los campos de formulario pueden obtener <em>enfoque de teclado</em>. Cuando se hace clic, se mueve con la tecla <span class=\"keyname\">tab</span>, o se activa de alguna otra manera, se convierten en el elemento activo actual y en el receptor de la entrada de teclado."
              },
              {
                "type": "paragraph",
                "content": "Por lo tanto, puedes escribir en un campo de texto solo cuando está enfocado. Otros campos responden diferentemente a los eventos de teclado. Por ejemplo, un menú <code>&lt;select&gt;</code> intenta moverse a la opción que contiene el texto que el usuario escribió y responde a las teclas de flecha moviendo su selección hacia arriba y hacia abajo."
              },
              {
                "type": "paragraph",
                "content": "Podemos controlar el focus desde JavaScript con los métodos <code>focus</code> y <code>blur</code>. El primero mueve el enfoque al elemento del DOM en el que se llama, y el segundo elimina el enfoque. El valor en <code>document.<wbr>activeElement</code> corresponde al elemento actualmente enfocado."
              }
            ]
          },
          {
            "id": "ch18-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para algunas páginas, se espera que el usuario desee interactuar inmediatamente con un campo de formulario. JavaScript se puede utilizar para enfocar este campo cuando se carga el documento, pero HTML también proporciona el atributo <code>autofocus</code>, que produce el mismo efecto al mismo tiempo que le indica al navegador lo que estamos tratando de lograr. Esto le da al navegador la opción de deshabilitar el comportamiento cuando no es apropiado, como cuando el usuario ha puesto el enfoque en otra parte."
              },
              {
                "type": "paragraph",
                "content": "Los navegadores permiten al usuario mover el enfoque a través del documento presionando la tecla <span class=\"keyname\">tab</span> para pasar al siguiente elemento enfocable, y <span class=\"keyname\">shift-tab</span> para retroceder al elemento anterior. Por defecto, los elementos se visitan en el orden en que aparecen en el documento. Es posible usar el atributo <code>tabindex</code> para cambiar este orden. El siguiente ejemplo de documento permitirá que el enfoque salte del campo de texto al botón OK, en lugar de pasar primero por el enlace de ayuda:"
              },
              {
                "type": "paragraph",
                "content": "Por defecto, la mayoría de los tipos de elementos HTML no pueden ser enfocados. Pero se puede agregar un atributo <code>tabindex</code> a cualquier elemento para hacerlo enfocable. Un <code>tabindex</code> de 0 hace que un elemento sea enfocable sin afectar el orden de enfoque."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l9",
        "title": "Campos deshabilitados",
        "sections": [
          {
            "id": "ch18-l9-s0",
            "title": "Campos deshabilitados",
            "content": [
              {
                "type": "paragraph",
                "content": "Todos los campos de formulario pueden ser <em>deshabilitados</em> a través de su atributo <code>disabled</code>. Es un atributo que se puede especificar sin valor; el simple hecho de que esté presente deshabilita el elemento."
              },
              {
                "type": "paragraph",
                "content": "Los campos deshabilitados no pueden ser enfocardos ni modificados, y los navegadores los muestran de color gris y atenuados."
              },
              {
                "type": "paragraph",
                "content": "Cuando un programa está en proceso de manejar una acción provocada por algún botón u otro control que podría requerir comunicación con el servidor y por lo tanto llevar un tiempo, puede ser una buena idea deshabilitar el control hasta que la acción haya terminado. De esta forma, cuando el usuario se impaciente y hace clic nuevamente, no repiten accidentalmente su acción."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch18-l10",
        "title": "El formulario en su totalidad",
        "sections": [
          {
            "id": "ch18-l10-s0",
            "title": "El formulario en su totalidad",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando un field está contenido en un elemento <code>&lt;form&gt;</code>, su elemento DOM tendrá una propiedad <code>form</code> que enlaza de vuelta al elemento DOM del formulario. El elemento <code>&lt;form&gt;</code>, a su vez, tiene una propiedad llamada <code>elements</code> que contiene una colección similar a un array de los campos dentro de él."
              },
              {
                "type": "paragraph",
                "content": "El atributo <code>name</code> de un campo de formulario determina la forma en que se identificará su valor cuando se submitee el formulario. También se puede utilizar como nombre de propiedad al acceder a la propiedad <code>elements</code> del formulario, la cual actúa tanto como un objeto similar a un array (accesible por número) como un mapa (accesible por nombre)."
              },
              {
                "type": "paragraph",
                "content": "Un botón con un atributo <code>type</code> de <code>submit</code> hará que, al presionarlo, se submita el formulario. Presionar <span class=\"keyname\">enter</span> cuando un campo de formulario está enfocado tendrá el mismo efecto."
              }
            ]
          },
          {
            "id": "ch18-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Enviar un formulario normalmente significa que el navegador se dirige a la página indicada por el atributo <code>action</code> del formulario, utilizando ya sea una solicitud <code>GET</code> o <code>POST</code>. Pero antes de que eso ocurra, se dispara un evento <code>\"submit\"</code>. Puedes manejar este evento con JavaScript y prevenir este comportamiento por defecto llamando a <code>preventDefault</code> en el objeto de evento."
              },
              {
                "type": "paragraph",
                "content": "Interceptar los eventos <code>\"submit\"</code> en JavaScript tiene varios usos. Podemos escribir código para verificar que los valores ingresados por el usuario tengan sentido y mostrar inmediatamente un mensaje de error en lugar de enviar el formulario. O podemos deshabilitar completamente la forma regular de enviar el formulario, como en el ejemplo, y hacer que nuestro programa maneje la entrada, posiblemente utilizando <code>fetch</code> para enviarla a un servidor sin recargar la página."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l11",
        "title": "Campos de texto",
        "sections": [
          {
            "id": "ch18-l11-s0",
            "title": "Campos de texto",
            "content": [
              {
                "type": "paragraph",
                "content": "Los campos creados por etiquetas <code>&lt;textarea&gt;</code>, o etiquetas <code>&lt;input&gt;</code> con un tipo de <code>text</code> o <code>password</code>, comparten una interfaz común. Sus elementos DOM tienen una propiedad <code>value</code> que contiene su contenido actual como un valor de cadena. Establecer esta propiedad a otra cadena cambia el contenido del campo."
              },
              {
                "type": "paragraph",
                "content": "Las propiedades <code>selectionStart</code> y <code>selectionEnd</code> de los campos de texto nos brindan información sobre la posición del cursor y la selección en el texto. Cuando no se ha seleccionado nada, estas dos propiedades contienen el mismo número, indicando la posición del cursor. Por ejemplo, 0 indica el inicio del texto, y 10 indica que el cursor está después del 10<sup>º</sup> carácter. Cuando se selecciona parte del campo, las dos propiedades serán diferentes, dándonos el inicio y el final del texto seleccionado. Al igual que <code>value</code>, estas propiedades también se pueden escribir."
              },
              {
                "type": "paragraph",
                "content": "Imagina que estás escribiendo un artículo sobre Khasekhemwy pero tienes problemas para deletrear su nombre. El siguiente código vincula una etiqueta <code>&lt;textarea&gt;</code> con un controlador de eventos que, al presionar F2, inserta la cadena “Khasekhemwy” por ti."
              }
            ]
          },
          {
            "id": "ch18-l11-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>replaceSelection</code> reemplaza la parte actualmente seleccionada del contenido de un campo de texto con la palabra proporcionada y luego mueve el cursor después de esa palabra para que el usuario pueda continuar escribiendo."
              },
              {
                "type": "paragraph",
                "content": "El evento <code>\"change\"</code> para un campo de texto no se activa cada vez que se escribe algo. En cambio, se activa cuando el campo pierde el enfoque después de que su contenido haya cambiado. Para responder de inmediato a los cambios en un campo de texto, se debe registrar un controlador para el evento <code>\"input\"</code>, que se activa cada vez que el usuario escribe un carácter, elimina texto o de otra manera manipula el contenido del campo."
              },
              {
                "type": "paragraph",
                "content": "El siguiente ejemplo muestra un campo de texto y un contador que muestra la longitud actual del texto en el campo:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l12",
        "title": "Casillas de verificación y botones de radio",
        "sections": [
          {
            "id": "ch18-l12-s0",
            "title": "Casillas de verificación y botones de radio",
            "content": [
              {
                "type": "paragraph",
                "content": "Un campo de casilla de verificación es un interruptor binario. Su valor se puede extraer o cambiar a través de su propiedad <code>checked</code>, que contiene un valor Booleano."
              },
              {
                "type": "paragraph",
                "content": "La etiqueta <code>&lt;label&gt;</code> asocia un fragmento de documento con un campo de entrada. Hacer clic en cualquier parte de la etiqueta activará el campo, lo enfocará e invertirá su valor cuando sea un casilla de verificación o un botón de radio."
              },
              {
                "type": "paragraph",
                "content": "Un botón de radio es similar a una casilla de verificación, pero está vinculado implícitamente a otros botones de radio con el mismo atributo <code>name</code> para que solo uno de ellos pueda estar activo en cualquier momento."
              }
            ]
          },
          {
            "id": "ch18-l12-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los corchetes cuadrados en la consulta CSS proporcionada a <code>querySelectorAll</code> se utilizan para hacer coincidir atributos. Selecciona elementos cuyo atributo <code>name</code> es <code>\"color\"</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l13",
        "title": "Campos de selección",
        "sections": [
          {
            "id": "ch18-l13-s0",
            "title": "Campos de selección",
            "content": [
              {
                "type": "paragraph",
                "content": "Los campos de selección son conceptualmente similares a los botones de radio, ya que también permiten al usuario elegir entre un conjunto de opciones. Sin embargo, mientras que un botón de radio pone el diseño de las opciones bajo nuestro control, la apariencia de una etiqueta <code>&lt;select&gt;</code> está determinada por el navegador."
              },
              {
                "type": "paragraph",
                "content": "Los campos de selección también tienen una variante que se asemeja más a una lista de casillas de verificación que a botones de radio. Cuando se le otorga el atributo <code>multiple</code>, una etiqueta <code>&lt;select&gt;</code> permitirá al usuario seleccionar cualquier número de opciones, en lugar de una sola opción. Mientras que un campo de selección regular se muestra como un control de <em>lista desplegable</em>, que muestra las opciones inactivas solo cuando lo abres, un campo con <code>multiple</code> habilitado muestra múltiples opciones al mismo tiempo, permitiendo al usuario habilitar o deshabilitarlas individualmente."
              },
              {
                "type": "paragraph",
                "content": "Cada etiqueta <code>&lt;option&gt;</code> tiene un valor. Este valor se puede definir con un atributo <code>value</code>. Cuando este no se proporciona, el texto dentro de la opción se considerará como su valor. La propiedad <code>value</code> de un elemento <code>&lt;select&gt;</code> refleja la opción actualmente seleccionada. Sin embargo, para un campo <code>multiple</code>, esta propiedad no significa mucho, ya que dará el valor de solo <em>una</em> de las opciones actualmente seleccionadas."
              }
            ]
          },
          {
            "id": "ch18-l13-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las etiquetas <code>&lt;option&gt;</code> para un campo <code>&lt;select&gt;</code> pueden ser accedidas como un objeto similar a un array a través de la propiedad <code>options</code> del campo. Cada opción tiene una propiedad llamada <code>selected</code>, que indica si esa opción está actualmente seleccionada. La propiedad también se puede escribir para seleccionar o deseleccionar una opción."
              },
              {
                "type": "paragraph",
                "content": "Este ejemplo extrae los valores seleccionados de un campo de selección <code>multiple</code> y los utiliza para componer un número binario a partir de bits individuales. Mantén pulsado <span class=\"keyname\">control</span> (o <span class=\"keyname\">command</span> en un Mac) para seleccionar múltiples opciones."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch18-l14",
        "title": "Campos de archivo",
        "sections": [
          {
            "id": "ch18-l14-s0",
            "title": "Campos de archivo",
            "content": [
              {
                "type": "paragraph",
                "content": "Los campos de archivo fueron diseñados originalmente como una forma de subir archivos desde la máquina del usuario a través de un formulario. En los navegadores modernos, también proporcionan una forma de leer dichos archivos desde programas JavaScript. El campo actúa como una especie de guardián. El script no puede simplemente comenzar a leer archivos privados desde la computadora del usuario, pero si el usuario selecciona un archivo en dicho campo, el navegador interpreta esa acción como que el script puede leer el archivo."
              },
              {
                "type": "paragraph",
                "content": "Un campo de archivo suele parecerse a un botón etiquetado con algo como “elegir archivo” o “explorar”, con información sobre el archivo elegido al lado."
              },
              {
                "type": "paragraph",
                "content": "La propiedad <code>files</code> de un elemento campo de archivo es un objeto similar a un arreglo (una vez más, no es un arreglo real) que contiene los archivos elegidos en el campo. Inicialmente está vacío. La razón por la que no hay simplemente una propiedad <code>file</code> es que los campos de archivo también admiten un atributo <code>multiple</code>, lo que permite seleccionar varios archivos al mismo tiempo."
              }
            ]
          },
          {
            "id": "ch18-l14-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos en <code>files</code> tienen propiedades como <code>name</code> (el nombre de archivo), <code>size</code> (el tamaño del archivo en bytes, que son trozos de 8 bits) y <code>type</code> (el tipo de medio del archivo, como <code>text/plain</code> o <code>image/jpeg</code>)."
              },
              {
                "type": "paragraph",
                "content": "Lo que no tiene es una propiedad que contenga el contenido del archivo. Acceder a eso es un poco más complicado. Dado que leer un archivo desde el disco puede llevar tiempo, la interfaz es asíncrona para evitar que se congele la ventana."
              },
              {
                "type": "paragraph",
                "content": "La lectura de un archivo se realiza creando un objeto <code>FileReader</code>, registrando un controlador de eventos <code>\"load\"</code> para él y llamando a su método <code>readAsText</code>, dándole el archivo que queremos leer. Una vez que la carga finaliza, la propiedad <code>result</code> del lector contiene el contenido del archivo."
              }
            ]
          },
          {
            "id": "ch18-l14-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los <code>FileReader</code>s también disparan un evento <code>\"error\"</code> cuando la lectura del archivo falla por cualquier motivo. El objeto de error en sí terminará en la propiedad <code>error</code> del lector. Esta interfaz fue diseñada antes de que las promesas se convirtieran en parte del lenguaje. Podrías envolverlo en una promesa de la siguiente manera:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch18-l15",
        "title": "Almacenando datos del lado del cliente",
        "sections": [
          {
            "id": "ch18-l15-s0",
            "title": "Almacenando datos del lado del cliente",
            "content": [
              {
                "type": "paragraph",
                "content": "Páginas simples de HTML con un poco de JavaScript pueden ser un gran formato para “mini aplicaciones” - pequeños programas auxiliares que automatizan tareas básicas. Conectando unos cuantos campos de formulario con controladores de eventos, puedes hacer desde convertir entre centímetros y pulgadas hasta calcular contraseñas a partir de una contraseña maestra y un nombre de sitio web."
              },
              {
                "type": "paragraph",
                "content": "Cuando una aplicación así necesita recordar algo entre sesiones, no puedes usar las vinculaciones de JavaScript, ya que estas se descartan cada vez que se cierra la página. Podrías configurar un servidor, conectarlo a Internet y hacer que tu aplicación almacene algo allí. Veremos cómo hacerlo en el Capítulo 20. Pero eso implica mucho trabajo extra y complejidad. A veces es suficiente con mantener los datos en el navegador."
              },
              {
                "type": "paragraph",
                "content": "El objeto <code>localStorage</code> se puede utilizar para almacenar datos de una manera que sobreviva a las recargas de página. Este objeto te permite guardar valores de cadena bajo nombres."
              }
            ]
          },
          {
            "id": "ch18-l15-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un valor en <code>localStorage</code> permanece hasta que se sobrescribe, se elimina con <code>removeItem</code> o el usuario elimina sus datos locales."
              },
              {
                "type": "paragraph",
                "content": "Los sitios de diferentes dominios obtienen compartimentos de almacenamiento diferentes. Eso significa que los datos almacenados en <code>localStorage</code> por un sitio web dado, en principio, solo pueden ser leídos (y sobrescritos) por scripts en ese mismo sitio."
              },
              {
                "type": "paragraph",
                "content": "Los navegadores aplican un límite en el tamaño de los datos que un sitio puede almacenar en <code>localStorage</code>. Esta restricción, junto con el hecho de que llenar los discos duros de la gente con basura no es realmente rentable, evita que la función ocupe demasiado espacio."
              }
            ]
          },
          {
            "id": "ch18-l15-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente código implementa una aplicación rudimentaria de toma de notas. Mantiene un conjunto de notas con nombres y permite al usuario editar notas y crear nuevas."
              },
              {
                "type": "paragraph",
                "content": "El script obtiene su estado inicial del valor <code>\"Notas\"</code> almacenado en <code>localStorage</code> o, si está ausente, crea un estado de ejemplo que solo contiene una lista de compras. Leer un campo que no existe en <code>localStorage</code> devolverá <code>null</code>. Pasar <code>null</code> a <code>JSON.parse</code> hará que analice la cadena <code>\"null\"</code> y devuelva <code>null</code>. Por tanto, en una situación como esta se puede utilizar el operador <code>??</code> para proporcionar un valor predeterminado."
              },
              {
                "type": "paragraph",
                "content": "El método <code>setState</code> se asegura de que el DOM muestre un estado dado y almacena el nuevo estado en <code>localStorage</code>. Los controladores de eventos llaman a esta función para moverse a un nuevo estado."
              }
            ]
          },
          {
            "id": "ch18-l15-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La sintaxis <code>...</code> en el ejemplo se utiliza para crear un nuevo objeto que es un clon del antiguo <code>state.notes</code>, pero con una propiedad añadida o sobrescrita. Utiliza la sintaxis spread para primero añadir las propiedades del objeto antiguo y luego establecer una nueva propiedad. La notación de corchetes cuadrados en el literal del objeto se utiliza para crear una propiedad cuyo nombre se basa en algún valor dinámico."
              },
              {
                "type": "paragraph",
                "content": "Existe otro objeto, similar a <code>localStorage</code>, llamado <code>sessionStorage</code>. La diferencia entre los dos es que el contenido de <code>sessionStorage</code> se olvida al final de cada <em>sesión</em>, lo que en la mayoría de los navegadores significa cada vez que se cierra el navegador."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch18-l16",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch18-l16-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "En este capítulo, discutimos cómo funciona el protocolo HTTP. Un <em>cliente</em> envía una solicitud, que contiene un método (generalmente <code>GET</code>) y una ruta que identifica un recurso. El <em>servidor</em> luego decide qué hacer con la solicitud y responde con un código de estado y un cuerpo de respuesta. Tanto las solicitudes como las respuestas pueden contener encabezados que proporcionan información adicional.La interfaz a través de la cual JavaScript del navegador puede realizar solicitudes HTTP se llama <code>fetch</code>. Realizar una solicitud se ve así:"
              },
              {
                "type": "paragraph",
                "content": "Los navegadores hacen solicitudes <code>GET</code> para obtener los recursos necesarios para mostrar una página web. Una página también puede contener formularios, que permiten enviar información ingresada por el usuario como una solicitud de una nueva página cuando se envía el formulario."
              },
              {
                "type": "paragraph",
                "content": "HTML puede representar varios tipos de campos de formulario, como campos de texto, casillas de verificación, campos de selección múltiple y selectores de archivos."
              }
            ]
          },
          {
            "id": "ch18-l16-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Estos campos pueden ser inspeccionados y manipulados con JavaScript. Disparan el evento <code>\"change\"</code> al cambiar, disparan el evento <code>\"input\"</code> al escribir texto y reciben eventos del teclado cuando tienen el foco del teclado. Propiedades como <code>value</code> (para campos de texto y select) o <code>checked</code> (para casillas de verificación y botones de radio) se utilizan para leer o establecer el contenido del campo."
              },
              {
                "type": "paragraph",
                "content": "Cuando un formulario se envía, se dispara un evento <code>\"submit\"</code> en él. Un controlador de JavaScript puede llamar a <code>preventDefault</code> en ese evento para deshabilitar el comportamiento predeterminado del navegador. Los elementos de campo de formulario también pueden ocurrir fuera de una etiqueta de formulario."
              },
              {
                "type": "paragraph",
                "content": "Cuando el usuario ha seleccionado un archivo de su sistema de archivos local en un campo de selección de archivos, la interfaz <code>FileReader</code> se puede utilizar para acceder al contenido de este archivo desde un programa JavaScript."
              }
            ]
          },
          {
            "id": "ch18-l16-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos <code>localStorage</code> y <code>sessionStorage</code> se pueden usar para guardar información de una manera que sobrevive a las recargas de la página. El primer objeto guarda los datos para siempre (o hasta que el usuario decida borrarlos) y el segundo los guarda hasta que se cierra el navegador."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch18-l17",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch18-l17-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Una de las cosas que HTTP puede hacer es la <em>negociación de contenido</em>. El encabezado de solicitud <code>Accept</code> se utiliza para indicar al servidor qué tipo de documento le gustaría obtener al cliente. Muchos servidores ignoran este encabezado, pero cuando un servidor conoce diversas formas de codificar un recurso, puede mirar este encabezado y enviar la que el cliente prefiera."
              },
              {
                "type": "paragraph",
                "content": "La URL <em>https://eloquentjavascript.net/author</em> está configurada para responder ya sea con texto sin formato, HTML o JSON, dependiendo de lo que pida el cliente. Estos formatos están identificados por los <em>tipos de medios</em> estandarizados <code>text/plain</code>, <code>text/html</code> y <code>application/json</code>."
              },
              {
                "type": "paragraph",
                "content": "Envía solicitudes para obtener los tres formatos de este recurso. Utiliza la propiedad <code>headers</code> en el objeto de opciones pasado a <code>fetch</code> para establecer el encabezado llamado <code>Accept</code> en el tipo de medios deseado."
              }
            ]
          },
          {
            "id": "ch18-l17-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Finalmente, intenta pedir el tipo de medios <code>application/<wbr>rainbows+unicorns</code> y mira qué código de estado produce."
              },
              {
                "type": "paragraph",
                "content": "Basate en los ejemplos de <code>fetch</code> anteriores en el capítulo."
              },
              {
                "type": "paragraph",
                "content": "Al solicitar un tipo de medio falso devolverá una respuesta con el código 406, “No aceptable”, que es el código que un servidor debería devolver cuando no puede cumplir con el encabezado <code>Accept</code>."
              }
            ]
          },
          {
            "id": "ch18-l17-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Construye una interfaz que permita a las personas escribir y ejecutar fragmentos de código JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Coloca un botón al lado de un campo <code>&lt;textarea&gt;</code> que, al ser presionado, utilice el constructor <code>Function</code> que vimos en el Capítulo 10 para envolver el texto en una función y llamarla. Convierte el valor de retorno de la función, o cualquier error que genere, a una cadena y muéstralo debajo del campo de texto."
              },
              {
                "type": "paragraph",
                "content": "Utiliza <code>document.<wbr>querySelector</code> o <code>document.<wbr>getElementById</code> para acceder a los elementos definidos en tu HTML. Un manejador de eventos para eventos <code>\"click\"</code> o <code>\"mousedown\"</code> en el botón puede obtener la propiedad <code>value</code> del campo de texto y llamar a <code>Function</code> en él."
              }
            ]
          },
          {
            "id": "ch18-l17-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Asegúrate de envolver tanto la llamada a <code>Function</code> como la llamada a su resultado en un bloque <code>try</code> para poder capturar las excepciones que produce. En este caso, realmente no sabemos qué tipo de excepción estamos buscando, así que captura todo."
              },
              {
                "type": "paragraph",
                "content": "La propiedad <code>textContent</code> del elemento de salida se puede utilizar para llenarlo con un mensaje de cadena. O, si deseas mantener el contenido anterior, crea un nuevo nodo de texto utilizando <code>document.<wbr>createTextNode</code> y apéndelo al elemento. Recuerda agregar un carácter de nueva línea al final para que no aparezca toda la salida en una sola línea."
              },
              {
                "type": "paragraph",
                "content": "El Juego de la vida de Conway es una simulación simple que crea “vida” artificial en una rejilla, donde cada celda puede estar viva o no. En cada generación (turno), se aplican las siguientes reglas:"
              }
            ]
          },
          {
            "id": "ch18-l17-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "list",
                "content": [
                  "Cualquier celda viva con menos de dos o más de tres vecinos vivos muere.",
                  "Cualquier celda viva con dos o tres vecinos vivos sigue viva en la siguiente generación.",
                  "Cualquier celda muerta con exactamente tres vecinos vivos se convierte en una celda viva."
                ]
              },
              {
                "type": "paragraph",
                "content": "Un <em>vecino</em> se define como cualquier celda adyacente, incluidas las células adyacentes en diagonal."
              },
              {
                "type": "paragraph",
                "content": "Ten en cuenta que estas reglas se aplican a toda la rejilla de una vez, no cuadrado por cuadrado. Eso significa que el recuento de vecinos se basa en la situación al comienzo de la generación, y los cambios que ocurran en las células vecinas durante esta generación no deberían influir en el nuevo estado de una celda dada."
              }
            ]
          },
          {
            "id": "ch18-l17-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Implementa este juego utilizando la estructura de datos que consideres apropiada. Utiliza <code>Math.random</code> para poblar la rejilla con un patrón aleatorio inicialmente. Muestra la rejilla como una cuadrícula de campo de verificación campos, con un botón al lado para avanzar a la siguiente generación. Cuando el usuario marque o desmarque los campos de verificación, sus cambios deberían incluirse al calcular la siguiente generación."
              },
              {
                "type": "paragraph",
                "content": "Para resolver el problema de que los cambios ocurran conceptualmente al mismo tiempo, intenta ver la computación de una generación como una función pura, la cual toma un grid y produce un nuevo grid que representa el siguiente turno."
              },
              {
                "type": "paragraph",
                "content": "La representación de la matriz se puede hacer con un solo array de elementos de ancho × alto, almacenando valores fila por fila, por lo que, por ejemplo, el tercer elemento en la quinta fila se almacena en la posición 4 × <em>ancho</em> + 2 (usando indexación basada en cero). Puedes contar los vecinos vivos con dos bucles anidados, recorriendo coordenadas adyacentes en ambas dimensiones. Asegúrate de no contar celdas fuera del campo e ignorar la celda en el centro, cuyos vecinos estamos contando."
              }
            ]
          },
          {
            "id": "ch18-l17-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Asegurarse de que los cambios en los checkbox tengan efecto en la siguiente generación se puede hacer de dos maneras. Un manejador de eventos podría notar estos cambios y actualizar el grid actual para reflejarlos, o podrías generar un grid nuevo a partir de los valores de los checkboxes antes de calcular el siguiente turno."
              },
              {
                "type": "paragraph",
                "content": "Si decides utilizar manejadores de eventos, es posible que desees adjuntar atributos que identifiquen la posición a la que corresponde cada checkbox para que sea fácil saber qué celda cambiar."
              },
              {
                "type": "paragraph",
                "content": "Para dibujar el grid de checkboxes, puedes usar un elemento <code>&lt;table&gt;</code> (ver Capítulo 14) o simplemente colocar todos en el mismo elemento y poner elementos <code>&lt;br&gt;</code> (salto de línea) entre las filas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      }
    ]
  },
  {
    "id": "ch19",
    "number": 19,
    "title": "Proyecto: Editor de Arte Pixelado",
    "titleEs": "Proyecto: Editor de Arte Pixelado",
    "part": "part2",
    "partLabel": "Parte 2: Navegador",
    "icon": "BookOpen",
    "description": "Observo los muchos colores ante mí. Observo mi lienzo en blanco. Luego, intento aplicar colores como palabras que conforman poemas, como notas que con...",
    "isProject": true,
    "totalXP": 425,
    "lessons": [
      {
        "id": "ch19-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch19-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Observo los muchos colores ante mí. Observo mi lienzo en blanco. Luego, intento aplicar colores como palabras que conforman poemas, como notas que conforman música. Joan Miro"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Editor de Arte Pixelado __ Eloquent JavaScript_files/chapter_picture_19.jpg",
                "alt": "Ilustración que muestra un mosaico de baldosas negras, con tarros de otras baldosas junto a él"
              },
              {
                "type": "paragraph",
                "content": "El material de los capítulos anteriores te brinda todos los elementos que necesitas para construir una aplicación web básica. En este capítulo, haremos precisamente eso."
              }
            ]
          },
          {
            "id": "ch19-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Nuestra aplicación será un programa de dibujo de pixeles, donde puedes modificar una imagen píxel por píxel manipulando una vista ampliada de la misma, mostrada como una rejilla de cuadros de colores. Puedes utilizar el programa para abrir archivos de imagen, garabatear en ellos con tu ratón u otro dispositivo señalador, y guardarlos. Así es cómo se verá:"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Editor de Arte Pixelado __ Eloquent JavaScript_files/pixel_editor.png",
                "alt": "Captura de pantalla de la interfaz del editor de píxeles, con una rejilla de píxeles de colores en la parte superior y una serie de controles, en forma de campos y botones HTML, debajo de eso"
              },
              {
                "type": "paragraph",
                "content": "Pintar en una computadora es genial. No necesitas preocuparte por materiales, habilidad o talento. Simplemente comienzas a manchar y ves hacia dónde llegas."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch19-l1",
        "title": "Componentes",
        "sections": [
          {
            "id": "ch19-l1-s0",
            "title": "Componentes",
            "content": [
              {
                "type": "paragraph",
                "content": "La interfaz de la aplicación muestra un gran elemento <code>&lt;canvas&gt;</code> en la parte superior, con varios formularios debajo de él. El usuario dibuja en la imagen seleccionando una herramienta de un campo <code>&lt;select&gt;</code> y luego haciendo clic, tocando o arrastrando sobre el lienzo. Hay herramientas para dibujar píxeles individuales o rectángulos, para rellenar un área y para seleccionar un color de la imagen."
              },
              {
                "type": "paragraph",
                "content": "Estructuraremos la interfaz del editor como un conjunto de <em>componentes</em>, objetos responsables de una parte del DOM y que pueden contener otros componentes dentro de ellos."
              },
              {
                "type": "paragraph",
                "content": "El estado de la aplicación consiste en la imagen actual, la herramienta seleccionada y el color seleccionado. Organizaremos las cosas de manera que el estado resida en un único valor, y los componentes de la interfaz siempre se basen en el estado actual para verse."
              }
            ]
          },
          {
            "id": "ch19-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para entender por qué esto es importante, consideremos la alternativa: distribuir piezas de estado a lo largo de la interfaz. Hasta cierto punto, esto es más fácil de programar. Podemos simplemente agregar un campo de color y leer su valor cuando necesitemos saber el color actual."
              },
              {
                "type": "paragraph",
                "content": "Pero luego agregamos el selector de colores —una herramienta que te permite hacer clic en la imagen para seleccionar el color de un píxel determinado. Para mantener el campo de color mostrando el color correcto, esa herramienta tendría que saber que el campo de color existe y actualizarlo cada vez que elige un nuevo color. Si alguna vez añades otro lugar que muestre el color (quizás el cursor del ratón podría mostrarlo), tendrías que actualizar tu código de cambio de color para mantener eso sincronizado también."
              },
              {
                "type": "paragraph",
                "content": "De hecho, esto crea un problema en el que cada parte de la interfaz necesita saber acerca de todas las demás partes, lo cual no es muy modular. Para aplicaciones pequeñas como la de este capítulo, eso puede no ser un problema. Para proyectos más grandes, puede convertirse en una verdadera pesadilla."
              }
            ]
          },
          {
            "id": "ch19-l1-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para evitar esta pesadilla en principio, vamos a ser estrictos acerca del <em>flujo de datos</em>. Hay un estado, y la interfaz se dibuja basada en ese estado. Un componente de la interfaz puede responder a las acciones del usuario actualizando el estado, momento en el cual los componentes tienen la oportunidad de sincronizarse con este nuevo estado."
              },
              {
                "type": "paragraph",
                "content": "En la práctica, cada componente se configura para que, cuando reciba un nuevo estado, también notifique a sus componentes hijos, en la medida en que estos necesiten ser actualizados. Configurar esto es un poco tedioso. Hacer que esto sea más conveniente es el principal punto de venta de muchas bibliotecas de programación para el navegador. Pero para una aplicación pequeña como esta, podemos hacerlo sin dicha infraestructura."
              },
              {
                "type": "paragraph",
                "content": "Las actualizaciones al estado se representan como objetos, a los que llamaremos <em>acciones</em>. Los componentes pueden crear tales acciones y <em>despachar</em> (enviarlos) a una función central de gestión de estado. Esa función calcula el próximo estado, tras lo cual los componentes de la interfaz se actualizan a este nuevo estado."
              }
            ]
          },
          {
            "id": "ch19-l1-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Estamos tomando la tarea desordenada de ejecutar una interfaz de usuario y aplicándole estructura. Aunque las piezas relacionadas con el DOM aún están llenas de efectos secundarios, están respaldadas por un esqueleto conceptualmente simple: el ciclo de actualización de estado. El estado determina cómo se ve el DOM, y la única forma en que los eventos del DOM pueden cambiar el estado es despachando acciones al estado."
              },
              {
                "type": "paragraph",
                "content": "Hay <em>muchas</em> variantes de este enfoque, cada una con sus propios beneficios y problemas, pero su idea central es la misma: los cambios de estado deben pasar por un canal único y bien definido, no suceder por todas partes."
              },
              {
                "type": "paragraph",
                "content": "Nuestros componentes serán clases que cumplan con una interfaz. Su constructor recibe un estado, que puede ser el estado de toda la aplicación o algún valor más pequeño si no necesita acceso a todo, y lo utiliza para construir una propiedad <code>dom</code>. Este es el elemento DOM que representa el componente. La mayoría de los constructores también tomarán otros valores que no cambiarán con el tiempo, como la función que pueden utilizar para despachar una acción."
              }
            ]
          },
          {
            "id": "ch19-l1-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cada componente tiene un método <code>syncState</code> que se utiliza para sincronizarlo con un nuevo valor de estado. El método recibe un argumento, que es el estado, del mismo tipo que el primer argumento de su constructor."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 45
      },
      {
        "id": "ch19-l2",
        "title": "El estado",
        "sections": [
          {
            "id": "ch19-l2-s0",
            "title": "El estado",
            "content": [
              {
                "type": "paragraph",
                "content": "El estado de la aplicación será un objeto con las propiedades <code>imagen</code>, <code>herramienta</code> y <code>color</code>. La imagen es en sí misma un objeto que almacena el ancho, alto y contenido de píxeles de la imagen. Los píxels se almacenan en un solo array, fila por fila, de arriba abajo."
              },
              {
                "type": "paragraph",
                "content": "Queremos poder tratar una imagen como un valor inmutable por razones que revisaremos más adelante en el capítulo. Pero a veces necesitamos actualizar todo un conjunto de píxeles a la vez. Para poder hacerlo, la clase tiene un método <code>draw</code> que espera un array de píxeles actualizados, objetos con propiedades <code>x</code>, <code>y</code> y <code>color</code>, y crea una nueva imagen con esos píxeles sobrescritos. Este método utiliza <code>slice</code> sin argumentos para copiar todo el array de píxeles - el inicio de la rebanada predetermina a 0, y el final predetermina a la longitud del array."
              },
              {
                "type": "paragraph",
                "content": "El método <code>empty</code> utiliza dos funcionalidades de array que no hemos visto antes. El constructor <code>Array</code> se puede llamar con un número para crear un array vacío de la longitud dada. El método <code>fill</code> se puede usar para llenar este array con un valor dado. Se utilizan para crear un array en el que todos los píxeles tienen el mismo color."
              }
            ]
          },
          {
            "id": "ch19-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los colores se almacenan como cadenas que contienen códigos de colores CSS tradicionales compuestos por un signo de almohadilla (<code>#</code>) seguido de seis dígitos hexadecimales (base-16) - dos para el componente rojo, dos para el componente verde y dos para el componente azul. Esta es una forma algo críptica e incómoda de escribir colores, pero es el formato que utiliza el campo de entrada de color HTML, y se puede usar en la propiedad <code>fillStyle</code> de un contexto de dibujo de lienzo, por lo que para las formas en que usaremos colores en este programa, es lo bastante práctico."
              },
              {
                "type": "paragraph",
                "content": "El negro, donde todos los componentes son cero, se escribe como <code>\"#000000\"</code>, y el rosa brillante se ve como <code>\"#ff00ff\"</code>, donde los componentes rojo y azul tienen el valor máximo de 255, escrito <code>ff</code> en dígitos hexadecimales (que utilizan <em>a</em> a <em>f</em> para representar los dígitos 10 al 15)."
              },
              {
                "type": "paragraph",
                "content": "Permitiremos que la interfaz envíe acciones como objetos cuyas propiedades sobrescriben las propiedades del estado anterior. El campo de color, cuando el usuario lo cambia, podría enviar un objeto como <code>{color: field.<wbr>value}</code>, a partir del cual esta función de actualización puede calcular un nuevo estado."
              }
            ]
          },
          {
            "id": "ch19-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este patrón, en el que el operador de spread de objetos se utiliza primero para agregar las propiedades de un objeto existente y luego para anular algunas de ellas, es común en el código de JavaScript que utiliza objetos inmutables."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch19-l3",
        "title": "Construcción del DOM",
        "sections": [
          {
            "id": "ch19-l3-s0",
            "title": "Construcción del DOM",
            "content": [
              {
                "type": "paragraph",
                "content": "Una de las principales funciones que cumplen los componentes de la interfaz es crear una estructura DOM. Nuevamente, no queremos utilizar directamente los métodos verbosos del DOM para eso, así que aquí tienes una versión ligeramente ampliada de la función <code>elt</code>:"
              },
              {
                "type": "paragraph",
                "content": "La diferencia principal entre esta versión y la que usamos en el Capítulo 16 es que asigna <em>propiedades</em> a los nodos del DOM, no <em>atributos</em>. Esto significa que no podemos usarlo para establecer atributos arbitrarios, pero <em>sí</em> podemos usarlo para configurar propiedades cuyo valor no es una cadena, como <code>onclick</code>, que se puede establecer como una función para registrar un controlador de eventos de clic."
              },
              {
                "type": "paragraph",
                "content": "Esto permite este estilo conveniente para registrar manejadores de eventos:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch19-l4",
        "title": "El lienzo",
        "sections": [
          {
            "id": "ch19-l4-s0",
            "title": "El lienzo",
            "content": [
              {
                "type": "paragraph",
                "content": "El primer componente que definiremos es la parte de la interfaz que muestra la imagen como una cuadrícula de cuadros coloreados. Este componente es responsable de dos cosas: mostrar una imagen y comunicar evento de punteros en esa imagen al resto de la aplicación."
              },
              {
                "type": "paragraph",
                "content": "Como tal, podemos definirlo como un componente que solo conoce la imagen actual, no todo el estado de la aplicación. Dado que no sabe cómo funciona la aplicación en su totalidad, no puede despachar acciónes directamente. Más bien, al responder a eventos de puntero, llama a una función de devolución de llamada proporcionada por el código que lo creó, que se encargará de las partes específicas de la aplicación."
              },
              {
                "type": "paragraph",
                "content": "Dibujamos cada píxel como un cuadrado de 10 por 10, según lo determinado por la constante <code>scale</code>. Para evitar trabajo innecesario, el componente realiza un seguimiento de su imagen actual y solo vuelve a dibujar cuando se le proporciona una nueva imagen a <code>syncState</code>."
              }
            ]
          },
          {
            "id": "ch19-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función de dibujo real establece el tamaño del lienzo en función de la escala y el tamaño de la imagen y lo llena con una serie de cuadrados, uno para cada píxel."
              },
              {
                "type": "paragraph",
                "content": "Cuando se presiona el botón izquierdo del mouse mientras está sobre el lienzo de la imagen, el componente llama al callback <code>pointerDown</code>, dándole la posición del píxel que se hizo clic, en coordenadas de la imagen. Esto se usará para implementar la interacción del mouse con la imagen. El callback puede devolver otra función de callback para ser notificado cuando se mueve el puntero a un píxel diferente mientras se mantiene presionado el botón."
              },
              {
                "type": "paragraph",
                "content": "Dado que conocemos el tamaño de los píxeles y podemos usar <code>getBoundingClientRect</code> para encontrar la posición del lienzo en la pantalla, es posible ir desde las coordenadas del evento del mouse (<code>clientX</code> y <code>clientY</code>) hasta las coordenadas de la imagen. Estas siempre se redondean hacia abajo para que se refieran a un píxel específico."
              }
            ]
          },
          {
            "id": "ch19-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Con eventos táctiles, tenemos que hacer algo similar, pero utilizando diferentes eventos y asegurándonos de llamar a <code>preventDefault</code> en el evento <code>\"touchstart\"</code> para evitar el desplazamiento."
              },
              {
                "type": "paragraph",
                "content": "Para eventos táctiles, <code>clientX</code> y <code>clientY</code> no están disponibles directamente en el objeto de evento, pero podemos usar las coordenadas del primer objeto táctil en la propiedad <code>touches</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch19-l5",
        "title": "La aplicación",
        "sections": [
          {
            "id": "ch19-l5-s0",
            "title": "La aplicación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para hacer posible construir la aplicación pieza por pieza, implementaremos el componente principal como una cáscara alrededor de un lienzo de imagen y un conjunto dinámico de tools y controls que pasamos a su constructor."
              },
              {
                "type": "paragraph",
                "content": "Los <em>controles</em> son los elementos de interfaz que aparecen debajo de la imagen. Se proporcionarán como un array de constructores de component."
              },
              {
                "type": "paragraph",
                "content": "Las <em>herramientas</em> hacen cosas como dibujar píxeles o rellenar un área. La aplicación muestra el conjunto de herramientas disponibles como un campo <code>&lt;select&gt;</code>. La herramienta actualmente seleccionada determina qué sucede cuando el usuario interactúa con la imagen con un dispositivo puntero. El conjunto de herramientas disponibles se proporciona como un objeto que mapea los nombres que aparecen en el campo desplegable a funciones que implementan las herramientas. Dichas funciones reciben como argumentos una posición de imagen, un estado de aplicación actual y una función <code>dispatch</code>. Pueden devolver una función manejadora de movimiento que se llama con una nueva posición y un estado actual cuando el puntero se mueve a un píxel diferente."
              }
            ]
          },
          {
            "id": "ch19-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El manejador de puntero dado a <code>PictureCanvas</code> llama a la herramienta actualmente seleccionada con los argumentos apropiados y, si eso devuelve un manejador de movimiento, lo adapta para también recibir el estado."
              },
              {
                "type": "paragraph",
                "content": "Todos los controles se construyen y almacenan en <code>this.controls</code> para que puedan actualizarse cuando cambie el estado de la aplicación. La llamada a <code>reduce</code> introduce espacios entre los elementos DOM de los controles. De esa manera, no se ven tan juntos."
              },
              {
                "type": "paragraph",
                "content": "El primer control es el menú de selección de tool. Crea un elemento <code>&lt;select&gt;</code> con una opción para cada herramienta y configura un manejador de evento <code>\"change\"</code> que actualiza el estado de la aplicación cuando el usuario selecciona una herramienta diferente."
              }
            ]
          },
          {
            "id": "ch19-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Al envolver el texto de la etiqueta y el campo en un elemento <code>&lt;label&gt;</code>, le decimos al navegador que la etiqueta pertenece a ese campo para que, por ejemplo, se pueda hacer clic en la etiqueta para enfocar el campo."
              },
              {
                "type": "paragraph",
                "content": "También necesitamos poder cambiar el color, así que agreguemos un control para eso. Un elemento HTML <code>&lt;input&gt;</code> con un atributo <code>type</code> de <code>color</code> nos brinda un campo de formulario especializado para seleccionar colores. El valor de dicho campo siempre es un código de color CSS en formato <code>\"#RRGGBB\"</code> (componentes rojo, verde y azul, dos dígitos por color). El navegador mostrará una interfaz de selector de color cuando el usuario interactúe con él."
              },
              {
                "type": "paragraph",
                "content": "Este control crea un campo de ese tipo y lo conecta para que se mantenga sincronizado con la propiedad <code>color</code> del estado de la aplicación."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch19-l6",
        "title": "Herramientas de dibujo",
        "sections": [
          {
            "id": "ch19-l6-s0",
            "title": "Herramientas de dibujo",
            "content": [
              {
                "type": "paragraph",
                "content": "Antes de poder dibujar algo, necesitamos implementar las herramientas que controlarán la funcionalidad de eventos de ratón o táctiles en el lienzo."
              },
              {
                "type": "paragraph",
                "content": "La herramienta más básica es la herramienta de dibujo, que cambia cualquier píxel en el que hagas clic o toques al color seleccionado actualmente. Envía una acción que actualiza la imagen a una versión en la que el píxel señalado recibe el color seleccionado actualmente."
              },
              {
                "type": "paragraph",
                "content": "La función llama inmediatamente a la función <code>drawPixel</code>, pero también la devuelve para que sea llamada nuevamente para los píxeles recién tocados cuando el usuario arrastra o desliza sobre la imagen."
              }
            ]
          },
          {
            "id": "ch19-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para dibujar formas más grandes, puede ser útil crear rápidamente rectángulos. La herramienta <code>rectángulo</code> dibuja un rectángulo entre el punto donde comienzas a arrastrar y el punto al que arrastras."
              },
              {
                "type": "paragraph",
                "content": "Un detalle importante en esta implementación es que al arrastrar, el rectángulo se vuelve a dibujar en la imagen a partir del estado <em>original</em>. De esta manera, puedes hacer que el rectángulo sea más grande o más pequeño nuevamente mientras lo creas, sin que los rectángulos intermedios queden pegados en la imagen final. Esta es una de las razones por las que los objetos de imagen inmutables son útiles; veremos otra razón más adelante."
              },
              {
                "type": "paragraph",
                "content": "Implementar el relleno por inundación es algo más complejo. Se trata de una herramienta que llena el píxel bajo el puntero y todos los píxeles adyacentes que tengan el mismo color. “Adyacente” significa adyacente directamente en horizontal o vertical, no diagonalmente. Esta imagen ilustra el conjunto de píxeles coloreados cuando se utiliza la herramienta de relleno por inundación en el píxel marcado:"
              }
            ]
          },
          {
            "id": "ch19-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Editor de Arte Pixelado __ Eloquent JavaScript_files/flood-grid.svg",
                "alt": "Diagrama de una cuadrícula de píxeles que muestra el área llenada por una operación de relleno por inundación"
              },
              {
                "type": "paragraph",
                "content": "Curiosamente, la forma en que lo haremos se parece un poco al código de búsqueda de caminos del Capítulo 7. Mientras que ese código buscaba a través de un grafo para encontrar una ruta, este código busca a través de una cuadrícula para encontrar todos los píxeles “conectados”. El problema de llevar un conjunto ramificado de rutas posibles es similar."
              },
              {
                "type": "paragraph",
                "content": "El array de píxeles dibujados funciona como la lista de trabajo de la función. Para cada píxel alcanzado, tenemos que ver si algún píxel adyacente tiene el mismo color y aún no ha sido pintado. El contador del bucle va rezagado respecto a la longitud del array <code>dibujados</code> a medida que se añaden nuevos píxeles. Cualquier píxel por delante de él aún necesita ser explorado. Cuando alcanza la longitud, no quedan píxeles sin explorar y la función termina."
              }
            ]
          },
          {
            "id": "ch19-l6-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La última herramienta es un selector de color, que te permite apuntar a un color en la imagen para usarlo como color de dibujo actual."
              },
              {
                "type": "paragraph",
                "content": "El componente lleva un registro de la imagen actual para que pueda acceder a ella al guardar. Para crear el archivo de imagen, utiliza un elemento <code>&lt;canvas&gt;</code> en el que dibuja la imagen (a una escala de un píxel por píxel)."
              },
              {
                "type": "paragraph",
                "content": "El método <code>toDataURL</code> en un elemento canvas crea una URL que empieza con <code>data:</code>. A diferencia de las URL <code>http:</code> y <code>https:</code>, las URL de datos contienen todo el recurso en la URL. Por lo general, son muy largas, pero nos permiten crear enlaces funcionales a imágenes arbitrarias aquí mismo en el navegador."
              }
            ]
          },
          {
            "id": "ch19-l6-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para realmente hacer que el navegador descargue la imagen, luego creamos un elemento de enlace que apunta a esta URL y tiene un atributo <code>download</code>. Tales enlaces, al hacer clic en ellos, muestran un cuadro de diálogo para guardar el archivo en el navegador. Añadimos ese enlace al documento, simulamos un clic en él y luego lo eliminamos. Se pueden hacer muchas cosas con la tecnología del navegador, pero a veces la forma de hacerlo es bastante extraña."
              },
              {
                "type": "paragraph",
                "content": "Y la cosa se pone peor. También querríamos cargar archivos de imagen existentes en nuestra aplicación. Para hacer eso, nuevamente definimos un componente de botón."
              },
              {
                "type": "paragraph",
                "content": "Para acceder a un archivo en la computadora del usuario, necesitamos que el usuario seleccione el archivo a través de un campo de entrada de archivo. Pero no quiero que el botón de carga se vea como un campo de entrada de archivo, así que creamos el campo de entrada de archivo cuando se hace clic en el botón y luego fingimos que este campo de entrada de archivo fue clicado."
              }
            ]
          },
          {
            "id": "ch19-l6-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando el usuario ha seleccionado un archivo, podemos usar <code>FileReader</code> para acceder a su contenido, nuevamente como una URL de datos. Esa URL se puede utilizar para crear un elemento <code>&lt;img&gt;</code>, pero debido a que no podemos acceder directamente a los píxeles en una imagen de ese tipo, no podemos crear un objeto <code>Picture</code> a partir de eso."
              },
              {
                "type": "paragraph",
                "content": "Para acceder a los píxeles, primero debemos dibujar la imagen en un elemento <code>&lt;canvas&gt;</code>. El contexto del canvas tiene un método <code>getImageData</code> que permite a un script leer sus píxeles. Por lo tanto, una vez que la imagen esté en el canvas, podemos acceder a ella y construir un objeto <code>Picture</code>."
              },
              {
                "type": "paragraph",
                "content": "Limitaremos el tamaño de las imágenes a 100 por 100 píxeles, ya que cualquier cosa más grande se verá <em>enorme</em> en nuestra pantalla y podría ralentizar la interfaz."
              }
            ]
          },
          {
            "id": "ch19-l6-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La propiedad <code>data</code> del objeto devuelto por <code>getImageData</code> es un array de componentes de color. Para cada píxel en el rectángulo especificado por los argumentos, contiene cuatro valores, que representan los componentes rojo, verde, azul y <em>alfa</em> del color del píxel, como números entre 0 y 255. La parte alfa representa la opacidad: cuando es cero, el píxel es totalmente transparente, y cuando es 255, es totalmente opaco. Para nuestro propósito, podemos ignorarla."
              },
              {
                "type": "paragraph",
                "content": "Los dos dígitos hexadecimales por componente, como se usa en nuestra notación de color, corresponden precisamente al rango del 0 al 255: dos dígitos en base 16 pueden expresar 16<sup>2</sup> = 256 números diferentes. El método <code>toString</code> de los números puede recibir como argumento una base, por lo que <code>n.toString(16)</code> producirá una representación en cadena en base 16. Debemos asegurarnos de que cada número tenga dos dígitos, por lo que la función auxiliar <code>hex</code> llama a <code>padStart</code> para agregar un cero inicial cuando sea necesario."
              },
              {
                "type": "paragraph",
                "content": "¡Ya podemos cargar y guardar! Eso deja una característica más antes de que hayamos terminado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      },
      {
        "id": "ch19-l7",
        "title": "Historial de deshacer",
        "sections": [
          {
            "id": "ch19-l7-s0",
            "title": "Historial de deshacer",
            "content": [
              {
                "type": "paragraph",
                "content": "La mitad del proceso de edición consiste en cometer pequeños errores y corregirlos. Por lo tanto, una característica importante en un programa de dibujo es un historial de deshacer."
              },
              {
                "type": "paragraph",
                "content": "Para poder deshacer cambios, necesitamos almacenar versiones anteriores de la imagen. Dado que es un valor inmutable, eso es fácil. Pero sí requiere un campo adicional en el estado de la aplicación."
              },
              {
                "type": "paragraph",
                "content": "Agregaremos una matriz <code>done</code> para mantener versiones anteriores de la imagen. Mantener esta propiedad requiere una función de actualización de estado más complicada que añade imágenes a la matriz."
              }
            ]
          },
          {
            "id": "ch19-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Pero no queremos almacenar <em>cada</em> cambio, solo los cambios que ocurran en un determinado espacio de tiempo. Para poder hacer eso, necesitaremos una segunda propiedad, <code>doneAt</code>, que rastree la hora en la que almacenamos por última vez una imagen en el historial."
              },
              {
                "type": "paragraph",
                "content": "Cuando la acción es una acción de deshacer, la función toma la imagen más reciente del historial y la convierte en la imagen actual. Establece <code>doneAt</code> en cero para garantizar que el siguiente cambio almacenará la imagen nuevamente en el historial, permitiéndote revertir a ella en otro momento si lo deseas."
              },
              {
                "type": "paragraph",
                "content": "De lo contrario, si la acción contiene una nueva imagen y la última vez que almacenamos algo fue hace más de un segundo (1000 milisegundos), las propiedades <code>done</code> y <code>doneAt</code> se actualizan para almacenar la imagen anterior."
              }
            ]
          },
          {
            "id": "ch19-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El botón de deshacer componente no hace mucho. Despacha acciones de deshacer al hacer clic y se deshabilita cuando no hay nada que deshacer."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch19-l8",
        "title": "Vamos a dibujar",
        "sections": [
          {
            "id": "ch19-l8-s0",
            "title": "Vamos a dibujar",
            "content": [
              {
                "type": "paragraph",
                "content": "Para configurar la aplicación, necesitamos crear un estado, un conjunto de herramientas, un conjunto de controles y una función despachar. Podemos pasarlos al constructor <code>PixelEditor</code> para crear el componente principal. Dado que necesitaremos crear varios editores en los ejercicios, primero definimos algunos enlaces."
              },
              {
                "type": "paragraph",
                "content": "Cuando desestructuras un objeto o un array, puedes usar <code>=</code> después de un nombre de enlace para darle al enlace un valor predeterminado, que se usa cuando la propiedad está ausente o tiene <code>undefined</code>. La función <code>startPixelEditor</code> hace uso de esto para aceptar un objeto con varias propiedades opcionales como argumento. Si, por ejemplo, no proporcionas una propiedad <code>tools</code>, entonces <code>tools</code> estará vinculado a <code>baseTools</code>.Así es como obtenemos un editor real en la pantalla:"
              },
              {
                "type": "paragraph",
                "content": "Adelante y dibuja algo."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch19-l9",
        "title": "¿Por qué es tan difícil?",
        "sections": [
          {
            "id": "ch19-l9-s0",
            "title": "¿Por qué es tan difícil?",
            "content": [
              {
                "type": "paragraph",
                "content": "La tecnología del navegador es asombrosa. Proporciona un poderoso conjunto de bloques de construcción de interfaz, formas de diseñar y manipularlos, y herramientas para inspeccionar y depurar tus aplicaciones. El software que escribes para el navegador puede ejecutarse en casi todas las computadoras y teléfonos del planeta."
              },
              {
                "type": "paragraph",
                "content": "Al mismo tiempo, la tecnología del navegador es ridícula. Tienes que aprender una gran cantidad de trucos tontos y hechos oscuros para dominarla, y el modelo de programación predeterminado que ofrece es tan problemático que la mayoría de los programadores prefieren cubrirlo con varias capas de abstracción en lugar de lidiar con él directamente."
              },
              {
                "type": "paragraph",
                "content": "Y aunque la situación definitivamente está mejorando, en su mayoría lo hace en forma de más elementos que se agregan para abordar deficiencias, creando aún más complejidad. Una característica utilizada por un millón de sitios web realmente no se puede reemplazar. Incluso si se pudiera, sería difícil decidir con qué debiera ser reemplazada."
              }
            ]
          },
          {
            "id": "ch19-l9-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La tecnología nunca existe en un vacío; estamos limitados por nuestras herramientas y los factores sociales, económicos e históricos que las produjeron. Esto puede ser molesto, pero generalmente es más productivo tratar de construir una buena comprensión de cómo funciona la realidad técnica <em>existente</em> y por qué es como es, que luchar contra ella o esperar otra realidad."
              },
              {
                "type": "paragraph",
                "content": "Nuevas abstracciones <em>pueden</em> ser útiles. El modelo de componente y la convención de flujo de datos que utilicé en este capítulo es una forma rudimentaria de eso. Como se mencionó, hay bibliotecas que intentan hacer la programación de interfaces de usuario más agradable. En el momento de escribir esto, React y Svelte son opciones populares, pero hay toda una industria de tales marcos. Si estás interesado en programar aplicaciones web, recomiendo investigar algunos de ellos para comprender cómo funcionan y qué beneficios proporcionan."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch19-l10",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch19-l10-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Todavía hay espacio para mejorar nuestro programa. Vamos a agregar algunas funciones más como ejercicios."
              },
              {
                "type": "paragraph",
                "content": "Agrega atajos de teclado a la aplicación. La primera letra del nombre de una herramienta selecciona la herramienta, y <span class=\"keyname\">control</span>-Z o <span class=\"keyname\">command</span>-Z activa el deshacer."
              },
              {
                "type": "paragraph",
                "content": "Haz esto modificando el componente <code>PixelEditor</code>. Agrega una propiedad <code>tabIndex</code> de 0 al elemento <code>&lt;div&gt;</code> envolvente para que pueda recibir el enfoque del teclado. Ten en cuenta que la <em>propiedad</em> correspondiente al atributo <code>tabindex</code> se llama <code>tabIndex</code>, con una I mayúscula, y nuestra función <code>elt</code> espera nombres de propiedades. Registra los manejadores de eventos de teclas directamente en ese elemento. Esto significa que debes hacer clic, tocar o moverte al tabulador en la aplicación antes de poder interactuar con el teclado."
              }
            ]
          },
          {
            "id": "ch19-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Recuerda que los eventos de teclado tienen las propiedades <code>ctrlKey</code> y <code>metaKey</code> (para la tecla <span class=\"keyname\">command</span> en Mac) que puedes utilizar para ver si esas teclas están presionadas."
              },
              {
                "type": "paragraph",
                "content": "La propiedad <code>key</code> de los eventos de teclas de letras será la letra en minúscula en sí misma, si no se mantiene presionada la tecla <span class=\"keyname\">shift</span>. No nos interesan los eventos de teclas con <span class=\"keyname\">shift</span> aquí."
              },
              {
                "type": "paragraph",
                "content": "Un controlador <code>\"keydown\"</code> puede inspeccionar su objeto de evento para ver si coincide con alguno de los atajos. Puedes obtener automáticamente la lista de primeras letras del objeto <code>tools</code> para que no tengas que escribirlas."
              }
            ]
          },
          {
            "id": "ch19-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando el evento de tecla coincide con un atajo, llama a <code>preventDefault</code> en él y dispatch la acción apropiada."
              },
              {
                "type": "paragraph",
                "content": "Durante el dibujo, la mayoría del trabajo que hace nuestra aplicación ocurre en <code>drawPicture</code>. Crear un nuevo estado y actualizar el resto del DOM no es muy costoso, pero repintar todos los píxeles en el lienzo es bastante trabajo."
              },
              {
                "type": "paragraph",
                "content": "Encuentra una forma de hacer que el método <code>syncState</code> de <code>PictureCanvas</code> sea más rápido redibujando solo los píxeles que realmente cambiaron."
              }
            ]
          },
          {
            "id": "ch19-l10-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Recuerda que <code>drawPicture</code> también es utilizado por el botón de guardar, así que si lo cambias, asegúrate de que los cambios no rompan el uso anterior o crea una nueva versión con un nombre diferente."
              },
              {
                "type": "paragraph",
                "content": "También ten en cuenta que al cambiar el tamaño de un elemento <code>&lt;canvas&gt;</code>, establecer sus propiedades <code>width</code> o <code>height</code>, lo borra y lo vuelve completamente transparente nuevamente."
              },
              {
                "type": "paragraph",
                "content": "Este ejercicio es un buen ejemplo de cómo las estructuras de datos inmutables pueden hacer que el código sea <em>más rápido</em>. Debido a que tenemos tanto la imagen antigua como la nueva, podemos compararlas y volver a dibujar solo los píxeles que cambiaron de color, ahorrando más del 99 por ciento del trabajo de dibujo en la mayoría de los casos."
              }
            ]
          },
          {
            "id": "ch19-l10-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes escribir una nueva función <code>updatePicture</code> o hacer que <code>drawPicture</code> tome un argumento adicional, que puede ser undefined o la imagen anterior. Para cada píxel, la función comprueba si se pasó una imagen anterior con el mismo color en esta posición y omite el píxel en ese caso."
              },
              {
                "type": "paragraph",
                "content": "Como el lienzo se borra cuando cambiamos su tamaño, también debes evitar tocar sus propiedades <code>width</code> y <code>height</code> cuando la imagen antigua y la imagen nueva tienen el mismo tamaño. Si son diferentes, lo cual sucederá cuando se haya cargado una nueva imagen, puedes establecer que el enlace que sostiene la imagen antigua sea nulo después de cambiar el tamaño del lienzo porque no deberías omitir ningún píxel después de haber cambiado el tamaño del lienzo."
              },
              {
                "type": "paragraph",
                "content": "Define una herramienta llamada <code>circle</code> que dibuje un círculo relleno cuando arrastres. El centro del círculo se encuentra en el punto donde comienza el gesto de arrastre o toque, y su radio está determinado por la distancia arrastrada."
              }
            ]
          },
          {
            "id": "ch19-l10-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes inspirarte en la herramienta <code>rectangle</code>. Como esa herramienta, querrás seguir dibujando en la imagen <em>inicial</em>, en lugar de la imagen actual, cuando el puntero se mueva."
              },
              {
                "type": "paragraph",
                "content": "Para averiguar qué píxeles colorear, puedes usar el teorema de Pitágoras. Primero averigua la distancia entre la posición actual del puntero y la posición de inicio tomando la raíz cuadrada (<code>Math.sqrt</code>) de la suma del cuadrado (<code>x ** 2</code>) de la diferencia en las coordenadas x y el cuadrado de la diferencia en las coordenadas y. Luego, recorre una cuadrícula de píxeles alrededor de la posición de inicio, cuyos lados tienen al menos el doble del radio, y colorea aquellos que estén dentro del radio del círculo, nuevamente usando la fórmula pitagórica para averiguar la distancia desde el centro."
              },
              {
                "type": "paragraph",
                "content": "Asegúrate de no intentar colorear píxeles que estén fuera de los límites de la imagen."
              }
            ]
          },
          {
            "id": "ch19-l10-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Este es un ejercicio más avanzado que los dos anteriores, y requerirá que diseñes una solución a un problema no trivial. Asegúrate de tener mucho tiempo y paciencia antes de comenzar a trabajar en este ejercicio, y no te desanimes por los fallos iniciales."
              },
              {
                "type": "paragraph",
                "content": "En la mayoría de los navegadores, al seleccionar la <code>herramienta</code> de <code>dibujo</code> y arrastrar rápidamente sobre la imagen, no obtienes una línea cerrada. En su lugar, obtienes puntos con huecos entre ellos porque los eventos <code>\"mousemove\"</code> o <code>\"touchmove\"</code> no se dispararon lo suficientemente rápido como para alcanzar cada píxel."
              },
              {
                "type": "paragraph",
                "content": "Mejora la herramienta de <code>dibujo</code> para que dibuje una línea completa. Esto significa que debes hacer que la función de controlador de movimiento recuerde la posición anterior y la conecte con la actual."
              }
            ]
          },
          {
            "id": "ch19-l10-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para hacer esto, dado que los píxeles pueden estar a una distancia arbitraria, tendrás que escribir una función general de dibujo de líneas."
              },
              {
                "type": "paragraph",
                "content": "Una línea entre dos píxeles es una cadena conectada de píxeles, lo más recta posible, que va desde el comienzo hasta el final. Los píxeles diagonalmente adyacentes cuentan como conectados. Por lo tanto, una línea inclinada debería verse como la imagen de la izquierda, no como la de la derecha."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Editor de Arte Pixelado __ Eloquent JavaScript_files/line-grid.svg",
                "alt": "Diagrama de dos líneas pixeladas, una clara, saltando píxeles diagonalmente, y otra más gruesa, con todos los píxeles conectados horizontal o verticalmente"
              },
              {
                "type": "paragraph",
                "content": "Finalmente, si tenemos código que dibuja una línea entre dos puntos arbitrarios, podríamos usarlo también para definir una <code>herramienta</code> de <code>línea</code>, que dibuja una línea recta entre el inicio y el final de un arrastre."
              }
            ]
          },
          {
            "id": "ch19-l10-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El problema de dibujar una línea pixelada es que en realidad son cuatro problemas similares pero ligeramente diferentes. Dibujar una línea horizontal de izquierda a derecha es fácil: recorres las coordenadas <em>x</em> y coloreas un píxel en cada paso. Si la línea tiene una ligera pendiente (menos de 45 grados o ¼π radianes), puedes interpolar la coordenada <em>y</em> a lo largo de la pendiente. Aún necesitas un píxel por posición <em>x</em>, con la posición <em>y</em> de esos píxeles determinada por la pendiente."
              },
              {
                "type": "paragraph",
                "content": "Pero tan pronto como tu pendiente cruce los 45 grados, necesitas cambiar la forma en que tratas las coordenadas. Ahora necesitas un píxel por posición <em>y</em> ya que la línea sube más de lo que va a la izquierda. Y luego, cuando cruces los 135 grados, tendrás que volver a recorrer las coordenadas <em>x</em>, pero de derecha a izquierda."
              },
              {
                "type": "paragraph",
                "content": "No necesitas realmente escribir cuatro bucles. Dado que dibujar una línea de <em>A</em> a <em>B</em> es lo mismo que dibujar una línea de <em>B</em> a <em>A</em>, puedes intercambiar las posiciones de inicio y fin para las líneas que van de derecha a izquierda y tratarlas como si fueran de izquierda a derecha."
              }
            ]
          },
          {
            "id": "ch19-l10-s9",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Por lo tanto, necesitas dos bucles diferentes. Lo primero que debería hacer tu función de dibujo de líneas es verificar si la diferencia entre las coordenadas x es mayor que la diferencia entre las coordenadas y. Si lo es, esta es una línea horizontal-ish y, si no, una línea vertical-ish."
              },
              {
                "type": "paragraph",
                "content": "Asegúrate de comparar los valores <em>absolutos</em> de la diferencia de <em>x</em> e <em>y</em>, los cuales puedes obtener con <code>Math.abs</code>."
              },
              {
                "type": "paragraph",
                "content": "Una vez que sepas a lo largo de qué eje estarás iterando, puedes verificar si el punto de inicio tiene una coordenada más alta a lo largo de ese eje que el punto final y intercambiarlos si es necesario. Una forma sucinta de intercambiar los valores de dos enlaces en JavaScript utiliza la asignación por desestructuración de la siguiente manera:"
              }
            ]
          },
          {
            "id": "ch19-l10-s10",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Entonces puedes calcular la pendiente de la línea, que determina la cantidad en que la coordenada en el otro eje cambia por cada paso que das a lo largo de tu eje principal. Con eso, puedes ejecutar un bucle a lo largo del eje principal mientras también haces un seguimiento de la posición correspondiente en el otro eje, y puedes dibujar píxeles en cada iteración. Asegúrate de redondear las coordenadas del eje no principal ya que es probable que sean fraccionales y el método <code>draw</code> no responda bien a coordenadas fraccionales."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 75
      }
    ]
  },
  {
    "id": "ch20",
    "number": 20,
    "title": "Node.js",
    "titleEs": "Node.js",
    "part": "part3",
    "partLabel": "Parte 3: Node.js",
    "icon": "BookOpen",
    "description": "Un estudiante preguntó: “Los programadores de antaño solo usaban máquinas simples y ningún lenguaje de programación, sin embargo, creaban programas he...",
    "isProject": false,
    "totalXP": 430,
    "lessons": [
      {
        "id": "ch20-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch20-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Un estudiante preguntó: “Los programadores de antaño solo usaban máquinas simples y ningún lenguaje de programación, sin embargo, creaban programas hermosos. ¿Por qué nosotros usamos máquinas complicadas y lenguajes de programación?”. Fu-Tzu respondió: “Los constructores de antaño solo usaban palos y arcilla, sin embargo, creaban hermosas chozas.” Maestro Yuan-Ma, El Libro de la Programación"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Node.js __ Eloquent JavaScript_files/chapter_picture_20.jpg",
                "alt": "Ilustración que muestra un poste telefónico con un enredo de cables en todas direcciones"
              },
              {
                "type": "paragraph",
                "content": "Hasta ahora, hemos utilizado el lenguaje JavaScript en un solo entorno: el navegador. Este capítulo y el siguiente introducirán brevemente Node.js, un programa que te permite aplicar tus habilidades con JavaScript fuera del navegador. Con él, puedes construir desde pequeñas herramientas de línea de comandos hasta servidores HTTP server que alimentan sitios web dinámicos."
              }
            ]
          },
          {
            "id": "ch20-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Estos capítulos tienen como objetivo enseñarte los conceptos principales que Node.js utiliza y darte información suficiente para escribir programas útiles para él. No intentan ser un tratamiento completo, ni siquiera exhaustivo, de la plataforma."
              },
              {
                "type": "paragraph",
                "content": "Mientras que podrías ejecutar el código en los capítulos anteriores directamente en estas páginas, ya sea JavaScript puro o escrito para el navegador, los ejemplos de código en este capítulo están escritos para Node y a menudo no se ejecutarán en el navegador."
              },
              {
                "type": "paragraph",
                "content": "Si deseas seguir y ejecutar el código en este capítulo, necesitarás instalar Node.js versión 18 o superior. Para hacerlo, ve a <em>https://nodejs.org</em> y sigue las instrucciones de instalación para tu sistema operativo. También puedes encontrar más documentación para Node.js allí."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch20-l1",
        "title": "Antecedentes",
        "sections": [
          {
            "id": "ch20-l1-s0",
            "title": "Antecedentes",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se construyen sistemas que se comunican a través de la red, la forma en que gestionas la entrada y el output—es decir, la lectura y escritura de datos desde y hacia la red y el disco duro—puede marcar una gran diferencia en cuán rápido responde un sistema al usuario o a las solicitudes de red."
              },
              {
                "type": "paragraph",
                "content": "En tales programas, la programación asincrónica a menudo es útil. Permite que el programa envíe y reciba datos desde y hacia múltiples dispositivos al mismo tiempo sin una complicada gestión de hilos y sincronización."
              },
              {
                "type": "paragraph",
                "content": "Node fue concebido inicialmente con el propósito de hacer que la programación asincrónica sea fácil y conveniente. JavaScript se presta bien a un sistema como Node. Es uno de los pocos lenguajes de programación que no tiene una forma incorporada de manejar la entrada y salida. Por lo tanto, JavaScript podría adaptarse al enfoque algo excéntrico de Node para la programación de red y sistemas de archivos sin terminar con dos interfaces inconsistentes. En 2009, cuando se diseñaba Node, la gente ya estaba realizando programación basada en callbacks en el navegador, por lo que la comunidad alrededor del lenguaje estaba acostumbrada a un estilo de programación asincrónica."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch20-l2",
        "title": "El comando node",
        "sections": [
          {
            "id": "ch20-l2-s0",
            "title": "El comando node",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando Node.js está instalado en un sistema, proporciona un programa llamado <code>node</code>, que se utiliza para ejecutar archivos de JavaScript. Supongamos que tienes un archivo <code>hello.js</code>, que contiene este código:"
              },
              {
                "type": "paragraph",
                "content": "Luego puedes ejecutar <code>node</code> desde la línea de comandos de la siguiente manera para ejecutar el programa:"
              },
              {
                "type": "paragraph",
                "content": "El método <code>console.log</code> en Node hace algo similar a lo que hace en el navegador. Imprime un texto. Pero en Node, el texto irá al flujo de salida estándar del proceso, en lugar de ir a la consola de JavaScript de un navegador. Al ejecutar <code>node</code> desde la línea de comandos, significa que verás los valores registrados en tu terminal."
              }
            ]
          },
          {
            "id": "ch20-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si ejecutas <code>node</code> sin proporcionarle un archivo, te proporcionará un indicador en el que puedes escribir código JavaScript y ver inmediatamente el resultado."
              },
              {
                "type": "paragraph",
                "content": "El enlace <code>process</code>, al igual que el enlace <code>console</code>, está disponible globalmente en Node. Proporciona varias formas de inspeccionar y manipular el programa actual. El método <code>exit</code> finaliza el proceso y puede recibir un código de estado de salida, que le indica al programa que inició <code>node</code> (en este caso, la shell de línea de comandos) si el programa se completó correctamente (código cero) o si se encontró un error (cualquier otro código)."
              },
              {
                "type": "paragraph",
                "content": "Para encontrar los argumentos de línea de comandos dados a tu script, puedes leer <code>process.argv</code>, que es un array de cadenas. Ten en cuenta que también incluye el nombre del comando <code>node</code> y el nombre de tu script, por lo que los argumentos reales comienzan en el índice 2. Si <code>showargv.js</code> contiene la instrucción <code>console.<wbr>log(process.<wbr>argv)</code>, podrías ejecutarlo de la siguiente manera:"
              }
            ]
          },
          {
            "id": "ch20-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Todos los enlaces globales de JavaScript estándar, como <code>Array</code>, <code>Math</code> y <code>JSON</code>, también están presentes en el entorno de Node. La funcionalidad relacionada con el navegador, como <code>document</code> o <code>prompt</code>, no lo está."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch20-l3",
        "title": "Módulos",
        "sections": [
          {
            "id": "ch20-l3-s0",
            "title": "Módulos",
            "content": [
              {
                "type": "paragraph",
                "content": "Además de los enlaces que mencioné, como <code>console</code> y <code>process</code>, Node agrega pocos enlaces adicionales en el ámbito global. Si deseas acceder a funcionalidades integradas, debes solicitarlas al sistema de módulos."
              },
              {
                "type": "paragraph",
                "content": "Node comenzó utilizando el sistema de módulos CommonJS, basado en la función <code>require</code>, que vimos en el Capítulo 10. Aún utilizará este sistema de forma predeterminada cuando cargues un archivo <code>.js</code>."
              },
              {
                "type": "paragraph",
                "content": "Pero también soporta el sistema de módulos ES más moderno. Cuando el nombre de un script termina en <code>.mjs</code>, se considera que es un módulo de este tipo, y puedes usar <code>import</code> y <code>export</code> en él (pero no <code>require</code>). Utilizaremos módulos ES en este capítulo."
              }
            ]
          },
          {
            "id": "ch20-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando se importa un módulo, ya sea con <code>require</code> o <code>import</code>, Node debe resolver la cadena proporcionada a un archivo real que pueda cargar. Los nombres que comienzan con <code>/</code>, <code>./</code> o <code>../</code> se resuelven como archivos, relativos a la ruta del módulo actual. Aquí, <code>.</code> representa el directorio actual, <code>../</code> para un directorio arriba, y <code>/</code> para la raíz del sistema de archivos. Por lo tanto, si solicitas <code>\"./<wbr>graph.<wbr>mjs\"</code> desde el archivo <code>/<wbr>tmp/<wbr>robot/<wbr>robot.<wbr>mjs</code>, Node intentará cargar el archivo <code>/<wbr>tmp/<wbr>robot/<wbr>graph.<wbr>mjs</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando se importa una cadena que no parece una ruta relativa o absoluta, se asume que se refiere a un módulo integrado o un módulo instalado en un directorio <code>node_modules</code>. Por ejemplo, importar desde <code>\"node:fs\"</code> te dará el módulo integrado del sistema de archivos de Node. E importar <code>\"robot\"</code> podría intentar cargar la biblioteca encontrada en <code>node_modules/<wbr>robot/<wbr></code>. Una forma común de instalar estas bibliotecas es usando NPM, a lo cual volveremos en un momento."
              },
              {
                "type": "paragraph",
                "content": "Configuremos un proyecto pequeño que consta de dos archivos. El primero, llamado <code>main.mjs</code>, define un script que puede ser llamado desde la línea de comandos para revertir una cadena."
              }
            ]
          },
          {
            "id": "ch20-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El archivo <code>reverse.mjs</code> define una biblioteca para revertir cadenas, que puede ser utilizada tanto por esta herramienta de línea de comandos como por otros scripts que necesiten acceso directo a una función para revertir cadenas."
              },
              {
                "type": "paragraph",
                "content": "Recuerda que <code>export</code> se utiliza para declarar que un enlace es parte de la interfaz del módulo. Eso permite que <code>main.mjs</code> importe y utilice la función."
              },
              {
                "type": "paragraph",
                "content": "Ahora podemos llamar a nuestra herramienta de esta manera:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch20-l4",
        "title": "Instalando con NPM",
        "sections": [
          {
            "id": "ch20-l4-s0",
            "title": "Instalando con NPM",
            "content": [
              {
                "type": "paragraph",
                "content": "NPM, que fue introducido en el Capítulo 10, es un repositorio en línea de módulos de JavaScript, muchos de los cuales están escritos específicamente para Node. Cuando instalas Node en tu computadora, también obtienes el comando <code>npm</code>, que puedes usar para interactuar con este repositorio."
              },
              {
                "type": "paragraph",
                "content": "El uso principal de NPM es descargar paquetes. Vimos el paquete <code>ini</code> en el Capítulo 10. Podemos usar NPM para buscar e instalar ese paquete en nuestra computadora."
              },
              {
                "type": "paragraph",
                "content": "Después de ejecutar <code>npm install</code>, NPM habrá creado un directorio llamado <code>node_modules</code>. Dentro de ese directorio estará un directorio <code>ini</code> que contiene la biblioteca. Puedes abrirlo y ver el código. Cuando importamos <code>\"ini\"</code>, esta biblioteca se carga, y podemos llamar a su propiedad <code>parse</code> para analizar un archivo de configuración.Por defecto, NPM instala paquetes en el directorio actual, en lugar de en un lugar centralizado. Si estás acostumbrado a otros gestores de paquetes, esto puede parecer inusual, pero tiene ventajas: pone a cada aplicación en control total de los paquetes que instala y facilita la gestión de versiones y limpieza al eliminar una aplicación."
              }
            ]
          },
          {
            "id": "ch20-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Después de ejecutar <code>npm install</code> para instalar algún paquete, encontrarás no solo un directorio <code>node_modules</code>, sino también un archivo llamado <code>package.json</code> en tu directorio actual. Se recomienda tener tal archivo para cada proyecto. Puedes crearlo manualmente o ejecutar <code>npm init</code>. Este archivo contiene información sobre el proyecto, como su nombre y versión, y enumera sus dependencias."
              },
              {
                "type": "paragraph",
                "content": "La simulación del robot de Capítulo 7, modularizada en el ejercicio en el Capítulo 10, podría tener un archivo <code>package.json</code> como este:"
              },
              {
                "type": "paragraph",
                "content": "Cuando ejecutas <code>npm install</code> sin especificar un paquete para instalar, NPM instalará las dependencias enumeradas en <code>package.json</code>. Cuando instalas un paquete específico que no está listado como una dependencia, NPM lo añadirá a <code>package.json</code>."
              }
            ]
          },
          {
            "id": "ch20-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un archivo <code>package.json</code> lista tanto la versión del propio programa como las versiones de sus dependencias. Las versiones son una forma de manejar el hecho de que los paquetes evolucionan por separado, y el código escrito para funcionar con un paquete tal como existía en un momento dado puede no funcionar con una versión posterior y modificada del paquete."
              },
              {
                "type": "paragraph",
                "content": "NPM exige que sus paquetes sigan un esquema llamado <em>semantic versioning</em>, que codifica información sobre qué versiones son <em>compatibles</em> (no rompen la antigua interfaz) en el número de versión. Una versión semántica consiste en tres números, separados por puntos, como <code>2.3.0</code>. Cada vez que se añade nueva funcionalidad, el número del medio debe incrementarse. Cada vez que se rompe la compatibilidad, de modo que el código existente que utiliza el paquete puede que no funcione con la nueva versión, el primer número debe incrementarse."
              },
              {
                "type": "paragraph",
                "content": "Un carácter de intercalación (<code>^</code>) delante del número de versión para una dependencia en <code>package.json</code> indica que se puede instalar cualquier versión compatible con el número dado. Por ejemplo, <code>\"^2.<wbr>3.<wbr>0\"</code> significaría que se permite cualquier versión mayor o igual a 2.3.0 y menor que 3.0.0."
              }
            ]
          },
          {
            "id": "ch20-l4-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El comando <code>npm</code> también se utiliza para publicar nuevos paquetes o nuevas versiones de paquetes. Si ejecutas <code>npm publish</code> en un directorio que tiene un archivo <code>package.json</code>, se publicará un paquete con el nombre y versión listados en el archivo JSON en el registro. Cualquiera puede publicar paquetes en NPM, aunque solo bajo un nombre de paquete que aún no esté en uso, ya que no sería bueno que personas aleatorias pudieran actualizar paquetes existentes.Este libro no profundizará más en los detalles del uso de NPM. Consulta <em>https://npmjs.org</em> para obtener más documentación y una forma de buscar paquetes."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch20-l5",
        "title": "El módulo del sistema de archivos",
        "sections": [
          {
            "id": "ch20-l5-s0",
            "title": "El módulo del sistema de archivos",
            "content": [
              {
                "type": "paragraph",
                "content": "Uno de los módulos integrados más utilizados en Node es el módulo <code>node:fs</code>, que significa <em>sistema de archivos</em>. Exporta funciones para trabajar con archivos y directorios."
              },
              {
                "type": "paragraph",
                "content": "Por ejemplo, la función llamada <code>readFile</code> lee un archivo y luego llama a una función de devolución de llamada con el contenido del archivo."
              },
              {
                "type": "paragraph",
                "content": "El segundo argumento de <code>readFile</code> indica la <em>codificación de caracteres</em> utilizada para decodificar el archivo en una cadena. Existen varias formas en las que el texto puede ser codificado en datos binarios, pero la mayoría de los sistemas modernos utilizan UTF-8. Entonces, a menos que tengas razones para creer que se utiliza otra codificación, pasa <code>\"utf8\"</code> al leer un archivo de texto. Si no pasas una codificación, Node asumirá que estás interesado en los datos binarios y te dará un objeto <code>Buffer</code> en lugar de una cadena. Este es un objeto similar a un array que contiene números que representan los bytes (trozos de datos de 8 bits) en los archivos."
              }
            ]
          },
          {
            "id": "ch20-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una función similar, <code>writeFile</code>, se utiliza para escribir un archivo en el disco."
              },
              {
                "type": "paragraph",
                "content": "Aquí no fue necesario especificar la codificación: <code>writeFile</code> asumirá que cuando se le da una cadena para escribir, en lugar de un objeto <code>Buffer</code>, debe escribirla como texto utilizando su codificación de caracteres predeterminada, que es UTF-8."
              },
              {
                "type": "paragraph",
                "content": "El módulo <code>node:fs</code> contiene muchas otras funciones útiles: <code>readdir</code> te dará los archivos en un directorio como un array de cadenas, <code>stat</code> recuperará información sobre un archivo, <code>rename</code> cambiará el nombre de un archivo, <code>unlink</code> lo eliminará, entre otros. Consulta la documentación en <em>https://nodejs.org</em> para obtener detalles específicos."
              }
            ]
          },
          {
            "id": "ch20-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La mayoría de estas funciones toman una función de devolución de llamada como último parámetro, a la que llaman ya sea con un error (el primer argumento) o con un resultado exitoso (el segundo). Como vimos en el Capítulo 11, hay desventajas en este estilo de programación, siendo la mayor que el manejo de errores se vuelve verboso y propenso a errores."
              },
              {
                "type": "paragraph",
                "content": "El módulo <code>node:fs/promises</code> exporta la mayoría de las mismas funciones que el antiguo módulo <code>node:fs</code>, pero utiliza promesas en lugar de funciones de devolución de llamada."
              },
              {
                "type": "paragraph",
                "content": "A veces no necesitas asincronía y simplemente te estorba. Muchas de las funciones en <code>node:fs</code> también tienen una variante síncrona, que tiene el mismo nombre con <code>Sync</code> agregado al final. Por ejemplo, la versión síncrona de <code>readFile</code> se llama <code>readFileSync</code>."
              }
            ]
          },
          {
            "id": "ch20-l5-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cabe destacar que mientras se realiza una operación síncrona de este tipo, tu programa se detiene por completo. Si debería estar respondiendo al usuario o a otras máquinas en la red, quedarse atrapado en una acción síncrona podría producir retrasos molestos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch20-l6",
        "title": "El módulo HTTP",
        "sections": [
          {
            "id": "ch20-l6-s0",
            "title": "El módulo HTTP",
            "content": [
              {
                "type": "paragraph",
                "content": "Otro módulo central se llama <code>node:http</code>. Proporciona funcionalidad para ejecutar un servidor HTTP."
              },
              {
                "type": "paragraph",
                "content": "Esto es todo lo que se necesita para iniciar un servidor HTTP:"
              },
              {
                "type": "paragraph",
                "content": "Si ejecutas este script en tu propia máquina, puedes apuntar tu navegador web a <em>http://localhost:8000/hola</em> para hacer una solicitud a tu servidor. Responderá con una pequeña página HTML."
              }
            ]
          },
          {
            "id": "ch20-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función pasada como argumento a <code>createServer</code> se llama cada vez que un cliente se conecta al servidor. Los enlaces <code>solicitud</code> y <code>respuesta</code> son objetos que representan los datos de entrada y salida. El primero contiene información sobre la solicitud, como su propiedad <code>url</code>, que nos dice a qué URL se hizo la solicitud."
              },
              {
                "type": "paragraph",
                "content": "Así que, cuando abres esa página en tu navegador, envía una solicitud a tu propia computadora. Esto hace que la función del servidor se ejecute y envíe una respuesta, que luego puedes ver en el navegador."
              },
              {
                "type": "paragraph",
                "content": "Para enviar algo al cliente, llamas a métodos en el objeto <code>respuesta</code>. El primero, <code>writeHead</code>, escribirá los encabezados de respuesta (ver Capítulo 18). Le das el código de estado (200 para “OK” en este caso) y un objeto que contiene valores de encabezado. El ejemplo establece el encabezado <code>Content-Type</code> para informar al cliente que estaremos enviando de vuelta un documento HTML."
              }
            ]
          },
          {
            "id": "ch20-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "A continuación, el cuerpo real de la respuesta (el documento en sí) se envía con <code>response.write</code>. Se permite llamar a este método varias veces si deseas enviar la respuesta pieza por pieza, por ejemplo para transmitir datos al cliente a medida que estén disponibles. Por último, <code>response.end</code> señala el fin de la respuesta."
              },
              {
                "type": "paragraph",
                "content": "La llamada a <code>server.listen</code> hace que el servidor comience a esperar conexiones en el puerto 8000. Por eso debes conectarte a <em>localhost:8000</em> para comunicarte con este servidor, en lugar de simplemente a <em>localhost</em>, que usaría el puerto predeterminado 80."
              },
              {
                "type": "paragraph",
                "content": "Cuando ejecutas este script, el proceso se queda esperando. Cuando un script está escuchando eventos —en este caso, conexiones de red—, <code>node</code> no se cerrará automáticamente al llegar al final del script. Para cerrarlo, presiona <span class=\"keyname\">control</span>-C."
              }
            ]
          },
          {
            "id": "ch20-l6-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un verdadero servidor web server usualmente hace más cosas que el ejemplo; examina el método de la solicitud (la propiedad <code>method</code>) para ver qué acción está intentando realizar el cliente y mira el URL de la solicitud para descubrir sobre qué recurso se está realizando esta acción. Veremos un servidor más avanzado más adelante en este capítulo."
              },
              {
                "type": "paragraph",
                "content": "El módulo <code>node:http</code> también provee una función <code>request</code>, que se puede usar para hacer solicitudes HTTP. Sin embargo, es mucho más engorroso de usar que <code>fetch</code>, que vimos en el Capítulo 18. Afortunadamente, <code>fetch</code> también está disponible en Node, como un enlace global. A menos que desees hacer algo muy específico, como procesar el documento de respuesta pieza por pieza a medida que llegan los datos a través de la red, recomiendo usar <code>fetch</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch20-l7",
        "title": "Flujos",
        "sections": [
          {
            "id": "ch20-l7-s0",
            "title": "Flujos",
            "content": [
              {
                "type": "paragraph",
                "content": "El objeto de respuesta al que el servidor HTTP podría escribir es un ejemplo de un objeto de <em>flujo de escritura</em>, que es un concepto ampliamente usado en Node. Estos objetos tienen un método <code>write</code> al que se puede pasar una cadena o un objeto <code>Buffer</code> para escribir algo en el flujo. Su método <code>end</code> cierra el flujo y opcionalmente toma un valor para escribir en el flujo antes de cerrarlo. Ambos métodos también pueden recibir una devolución de llamada como argumento adicional, que se llamará cuando la escritura o el cierre hayan finalizado."
              },
              {
                "type": "paragraph",
                "content": "Es posible crear un flujo de escritura que apunte a un archivo con la función <code>createWriteStream</code> del módulo <code>node:fs</code>. Luego puedes usar el método <code>write</code> en el objeto resultante para escribir el archivo pieza por pieza, en lugar de hacerlo de una sola vez como con <code>writeFile</code>."
              },
              {
                "type": "paragraph",
                "content": "Los <em>flujos legibles</em> son un poco más complejos. El argumento <code>request</code> para la devolución de llamada del servidor HTTP es un flujo legible. Leer de un flujo se hace utilizando manejadores de eventos, en lugar de métodos."
              }
            ]
          },
          {
            "id": "ch20-l7-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los objetos que emiten eventos en Node tienen un método llamado <code>on</code> que es similar al método <code>addEventListener</code> en el navegador. Le das un nombre de evento y luego una función, y registrará esa función para que se llame cada vez que ocurra el evento dado."
              },
              {
                "type": "paragraph",
                "content": "Los streams legibles tienen eventos <code>\"data\"</code> y <code>\"end\"</code>. El primero se dispara cada vez que llegan datos, y el segundo se llama cuando el flujo llega a su fin. Este modelo es más adecuado para datos de <em>streaming</em> que pueden procesarse de inmediato, incluso cuando todo el documento aún no está disponible. Un archivo se puede leer como un flujo legible utilizando la función <code>createReadStream</code> de <code>node:fs</code>."
              },
              {
                "type": "paragraph",
                "content": "Este código crea un servidor que lee los cuerpos de las solicitudes y los reenvía al cliente como texto en mayúsculas:"
              }
            ]
          },
          {
            "id": "ch20-l7-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El valor <code>chunk</code> pasado al manejador de datos será un <code>Buffer</code> binario. Podemos convertir esto a una cadena decodificándolo como caracteres codificados en UTF-8 con su método <code>toString</code>."
              },
              {
                "type": "paragraph",
                "content": "El siguiente fragmento de código, cuando se ejecuta con el servidor de mayúsculas activo, enviará una solicitud a ese servidor y escribirá la respuesta que recibe:"
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch20-l8",
        "title": "Un servidor de archivos",
        "sections": [
          {
            "id": "ch20-l8-s0",
            "title": "Un servidor de archivos",
            "content": [
              {
                "type": "paragraph",
                "content": "Combina nuestro nuevo conocimiento sobre los servidores HTTP y el trabajo con el sistema de archivos para crear un puente entre ambos: un servidor HTTP que permite el acceso remoto a un sistema de archivos. Este tipo de servidor tiene todo tipo de usos, como permitir que las aplicaciones web almacenen y compartan datos, o dar acceso compartido a un grupo de personas a un montón de archivos."
              },
              {
                "type": "paragraph",
                "content": "Cuando tratamos los archivos como recursos de HTTP, los métodos HTTP <code>GET</code>, <code>PUT</code> y <code>DELETE</code> se pueden usar para leer, escribir y eliminar los archivos, respectivamente. Interpretaremos la ruta en la solicitud como la ruta del archivo al que se refiere la solicitud."
              },
              {
                "type": "paragraph",
                "content": "Probablemente no queramos compartir todo nuestro sistema de archivos, por lo que interpretaremos estas rutas como comenzando en el directorio de trabajo del servidor, que es el directorio en el que se inició. Si ejecuté el servidor desde <code>/tmp/public/</code> (o <code>C:\\tmp\\public\\</code> en Windows), entonces una solicitud para <code>/file.txt</code> debería referirse a <code>/<wbr>tmp/<wbr>public/<wbr>file.<wbr>txt</code> (o <code>C:\\tmp\\public\\file.<wbr>txt</code>)."
              }
            ]
          },
          {
            "id": "ch20-l8-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Construiremos el programa paso a paso, utilizando un objeto llamado <code>methods</code> para almacenar las funciones que manejan los diferentes métodos HTTP. Los manejadores de métodos son funciones <code>async</code> que reciben el objeto de solicitud como argumento y devuelven una promesa que se resuelve a un objeto que describe la respuesta."
              },
              {
                "type": "paragraph",
                "content": "Esto inicia un servidor que simplemente devuelve respuestas de error 405, que es el código utilizado para indicar que el servidor se niega a manejar un método determinado."
              },
              {
                "type": "paragraph",
                "content": "Cuando la promesa de un manejador de solicitud es rechazada, la llamada a <code>catch</code> traduce el error en un objeto de respuesta, si aún no lo es, para que el servidor pueda enviar una respuesta de error para informar al cliente que no pudo manejar la solicitud."
              }
            ]
          },
          {
            "id": "ch20-l8-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El campo <code>status</code> de la descripción de la respuesta puede omitirse, en cuyo caso se establece en 200 (OK) por defecto. El tipo de contenido, en la propiedad <code>type</code>, también puede omitirse, en cuyo caso se asume que la respuesta es texto plano."
              },
              {
                "type": "paragraph",
                "content": "Cuando el valor de <code>body</code> es un readable stream, este tendrá un método <code>pipe</code> que se utiliza para reenviar todo el contenido de un flujo de lectura a un writable stream. Si no es así, se asume que es <code>null</code> (sin cuerpo), una cadena o un búfer, y se pasa directamente al método <code>end</code> del response."
              },
              {
                "type": "paragraph",
                "content": "Para determinar qué ruta de archivo corresponde a una URL de solicitud, la función <code>urlPath</code> utiliza la clase integrada <code>URL</code> (que también existe en el navegador) para analizar la URL. Este constructor espera una URL completa, no solo la parte que comienza con la barra diagonal que obtenemos de <code>request.url</code>, por lo que le proporcionamos un nombre de dominio falso para completar. Extrae su ruta, que será algo como <code>\"/<wbr>archivo.<wbr>txt\"</code>, la decodifica para eliminar los códigos de escape estilo <code>%20</code>, y la resuelve en relación con el directorio de trabajo del programa."
              }
            ]
          },
          {
            "id": "ch20-l8-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Tan pronto como configuras un programa para aceptar solicitudes de red, debes empezar a preocuparte por la seguridad. En este caso, si no tenemos cuidado, es probable que terminemos exponiendo accidentalmente todo nuestro sistema de archivos a la red."
              },
              {
                "type": "paragraph",
                "content": "Las rutas de archivos son cadenas en Node. Para mapear dicha cadena a un archivo real, hay una cantidad no trivial de interpretación en juego. Las rutas pueden, por ejemplo, incluir <code>../</code> para hacer referencia a un directorio padre. Así que una fuente obvia de problemas serían las solicitudes de rutas como <code>/<wbr>.<wbr>./<wbr>archivo_secreto</code>."
              },
              {
                "type": "paragraph",
                "content": "Para evitar tales problemas, <code>urlPath</code> utiliza la función <code>resolve</code> del módulo <code>node:path</code>, que resuelve rutas relativas. Luego verifica que el resultado esté <em>debajo</em> del directorio de trabajo. La función <code>process.cwd</code> (donde <code>cwd</code> significa “directorio de trabajo actual”) se puede usar para encontrar este directorio de trabajo. El vínculo <code>sep</code> del paquete <code>node:path</code> es el separador de ruta del sistema: una barra invertida en Windows y una barra diagonal en la mayoría de otros sistemas. Cuando la ruta no comienza con el directorio base, la función arroja un objeto de respuesta de error, usando el código de estado HTTP que indica que el acceso al recurso está prohibido."
              }
            ]
          },
          {
            "id": "ch20-l8-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Configuraremos el método <code>GET</code> para devolver una lista de archivos al leer un directorio y para devolver el contenido del archivo al leer un archivo regular."
              },
              {
                "type": "paragraph",
                "content": "Una pregunta complicada es qué tipo de encabezado <code>Content-Type</code> debemos establecer al devolver el contenido de un archivo. Dado que estos archivos podrían ser cualquier cosa, nuestro servidor no puede simplemente devolver el mismo tipo de contenido para todos ellos. npm puede ayudarnos nuevamente aquí. El paquete <code>mime-types</code> (los indicadores de tipo de contenido como <code>text/plain</code> también se llaman <em>tipos MIME</em>) conoce el tipo correcto para una gran cantidad de extensiones de archivo."
              },
              {
                "type": "paragraph",
                "content": "El siguiente comando de <code>npm</code>, en el directorio donde reside el script del servidor, instala una versión específica de <code>mime</code>:"
              }
            ]
          },
          {
            "id": "ch20-l8-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando un archivo solicitado no existe, el código de estado HTTP correcto a devolver es 404. Utilizaremos la función <code>stat</code>, que busca información sobre un archivo, para averiguar tanto si el archivo existe como si es un directorio."
              },
              {
                "type": "paragraph",
                "content": "Debido a que debe acceder al disco y por lo tanto podría llevar algún tiempo, <code>stat</code> es asíncrono. Dado que estamos utilizando promesas en lugar del estilo de devolución de llamada, debe ser importado desde <code>node:fs/promises</code> en lugar de directamente desde <code>node:fs</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando el archivo no existe, <code>stat</code> lanzará un objeto de error con una propiedad <code>code</code> de <code>\"ENOENT\"</code>. Estos códigos algo oscuros, inspirados en Unix, son la forma en que se reconocen los tipos de error en Node."
              }
            ]
          },
          {
            "id": "ch20-l8-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El objeto <code>stats</code> devuelto por <code>stat</code> nos indica varias cosas sobre un archivo, como su tamaño (propiedad <code>size</code>) y su fecha de modificación (<code>mtime</code>). Aquí nos interesa saber si es un directorio o un archivo regular, lo cual nos dice el método <code>isDirectory</code>."
              },
              {
                "type": "paragraph",
                "content": "Usamos <code>readdir</code> para leer la matriz de archivos en un directorio y devolverla al cliente. Para archivos normales, creamos un flujo de lectura con <code>createReadStream</code> y lo devolvemos como cuerpo, junto con el tipo de contenido que nos proporciona el paquete <code>mime</code> para el nombre del archivo."
              },
              {
                "type": "paragraph",
                "content": "El código para manejar las solicitudes <code>DELETE</code> es ligeramente más sencillo."
              }
            ]
          },
          {
            "id": "ch20-l8-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando una respuesta HTTP no contiene datos, se puede usar el código de estado 204 (“sin contenido”) para indicarlo. Dado que la respuesta a la eliminación no necesita transmitir ninguna información más allá de si la operación tuvo éxito, es sensato devolver eso aquí."
              },
              {
                "type": "paragraph",
                "content": "Es posible que te preguntes por qué intentar eliminar un archivo inexistente devuelve un código de estado de éxito en lugar de un error. Cuando el archivo que se está eliminando no está presente, se podría decir que el objetivo de la solicitud ya se ha cumplido. El estándar HTTP nos anima a hacer solicitudes <em>idempotentes</em>, lo que significa que hacer la misma solicitud varias veces produce el mismo resultado que hacerla una vez. De cierta manera, si intentas eliminar algo que ya no está, el efecto que intentabas lograr se ha alcanzado: la cosa ya no está allí."
              },
              {
                "type": "paragraph",
                "content": "Este es el manejador para las solicitudes <code>PUT</code>:"
              }
            ]
          },
          {
            "id": "ch20-l8-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esta vez no necesitamos verificar si el archivo existe; si lo hace, simplemente lo sobrescribiremos. Nuevamente usamos <code>pipe</code> para mover datos de un flujo legible a uno escribible, en este caso del request al archivo. Pero como <code>pipe</code> no está diseñado para devolver una promesa, debemos escribir un contenedor, <code>pipeStream</code>, que cree una promesa alrededor del resultado de llamar a <code>pipe</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando algo sale mal al abrir el archivo, <code>createWriteStream</code> seguirá devolviendo un flujo, pero ese flujo lanzará un evento de <code>\"error\"</code>. El flujo del request también puede fallar, por ejemplo si la red falla. Por lo tanto, conectamos los eventos de <code>\"error\"</code> de ambos flujos para rechazar la promesa. Cuando <code>pipe</code> haya terminado, cerrará el flujo de salida, lo que hará que lance un evento de <code>\"finalización\"</code>. En ese momento podemos resolver la promesa con éxito (devolviendo nada)."
              },
              {
                "type": "paragraph",
                "content": "El script completo del servidor está disponible en <em>https://eloquentjavascript.net/code/file_server.mjs</em>. Puedes descargarlo y, después de instalar sus dependencias, ejecutarlo con Node para iniciar tu propio servidor de archivos. Y, por supuesto, puedes modificarlo y ampliarlo para resolver los ejercicios de este capítulo o para experimentar."
              }
            ]
          },
          {
            "id": "ch20-l8-s9",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La herramienta de línea de comandos <code>curl</code>, ampliamente disponible en sistemas Unix (como macOS y Linux), se puede utilizar para hacer solicitudes HTTP. La siguiente sesión prueba brevemente nuestro servidor. La opción <code>-X</code> se usa para establecer el método de la solicitud, y <code>-d</code> se utiliza para incluir un cuerpo de solicitud."
              },
              {
                "type": "paragraph",
                "content": "La primera solicitud para <code>file.txt</code> falla ya que el archivo aún no existe. La solicitud <code>PUT</code> crea el archivo y, voilà, la siguiente solicitud lo recupera con éxito. Después de eliminarlo con una solicitud <code>DELETE</code>, el archivo vuelve a estar ausente."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 70
      },
      {
        "id": "ch20-l9",
        "title": "Resumen",
        "sections": [
          {
            "id": "ch20-l9-s0",
            "title": "Resumen",
            "content": [
              {
                "type": "paragraph",
                "content": "Node es un sistema pequeño interesante que nos permite ejecutar JavaScript en un contexto no de navegador. Originalmente fue diseñado para tareas de red para desempeñar el papel de un <em>nodo</em> en una red. Sin embargo, se presta para todo tipo de tareas de script, y si disfrutas escribir JavaScript, automatizar tareas con Node funciona bien."
              },
              {
                "type": "paragraph",
                "content": "NPM proporciona paquetes para todo lo que puedas imaginar (y varias cosas que probablemente nunca se te ocurrirían), y te permite descargar e instalar esos paquetes con el programa <code>npm</code>. Node viene con varios módulos integrados, incluido el módulo <code>node:fs</code> para trabajar con el sistema de archivos y el módulo <code>node:http</code> para ejecutar servidores HTTP.Todo el input y output en Node se hace de forma asíncrona, a menos que uses explícitamente una variante síncrona de una función, como <code>readFileSync</code>. Originalmente, Node usaba devoluciones de llamada para funcionalidades asíncronas, pero el paquete <code>node:fs/promises</code> proporciona una interfaz basada en promesas para el sistema de archivos."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 25
      },
      {
        "id": "ch20-l10",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch20-l10-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "En los sistemas Unix, existe una herramienta de línea de comandos llamada <code>grep</code> que se puede utilizar para buscar rápidamente archivos según una expresión regular."
              },
              {
                "type": "paragraph",
                "content": "Escribe un script de Node que se pueda ejecutar desde la línea de comandos y funcione de manera similar a <code>grep</code>. Trata el primer argumento de la línea de comandos como una expresión regular y trata cualquier argumento adicional como archivos a buscar. Debería mostrar los nombres de los archivos cuyo contenido coincide con la expresión regular."
              },
              {
                "type": "paragraph",
                "content": "Una vez que eso funcione, extiéndelo para que cuando uno de los argumentos sea un directorio, busque en todos los archivos de ese directorio y sus subdirectorios."
              }
            ]
          },
          {
            "id": "ch20-l10-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Utiliza funciones asíncronas o síncronas del sistema de archivos según consideres adecuado. Configurar las cosas para que se soliciten múltiples acciones asíncronas al mismo tiempo podría acelerar un poco las cosas, pero no demasiado, ya que la mayoría de los sistemas de archivos solo pueden leer una cosa a la vez."
              },
              {
                "type": "paragraph",
                "content": "Tu primer argumento de línea de comandos, la expresión regular, se puede encontrar en <code>process.argv[2]</code>. Los archivos de entrada vienen después de eso. Puedes usar el constructor <code>RegExp</code> para convertir una cadena en un objeto de expresión regular."
              },
              {
                "type": "paragraph",
                "content": "Hacer esto de forma síncrona, con <code>readFileSync</code>, es más sencillo, pero si usas <code>node:fs/promises</code> para obtener funciones que devuelven promesas y escribes una función <code>async</code>, el código se ve similar."
              }
            ]
          },
          {
            "id": "ch20-l10-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para averiguar si algo es un directorio, nuevamente puedes usar <code>stat</code> (o <code>statSync</code>) y el método <code>isDirectory</code> del objeto de estadísticas."
              },
              {
                "type": "paragraph",
                "content": "Explorar un directorio es un proceso ramificado. Puedes hacerlo usando una función recursiva o manteniendo un array de tareas pendientes (archivos que aún deben ser explorados). Para encontrar los archivos en un directorio, puedes llamar a <code>readdir</code> o <code>readdirSync</code>. Observa la extraña capitalización: el nombrado de funciones del sistema de archivos de Node se basa vagamente en las funciones estándar de Unix, como <code>readdir</code>, que son todas en minúsculas, pero luego agrega <code>Sync</code> con una letra mayúscula."
              },
              {
                "type": "paragraph",
                "content": "Para obtener el nombre completo de un archivo leído con <code>readdir</code>, debes combinarlo con el nombre del directorio, ya sea añadiendo <code>sep</code> de <code>node:path</code> entre ellos, o utilizando la función <code>join</code> de ese mismo paquete."
              }
            ]
          },
          {
            "id": "ch20-l10-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Aunque el método <code>DELETE</code> en nuestro servidor de archivos es capaz de eliminar directorios (usando <code>rmdir</code>), actualmente el servidor no proporciona ninguna forma de <em>crear</em> un directorio."
              },
              {
                "type": "paragraph",
                "content": "Añade soporte para el método <code>MKCOL</code> (“make collection”), que debería crear un directorio llamando a <code>mkdir</code> desde el módulo <code>node:fs</code>. <code>MKCOL</code> no es un método HTTP ampliamente utilizado, pero sí existe con este mismo propósito en el estándar <em>WebDAV</em>, el cual especifica un conjunto de convenciones sobre HTTP que lo hacen adecuado para crear documentos."
              },
              {
                "type": "paragraph",
                "content": "Puedes usar la función que implementa el método <code>DELETE</code> como base para el método <code>MKCOL</code>. Cuando no se encuentra ningún archivo, intenta crear un directorio con <code>mkdir</code>. Cuando existe un directorio en esa ruta, puedes devolver una respuesta 204 para que las solicitudes de creación de directorios sean idempotentes. Si existe un archivo que no es un directorio en esta ruta, devuelve un código de error. El código 400 (“solicitud incorrecta”) sería apropiado."
              }
            ]
          },
          {
            "id": "ch20-l10-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Dado que el servidor de archivos sirve cualquier tipo de archivo e incluso incluye la cabecera <code>Content-Type</code> correcta, puedes usarlo para servir un sitio web. Dado que permite a todos eliminar y reemplazar archivos, sería un tipo interesante de sitio web: uno que puede ser modificado, mejorado y vandalizado por todos aquellos que se tomen el tiempo de hacer la solicitud HTTP adecuada."
              },
              {
                "type": "paragraph",
                "content": "Escribe una página HTML básica que incluya un archivo JavaScript sencillo. Coloca los archivos en un directorio servido por el servidor de archivos y ábrelos en tu navegador."
              },
              {
                "type": "paragraph",
                "content": "Luego, como ejercicio avanzado o incluso como un proyecto de fin de semana, combina todo el conocimiento que has adquirido de este libro para construir una interfaz más amigable para modificar el sitio web—desde <em>dentro</em> del sitio web."
              }
            ]
          },
          {
            "id": "ch20-l10-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Utiliza un formulario HTML para editar el contenido de los archivos que conforman el sitio web, permitiendo al usuario actualizarlos en el servidor mediante solicitudes HTTP, como se describe en el Capítulo 18."
              },
              {
                "type": "paragraph",
                "content": "Comienza permitiendo que solo un archivo sea editable. Luego haz que el usuario pueda seleccionar qué archivo editar. Aprovecha el hecho de que nuestro servidor de archivos devuelve listas de archivos al leer un directorio."
              },
              {
                "type": "paragraph",
                "content": "No trabajes directamente en el código expuesto por el servidor de archivos ya que si cometes un error, es probable que dañes los archivos allí. En su lugar, mantén tu trabajo fuera del directorio accesible al público y cópialo allí al hacer pruebas."
              }
            ]
          },
          {
            "id": "ch20-l10-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Puedes crear un elemento <code>&lt;textarea&gt;</code> para contener el contenido del archivo que se está editando. Una solicitud <code>GET</code>, utilizando <code>fetch</code>, puede recuperar el contenido actual del archivo. Puedes usar URLs relativas como <em>index.html</em>, en lugar de <em>http://localhost:8000/index.html</em>, para hacer referencia a archivos en el mismo servidor que el script en ejecución."
              },
              {
                "type": "paragraph",
                "content": "Luego, cuando el usuario haga clic en un botón (puedes usar un elemento <code>&lt;form&gt;</code> y el evento <code>\"submit\"</code>), realiza una solicitud <code>PUT</code> a la misma URL, con el contenido del <code>&lt;textarea&gt;</code> como cuerpo de la solicitud, para guardar el archivo."
              },
              {
                "type": "paragraph",
                "content": "Puedes luego agregar un elemento <code>&lt;select&gt;</code> que contenga todos los archivos en el directorio principal del servidor mediante la adición de elementos <code>&lt;option&gt;</code> que contengan las líneas devueltas por una solicitud <code>GET</code> a la URL <code>/</code>. Cuando el usuario seleccione otro archivo (un evento <code>\"change\"</code> en el campo), el script debe recuperar y mostrar ese archivo. Al guardar un archivo, utiliza el nombre de archivo actualmente seleccionado."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 55
      }
    ]
  },
  {
    "id": "ch21",
    "number": 21,
    "title": "Proyecto: Sitio web de intercambio de habilidades",
    "titleEs": "Proyecto: Sitio web de intercambio de habilidades",
    "part": "part3",
    "partLabel": "Parte 3: Node.js",
    "icon": "BookOpen",
    "description": "Si tienes conocimiento, permite que otros enciendan sus velas en él....",
    "isProject": true,
    "totalXP": 305,
    "lessons": [
      {
        "id": "ch21-l0",
        "title": "Introducción",
        "sections": [
          {
            "id": "ch21-l0-s0",
            "title": "Introducción",
            "content": [
              {
                "type": "blockquote",
                "content": "Si tienes conocimiento, permite que otros enciendan sus velas en él. Margaret Fuller"
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Sitio web de intercambio de habilidades __ Eloquent JavaScript_files/chapter_picture_21.jpg",
                "alt": "Ilustración que muestra dos monociclos apoyados en un buzón"
              },
              {
                "type": "paragraph",
                "content": "Una reunión de intercambio de habilidades es un evento en el que personas con un interés compartido se reúnen y dan pequeñas presentaciones informales sobre cosas que saben. En una reunión de intercambio de habilidades de jardinería, alguien podría explicar cómo cultivar apio. O en un grupo de intercambio de habilidades de programación, podrías pasar y contarles a la gente sobre Node.js."
              }
            ]
          },
          {
            "id": "ch21-l0-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En este último capítulo del proyecto, nuestro objetivo es configurar un sitio web para gestionar las charlas impartidas en una reunión de intercambio de habilidades. Imagina un pequeño grupo de personas que se reúnen regularmente en la oficina de uno de los miembros para hablar sobre monociclos. El organizador anterior de las reuniones se mudó a otra ciudad y nadie se ofreció a asumir esta tarea. Queremos un sistema que permita a los participantes proponer y discutir charlas entre ellos, sin un organizador activo."
              },
              {
                "type": "paragraph",
                "content": "Al igual que en el capítulo anterior, parte del código en este capítulo está escrito para Node.js y es poco probable que funcione si se ejecuta directamente en la página HTML que estás viendo. El código completo del proyecto se puede descargar desde <em>https://eloquentjavascript.net/code/skillsharing.zip</em>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch21-l1",
        "title": "Diseño",
        "sections": [
          {
            "id": "ch21-l1-s0",
            "title": "Diseño",
            "content": [
              {
                "type": "paragraph",
                "content": "Este proyecto tiene una parte de <em>servidor</em>, escrita para Node.js, y una parte de <em>cliente</em>, escrita para el navegador. El servidor almacena los datos del sistema y los proporciona al cliente. También sirve los archivos que implementan el sistema del lado del cliente."
              },
              {
                "type": "paragraph",
                "content": "El servidor mantiene la lista de charlas propuestas para la próxima reunión, y el cliente muestra esta lista. Cada charla tiene un nombre de presentador, un título, un resumen y una matriz de comentarios asociados. El cliente permite a los usuarios proponer nuevas charlas (agregándolas a la lista), eliminar charlas y comentar en charlas existentes. Cada vez que el usuario realiza un cambio de este tipo, el cliente realiza una solicitud HTTP para informar al servidor al respecto."
              },
              {
                "type": "image",
                "src": "/courses/eloquent/Proyecto_ Sitio web de intercambio de habilidades __ Eloquent JavaScript_files/skillsharing.png",
                "alt": "Captura de pantalla del sitio web de intercambio de habilidades"
              },
              {
                "type": "paragraph",
                "content": "La aplicación se configurará para mostrar una vista <em>en vivo</em> de las charlas propuestas actuales y sus comentarios. Cada vez que alguien, en algún lugar, envíe una nueva charla o agregue un comentario, todas las personas que tengan la página abierta en sus navegadores deberían ver el cambio de inmediato. Esto plantea un desafío—no hay forma de que un servidor web abra una conexión a un cliente, ni hay una buena forma de saber qué clientes están viendo actualmente un sitio web dado."
              }
            ]
          },
          {
            "id": "ch21-l1-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Una solución común a este problema se llama <em>long polling</em>, que resulta ser una de las motivaciones del diseño de Node."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 30
      },
      {
        "id": "ch21-l2",
        "title": "Long polling",
        "sections": [
          {
            "id": "ch21-l2-s0",
            "title": "Long polling",
            "content": [
              {
                "type": "paragraph",
                "content": "Para poder notificar inmediatamente a un cliente que algo ha cambiado, necesitamos una conexión con ese cliente. Dado que los navegadores web tradicionalmente no aceptan conexiones y los clientes a menudo están detrás de routers que bloquearían tales conexiones de todos modos, no es práctico que sea el servidor quien inicie esta conexión."
              },
              {
                "type": "paragraph",
                "content": "Podemos hacer que el cliente abra la conexión y la mantenga activa para que el servidor pueda usarla para enviar información cuando sea necesario."
              },
              {
                "type": "paragraph",
                "content": "Sin embargo, una solicitud HTTP permite solo un flujo simple de información: el cliente envía una solicitud, el servidor responde una sola vez, y eso es todo. Existe una tecnología llamada <em>WebSockets</em> que permite abrir conexiones para el intercambio arbitrario de datos. Pero usarlas adecuadamente es algo complicado."
              }
            ]
          },
          {
            "id": "ch21-l2-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "En este capítulo, utilizamos una técnica más sencilla—long polling—donde los clientes preguntan continuamente al servidor por nueva información mediante solicitudes HTTP regulares, y el servidor retiene su respuesta cuando no tiene nada nuevo que informar."
              },
              {
                "type": "paragraph",
                "content": "Mientras el cliente se asegure de tener una solicitud de sondeo abierta constantemente, recibirá información del servidor rápidamente cuando esté disponible. Por ejemplo, si Fatma tiene nuestra aplicación de intercambio de habilidades abierta en su navegador, ese navegador habrá solicitado actualizaciones y estará esperando una respuesta a esa solicitud. Cuando Iman envía una charla sobre “Extreme Downhill Unicycling”, el servidor notará que Fatma está esperando actualizaciones y enviará una respuesta que contiene la nueva charla a su solicitud pendiente. El navegador de Fatma recibirá los datos y actualizará la pantalla para mostrar la charla."
              },
              {
                "type": "paragraph",
                "content": "Para evitar que las conexiones se agoten por tiempo (se aborten debido a una falta de actividad), las técnicas de long polling suelen establecer un tiempo máximo para cada solicitud, tras el cual el servidor responderá de todos modos, aunque no tenga nada que informar. Entonces, el cliente puede iniciar una nueva solicitud. Reiniciar periódicamente la solicitud también hace que la técnica sea más robusta, permitiendo a los clientes recuperarse de fallos temporales de conexión o problemas de servidor."
              }
            ]
          },
          {
            "id": "ch21-l2-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un servidor ocupado que utiliza long polling puede tener miles de solicitudes en espera, y por lo tanto conexiones TCP abiertas. Node, que facilita la gestión de muchas conexiones sin crear un hilo de control separado para cada una, es ideal para este tipo de sistema."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 35
      },
      {
        "id": "ch21-l3",
        "title": "Interfaz HTTP",
        "sections": [
          {
            "id": "ch21-l3-s0",
            "title": "Interfaz HTTP",
            "content": [
              {
                "type": "paragraph",
                "content": "Antes de comenzar a diseñar el servidor o el cliente, pensemos en el punto donde se conectan: la interfaz HTTP a través de la cual se comunican."
              },
              {
                "type": "paragraph",
                "content": "Utilizaremos JSON como formato de nuestro cuerpo de solicitud y respuesta. Al igual que en el servidor de archivos del Capítulo 20, intentaremos hacer un buen uso de los métodos y cabeceras HTTP. La interfaz se centra en la ruta <code>/talks</code>. Las rutas que no comienzan con <code>/talks</code> se utilizarán para servir archivos estáticos—el código HTML y JavaScript para el sistema del lado del cliente."
              },
              {
                "type": "paragraph",
                "content": "Una solicitud <code>GET</code> a <code>/talks</code> devuelve un documento JSON como este:"
              }
            ]
          },
          {
            "id": "ch21-l3-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Crear una nueva charla se hace haciendo una solicitud <code>PUT</code> a una URL como <code>/talks/Unituning</code>, donde la parte después de la segunda barra es el título de la charla. El cuerpo de la solicitud <code>PUT</code> debe contener un objeto JSON que tenga propiedades <code>presenter</code> y <code>summary</code>."
              },
              {
                "type": "paragraph",
                "content": "Dado que los títulos de las charlas pueden contener espacios y otros caracteres que normalmente no aparecen en una URL, las cadenas de título deben ser codificadas con la función <code>encodeURIComponent</code> al construir una URL de ese tipo."
              },
              {
                "type": "paragraph",
                "content": "Una solicitud para crear una charla sobre hacer el caballito podría ser algo así:"
              }
            ]
          },
          {
            "id": "ch21-l3-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Estas URLs también admiten solicitudes <code>GET</code> para recuperar la representación JSON de una charla y solicitudes <code>DELETE</code> para eliminar una charla."
              },
              {
                "type": "paragraph",
                "content": "Agregar un comentario a una charla se hace con una solicitud <code>POST</code> a una URL como <code>/<wbr>talks/<wbr>Unituning/<wbr>comments</code>, con un cuerpo JSON que tiene propiedades <code>author</code> y <code>message</code>."
              },
              {
                "type": "paragraph",
                "content": "Para soportar encuestas prolongadas, las solicitudes <code>GET</code> a <code>/talks</code> pueden incluir encabezados adicionales que informen al servidor para retrasar la respuesta si no hay nueva información disponible. Usaremos un par de encabezados normalmente destinados a gestionar el almacenamiento en caché: <code>ETag</code> y <code>If-None-Match</code>."
              }
            ]
          },
          {
            "id": "ch21-l3-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los servidores pueden incluir un encabezado <code>ETag</code> (“etiqueta de entidad”) en una respuesta. Su valor es una cadena que identifica la versión actual del recurso. Los clientes, al solicitar posteriormente ese recurso de nuevo, pueden hacer una <em>solicitud condicional</em> incluyendo un encabezado <code>If-None-Match</code> cuyo valor contenga esa misma cadena. Si el recurso no ha cambiado, el servidor responderá con el código de estado 304, que significa “no modificado”, indicando al cliente que su versión en caché sigue siendo actual. Cuando la etiqueta no coincide, el servidor responde como de costumbre."
              },
              {
                "type": "paragraph",
                "content": "Necesitamos algo como esto, donde el cliente puede decirle al servidor qué versión de la lista de charlas tiene, y el servidor responde solo cuando esa lista ha cambiado. Pero en lugar de devolver inmediatamente una respuesta 304, el servidor debería demorar la respuesta y devolverla solo cuando haya algo nuevo disponible o haya transcurrido una cantidad de tiempo determinada. Para distinguir las solicitudes de encuestas prolongadas de las solicitudes condicionales normales, les damos otro encabezado, <code>Prefer: wait=90</code>, que le indica al servidor que el cliente está dispuesto a esperar hasta 90 segundos por la respuesta.El servidor mantendrá un número de versión que actualiza cada vez que cambian las charlas y lo utilizará como valor <code>ETag</code>. Los clientes pueden hacer solicitudes como esta para ser notificados cuando las charlas cambien:"
              },
              {
                "type": "paragraph",
                "content": "El protocolo descrito aquí no realiza ningún control de acceso. Cualquiera puede comentar, modificar charlas e incluso eliminarlas. (Dado que Internet está lleno de matones, poner un sistema en línea sin una protección adicional probablemente no terminaría bien)."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      },
      {
        "id": "ch21-l4",
        "title": "El servidor",
        "sections": [
          {
            "id": "ch21-l4-s0",
            "title": "El servidor",
            "content": [
              {
                "type": "paragraph",
                "content": "Comencemos construyendo la parte del programa del lado del servidor. El código en esta sección se ejecuta en Node.js."
              },
              {
                "type": "paragraph",
                "content": "Nuestro servidor utilizará <code>createServer</code> de Node para iniciar un servidor HTTP. En la función que maneja una nueva solicitud, debemos distinguir entre los diferentes tipos de solicitudes (como se determina por el método y la ruta) que soportamos. Esto se puede hacer con una larga cadena de declaraciones <code>if</code>, pero hay una manera más elegante."
              },
              {
                "type": "paragraph",
                "content": "Un <em>enrutador</em> es un componente que ayuda a despachar una solicitud a la función que puede manejarla. Puedes indicarle al enrutador, por ejemplo, que las solicitudes <code>PUT</code> con una ruta que coincida con la expresión regular <code>/<wbr>^\\/<wbr>talks\\/<wbr>([^\\/<wbr>]+)$/<wbr></code> (<code>/talks/</code> seguido de un título de charla) pueden ser manejadas por una función dada. Además, puede ayudar a extraer las partes significativas de la ruta (en este caso el título de la charla), envueltas en paréntesis en la expresión regular, y pasarlas a la función manejadora."
              }
            ]
          },
          {
            "id": "ch21-l4-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Hay varios paquetes de enrutadores buenos en NPM, pero aquí escribiremos uno nosotros mismos para ilustrar el principio."
              },
              {
                "type": "paragraph",
                "content": "Este es <code>router.mjs</code>, que luego <code>importaremos</code> desde nuestro módulo del servidor:"
              },
              {
                "type": "paragraph",
                "content": "El módulo exporta la clase <code>Router</code>. Un objeto de enrutador te permite registrar manejadores para métodos específicos y patrones de URL con su método <code>add</code>. Cuando una solicitud se resuelve con el método <code>resolve</code>, el enrutador llama al manejador cuyo método y URL coinciden con la solicitud y devuelve su resultado."
              }
            ]
          },
          {
            "id": "ch21-l4-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Las funciones manejadoras se llaman con el valor <code>context</code> dado a <code>resolve</code>. Utilizaremos esto para darles acceso al estado de nuestro servidor. Además, reciben las cadenas coincidentes para cualquier grupo que hayan definido en su expresión regular, y el objeto de solicitud. Las cadenas deben ser decodificadas de la URL ya que la URL cruda puede contener códigos estilo <code>%20</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando una solicitud no coincide con ninguno de los tipos de solicitud definidos en nuestro enrutador, el servidor debe interpretarlo como una solicitud de un archivo en el directorio <code>public</code>. Sería posible usar el servidor de archivos definido en el Capítulo 20 para servir dichos archivos, pero ni necesitamos ni queremos admitir solicitudes <code>PUT</code> y <code>DELETE</code> en archivos, y nos gustaría tener funciones avanzadas como el soporte para almacenamiento en caché. Así que usemos en cambio un servidor de archivos estático sólido y bien probado de NPM."
              },
              {
                "type": "paragraph",
                "content": "Opté por <code>serve-static</code>. Este no es el único servidor de este tipo en NPM, pero funciona bien y se ajusta a nuestros propósitos. El paquete <code>serve-static</code> exporta una función que puede ser llamada con un directorio raíz para producir una función manipuladora de solicitudes. La función manipuladora acepta los argumentos <code>request</code> y <code>response</code> proporcionados por el servidor de <code>\"node:http\"</code>, y un tercer argumento, una función que se llamará si ningún archivo coincide con la solicitud. Queremos que nuestro servidor primero compruebe las solicitudes que deberíamos manejar de manera especial, según lo definido en el enrutador, por lo que lo envolvemos en otra función."
              }
            ]
          },
          {
            "id": "ch21-l4-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La función <code>serveFromRouter</code> tiene la misma interfaz que <code>fileServer</code>, tomando los argumentos <code>(request, response, next)</code>. Esto nos permite “encadenar” varios manipuladores de solicitudes, permitiendo que cada uno maneje la solicitud o pase la responsabilidad de eso al siguiente manejador. El manejador final, <code>notFound</code>, simplemente responde con un error de “no encontrado”."
              },
              {
                "type": "paragraph",
                "content": "Nuestra función <code>serveFromRouter</code> utiliza una convención similar a la del servidor de archivos del capítulo anterior para las respuestas: los manejadores en el enrutador devuelven promesas que se resuelven en objetos que describen la respuesta."
              },
              {
                "type": "paragraph",
                "content": "Las charlas que se han propuesto se almacenan en la propiedad <code>talks</code> del servidor, un objeto cuyas propiedades son los títulos de las charlas. Agregaremos algunos controladores a nuestro enrutador que expongan estos como recursos HTTP bajo <code>/<wbr>charlas/<wbr>[título]</code>."
              }
            ]
          },
          {
            "id": "ch21-l4-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El controlador para las solicitudes que <code>GET</code> una sola charla debe buscar la charla y responder ya sea con los datos JSON de la charla o con una respuesta de error 404."
              },
              {
                "type": "paragraph",
                "content": "Eliminar una charla se hace eliminándola del objeto <code>talks</code>."
              },
              {
                "type": "paragraph",
                "content": "El método <code>updated</code>, que definiremos más adelante, notifica a las solicitudes de espera larga sobre el cambio."
              }
            ]
          },
          {
            "id": "ch21-l4-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Un controlador que necesita leer cuerpos de solicitud es el controlador <code>PUT</code>, que se utiliza para crear nuevas charlas. Debe verificar si los datos que se le proporcionaron tienen propiedades <code>presentador</code> y <code>resumen</code>, que son cadenas de texto. Cualquier dato que provenga de fuera del sistema podría ser un sinsentido y no queremos corromper nuestro modelo de datos interno o fallar cuando lleguen solicitudes incorrectas."
              },
              {
                "type": "paragraph",
                "content": "Si los datos parecen válidos, el controlador almacena un objeto que representa la nueva charla en el objeto <code>talks</code>, posiblemente sobrescribiendo una charla existente con este título, y nuevamente llama a <code>updated</code>."
              },
              {
                "type": "paragraph",
                "content": "Para leer el cuerpo del flujo de solicitud, utilizaremos la función <code>json</code> de <code>\"node:stream/<wbr>consumers\"</code>, que recopila los datos en el flujo y luego los analiza como JSON. Hay exportaciones similares llamadas <code>text</code> (para leer el contenido como una cadena) y <code>buffer</code> (para leerlo como datos binarios) en este paquete. Dado que <code>json</code> es un nombre genérico, la importación lo renombra a <code>readJSON</code> para evitar confusiones."
              }
            ]
          },
          {
            "id": "ch21-l4-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Intentar agregar un comentario a una charla inexistente devuelve un error 404."
              },
              {
                "type": "paragraph",
                "content": "El aspecto más interesante del servidor es la parte que maneja la larga espera. Cuando llega una solicitud <code>GET</code> para <code>/charlas</code>, puede ser una solicitud regular o una solicitud de larga espera."
              },
              {
                "type": "paragraph",
                "content": "Habrá varios lugares en los que debamos enviar una matriz de charlas al cliente, por lo que primero definimos un método auxiliar que construya dicha matriz e incluya un encabezado <code>ETag</code> en la respuesta."
              }
            ]
          },
          {
            "id": "ch21-l4-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El controlador en sí mismo necesita examinar los encabezados de la solicitud para ver si están presentes los encabezados <code>If-None-Match</code> y <code>Prefer</code>. Node almacena los encabezados, cuyos nombres se especifican como insensibles a mayúsculas y minúsculas, bajo sus nombres en minúsculas."
              },
              {
                "type": "paragraph",
                "content": "Si no se proporcionó ninguna etiqueta o se proporcionó una etiqueta que no coincide con la versión actual del servidor, el controlador responde con la lista de charlas. Si la solicitud es condicional y las charlas no han cambiado, consultamos el encabezado <code>Prefer</code> para ver si debemos retrasar la respuesta o responder de inmediato."
              },
              {
                "type": "paragraph",
                "content": "Las funciones de devolución de llamada para solicitudes retardadas se almacenan en la matriz <code>waiting</code> del servidor para que puedan ser notificadas cuando ocurra algo. El método <code>waitForChanges</code> también establece inmediatamente un temporizador para responder con un estado 304 cuando la solicitud haya esperado el tiempo suficiente."
              }
            ]
          },
          {
            "id": "ch21-l4-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Registrar un cambio con <code>updated</code> incrementa la propiedad <code>versión</code> y despierta todas las solicitudes en espera."
              },
              {
                "type": "paragraph",
                "content": "Eso concluye el código del servidor. Si creamos una instancia de <code>SkillShareServer</code> y la iniciamos en el puerto 8000, el servidor HTTP resultante servirá archivos desde el subdirectorio <code>public</code> junto con una interfaz para manejar charlas bajo la URL <code>/talks</code>."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 65
      },
      {
        "id": "ch21-l5",
        "title": "El cliente",
        "sections": [
          {
            "id": "ch21-l5-s0",
            "title": "El cliente",
            "content": [
              {
                "type": "paragraph",
                "content": "La parte del cliente del sitio web de intercambio de habilidades consiste en tres archivos: una pequeña página HTML, una hoja de estilos y un archivo JavaScript."
              },
              {
                "type": "paragraph",
                "content": "Es una convención ampliamente utilizada para servidores web intentar servir un archivo llamado <code>index.html</code> cuando se realiza una solicitud directamente a una ruta que corresponde a un directorio. El módulo de servidor de archivos que utilizamos, <code>serve-static</code>, soporta esta convención. Cuando se realiza una solicitud a la ruta <code>/</code>, el servidor busca el archivo <code>./<wbr>public/<wbr>index.<wbr>html</code> (<code>./public</code> siendo la raíz que le dimos) y devuelve ese archivo si se encuentra."
              },
              {
                "type": "paragraph",
                "content": "Por lo tanto, si queremos que una página aparezca cuando un navegador apunta a nuestro servidor, deberíamos colocarla en <code>public/<wbr>index.<wbr>html</code>. Este es nuestro archivo de índice:"
              }
            ]
          },
          {
            "id": "ch21-l5-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Define el título del documento e incluye una hoja de estilos, que define algunos estilos para, entre otras cosas, asegurarse de que haya algo de espacio entre las charlas. Luego agrega un encabezado en la parte superior de la página y carga el script que contiene la aplicación del cliente."
              },
              {
                "type": "paragraph",
                "content": "El estado de la aplicación consiste en la lista de charlas y el nombre del usuario, y lo almacenaremos en un objeto <code>{charlas, usuario}</code>. No permitimos que la interfaz de usuario manipule directamente el estado ni envíe solicitudes HTTP. En cambio, puede emitir <em>acciones</em> que describen lo que el usuario está intentando hacer."
              },
              {
                "type": "paragraph",
                "content": "La función <code>handleAction</code> toma una acción de este tipo y la lleva a cabo. Debido a que nuestras actualizaciones de estado son tan simples, los cambios de estado se manejan en la misma función."
              }
            ]
          },
          {
            "id": "ch21-l5-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Almacenaremos el nombre del usuario en <code>localStorage</code> para que pueda ser restaurado cuando se cargue la página."
              },
              {
                "type": "paragraph",
                "content": "Las acciones que necesitan involucrar al servidor realizan peticiones a la red, utilizando <code>fetch</code>, a la interfaz HTTP descrita anteriormente. Utilizamos una función de envoltura, <code>fetchOK</code>, que se asegura de que la promesa devuelta sea rechazada cuando el servidor devuelve un código de error."
              },
              {
                "type": "paragraph",
                "content": "Esta función auxiliar se utiliza para construir una URL para una charla con un título dado."
              }
            ]
          },
          {
            "id": "ch21-l5-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando la petición falla, no queremos que nuestra página simplemente se quede ahí, sin hacer nada sin explicación. Así que definimos una función llamada <code>reportError</code>, que al menos muestra al usuario un cuadro de diálogo que le informa que algo salió mal."
              },
              {
                "type": "paragraph",
                "content": "Utilizaremos un enfoque similar al que vimos en el Capítulo 19, dividiendo la aplicación en componentes. Pero dado que algunos de los componentes nunca necesitan actualizarse o siempre se redibujan por completo cuando se actualizan, definiremos aquellos no como clases, sino como funciones que devuelven directamente un nodo DOM. Por ejemplo, aquí hay un componente que muestra el campo donde el usuario puede ingresar su nombre:"
              },
              {
                "type": "paragraph",
                "content": "La función <code>elt</code> utilizada para construir elementos DOM es la misma que usamos en el Capítulo 19."
              }
            ]
          },
          {
            "id": "ch21-l5-s4",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Se utiliza una función similar para renderizar charlas, que incluyen una lista de comentarios y un formulario para agregar un nuevo comentario."
              },
              {
                "type": "paragraph",
                "content": "El controlador de evento <code>\"submit\"</code> llama a <code>form.reset</code> para limpiar el contenido del formulario después de crear una acción <code>\"newComment\"</code>."
              },
              {
                "type": "paragraph",
                "content": "Cuando se crean piezas moderadamente complejas del DOM, este estilo de programación comienza a verse bastante desordenado. Para evitar esto, a menudo la gente utiliza un <em>lenguaje de plantillas</em>, que permite escribir la interfaz como un archivo HTML con algunos marcadores especiales para indicar dónde van los elementos dinámicos. O utilizan <em>JSX</em>, un dialecto de JavaScript no estándar que te permite escribir algo muy parecido a etiquetas HTML en tu programa como si fueran expresiones JavaScript. Ambos enfoques utilizan herramientas adicionales para preprocesar el código antes de que pueda ser ejecutado, lo cual evitaremos en este capítulo."
              }
            ]
          },
          {
            "id": "ch21-l5-s5",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Los comentarios son simples de renderizar."
              },
              {
                "type": "paragraph",
                "content": "Finalmente, el formulario que el usuario puede usar para crear una nueva charla se representa de la siguiente manera:"
              },
              {
                "type": "paragraph",
                "content": "Para iniciar la aplicación necesitamos la lista actual de charlas. Dado que la carga inicial está estrechamente relacionada con el proceso de sondeo prolongado, el <code>ETag</code> de la carga debe ser utilizado al sondear, escribiremos una función que siga sondeando al servidor en busca de <code>/charlas</code> y llame a una función de devolución de llamada cuando un nuevo conjunto de charlas esté disponible."
              }
            ]
          },
          {
            "id": "ch21-l5-s6",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Esta es una función <code>async</code> para facilitar el bucle y la espera de la solicitud. Ejecuta un bucle infinito que, en cada iteración, recupera la lista de charlas, ya sea normalmente o, si esta no es la primera solicitud, con las cabeceras incluidas que la convierten en una solicitud de sondeo prolongado."
              },
              {
                "type": "paragraph",
                "content": "Cuando una solicitud falla, la función espera un momento y luego intenta nuevamente. De esta manera, si tu conexión de red se interrumpe por un tiempo y luego vuelve, la aplicación puede recuperarse y continuar actualizándose. La promesa resuelta a través de <code>setTimeout</code> es una forma de forzar a la función <code>async</code> a esperar."
              },
              {
                "type": "paragraph",
                "content": "Cuando el servidor devuelve una respuesta 304, eso significa que una solicitud de intercambio de larga duración expiró, por lo que la función debería comenzar inmediatamente la siguiente solicitud. Si la respuesta es un estado 200 normal, su cuerpo se lee como JSON y se pasa a la devolución de llamada, y el valor del encabezado <code>ETag</code> se almacena para la próxima iteración."
              }
            ]
          },
          {
            "id": "ch21-l5-s7",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "El siguiente componente une toda la interfaz de usuario:"
              },
              {
                "type": "paragraph",
                "content": "Cuando las charlas cambian, este componente las vuelve a dibujar todas. Esto es simple pero también derrochador. Hablaremos sobre eso en los ejercicios."
              },
              {
                "type": "paragraph",
                "content": "Podemos iniciar la aplicación de esta manera:"
              }
            ]
          },
          {
            "id": "ch21-l5-s8",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Si ejecutas el servidor y abres dos ventanas del navegador para <em>http://localhost:8000</em> una al lado de la otra, puedes ver que las acciones que realizas en una ventana son inmediatamente visibles en la otra."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 65
      },
      {
        "id": "ch21-l6",
        "title": "Ejercicios",
        "sections": [
          {
            "id": "ch21-l6-s0",
            "title": "Ejercicios",
            "content": [
              {
                "type": "paragraph",
                "content": "Los siguientes ejercicios implicarán modificar el sistema definido en este capítulo. Para trabajar en ellos, asegúrate de descargar primero el código (<em>https://eloquentjavascript.net/code/skillsharing.zip</em>), tener Node instalado (<em>https://nodejs.org</em>), e instalar la dependencia del proyecto con <code>npm install</code>."
              },
              {
                "type": "paragraph",
                "content": "El servidor de intercambio de habilidades mantiene sus datos puramente en memoria. Esto significa que cuando se produce un fallo o se reinicia por cualquier motivo, se pierden todas las charlas y comentarios."
              },
              {
                "type": "paragraph",
                "content": "Extiende el servidor para que almacene los datos de las charlas en disco y vuelva a cargar automáticamente los datos cuando se reinicie. No te preocupes por la eficiencia, haz lo más simple que funcione."
              }
            ]
          },
          {
            "id": "ch21-l6-s1",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "La solución más simple que se me ocurre es codificar todo el objeto <code>talks</code> como JSON y volcarlo en un archivo con <code>writeFile</code>. Ya existe un método (<code>updated</code>) que se llama cada vez que cambian los datos del servidor. Se puede ampliar para escribir los nuevos datos en el disco."
              },
              {
                "type": "paragraph",
                "content": "Elige un nombre de archivo, por ejemplo <code>./talks.json</code>. Cuando el servidor se inicie, puede intentar leer ese archivo con <code>readFile</code>, y si tiene éxito, el servidor puede usar el contenido del archivo como sus datos iniciales."
              },
              {
                "type": "paragraph",
                "content": "La remodelación completa de las charlas funciona bastante bien porque generalmente no se puede distinguir entre un nodo de DOM y su sustitución idéntica. Pero hay excepciones. Si empiezas a escribir algo en el campo de comentarios para una charla en una ventana del navegador y luego, en otra, añades un comentario a esa charla, el campo en la primera ventana se volverá a dibujar, eliminando tanto su contenido como su enfoque."
              }
            ]
          },
          {
            "id": "ch21-l6-s2",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Cuando varias personas están añadiendo comentarios al mismo tiempo, esto podría resultar molesto. ¿Puedes idear una manera de resolverlo?"
              },
              {
                "type": "paragraph",
                "content": "La mejor manera de hacerlo probablemente sea convertir el componente de la charla en un objeto, con un método <code>syncState</code>, para que se puedan actualizar para mostrar una versión modificada de la charla. Durante el funcionamiento normal, la única forma en que una charla puede cambiar es añadiendo más comentarios, por lo que el método <code>syncState</code> puede ser relativamente sencillo."
              },
              {
                "type": "paragraph",
                "content": "La parte difícil es que, cuando llega una lista modificada de charlas, tenemos que conciliar la lista existente de componentes de DOM con las charlas de la nueva lista: eliminar los componentes cuya charla fue eliminada y actualizar los componentes cuya charla cambió."
              }
            ]
          },
          {
            "id": "ch21-l6-s3",
            "title": "Continuación",
            "content": [
              {
                "type": "paragraph",
                "content": "Para hacer esto, podría ser útil mantener una estructura de datos que almacene los componentes de las charlas bajo los títulos de las charlas para que puedas averiguar fácilmente si existe un componente para una charla dada. Luego puedes recorrer la nueva matriz de charlas y, para cada una de ellas, sincronizar un componente existente o crear uno nuevo. Para eliminar los componentes de charlas eliminadas, también tendrás que recorrer los componentes y comprobar si las charlas correspondientes aún existen."
              }
            ]
          }
        ],
        "exercises": [],
        "xpReward": 40
      }
    ]
  }
]